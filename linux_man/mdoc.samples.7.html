<HTML>
<HEAD>
<META http-equiv="content-type" content="text/html; charset=gb2312">
<META name="man2html Chinese version">
<TITLE>MDOC.SAMPLES</TITLE>
</HEAD>
<BODY>
<H1>MDOC.SAMPLES</H1>
Section: Environments, Tables, and Troff Macros (7)<BR>Index</A>

<H2>NAME (名字)</H2>

<B>mdoc.samples</B>

 - 用

<B>-mdoc</B>

编写
BSD 手册 的 示范教程

<H2>SYNOPSIS (总览)</H2>

<B>man mdoc.samples</B>


<H2>DESCRIPTION (描述)</H2>

这个 示范教程 用于 编写
BSD 手册页 (manual page), 它 使用了
<B>-mdoc</B>

宏定义包, 这是个
<I>基于内容</I>

和
<I>基于宏域 (domain </I><B>-base)</B>



的 格式化包, 交由
troff</A>(1)


处理. 它的 前身
-man7


包, 定义了 页面布局 (page layout), 但是 把 诸如 字体控制 和 其他 排版 细节 
留给了 每一个 作者. 在
<B>-mdoc </B>

包里, 页面布局宏 构成了
<I>页结构宏域 (page structure domain)</I>

它 由 标题, 小节首部, 显示 (displays) 和 列表 宏 组成. 这些 基本项目 影响
正文 在 格式化页上 的 物理位置.
作为 页结构宏域 的 补充, 这里 还 定义了 另外 两个 宏域, 手册宏域 和
基本正文宏域. 基本正文宏域 定义了 一些 宏, 执行 例如 引文 或 文字强调 
之类的任务.
手册宏域 定义的宏 是 非正式 日常用语 的 子集, 用于 描述 命令, 例程
和 相关的
BSD 文件.
手册宏域里 的 宏 用来处理 命令名, 命令行参数和选项, 函数名称, 函数参数,
路径, 变量, 以及 到 其他手册页 的 参照 等.
这些 域项 留有 为 作者 和 手册页的 未来用户 设置的 值.
希望 从 手册集中 获得的 一致性 能够为 将来的 文档工具 提供 更简单的 转换.
<P>

从 整个的
UNIX
手册页 上 来看, 每个 手册项
可以 简单的 理解为 一个 man page, 不用 注意 它的 实际长度, 
也没有 性别歧视 意图. (译注: 可能是双关语, man page...男人页)

<H2>开始 GETTING STARTED</H2>

因为 人们 通常是 为了 能够 马上 使用 这些材料 的 时候 才 阅读 教程，所以 
我们 假设 此文档的 用户 是 缺乏耐心的．下面 简述一下 这份文档 剩余部分 
的 组织:
<OL><P>

<LI>

<B>TROFF 特性</B>

<DL COMPACT>
<P>

<DT><B>&quot;使用宏&quot;</B>
<DD>
 
<DT><B>&quot;参数中传递空白符&quot;</B>
<DD>
 
<DT><B>&quot;尾部的空白符&quot;</B>
<DD>
 
<DT><B>&quot;转义特殊字符&quot;</B>
<DD>
 
</DL>
<P>

<LI>

<B>手册页的结构分析</B>

<DL COMPACT>
<P>

<DT><B>&quot;手册页的模板&quot;</B>
<DD>
 
</DL>
<P>

<LI>

<B>标题宏</B>

 
<LI>

<B>手册宏域和基本正文宏域的介绍</B>

 
<DL COMPACT>
<P>

<DT><B>&quot;名称背后 ...&quot;</B>
<DD>
 
<DT><B>&quot;基本语法&quot;</B>
<DD>
 
</DL>
<P>

<LI>

<B>手册宏域</B>

<DL COMPACT>
<P>

<DT><B>&quot;地址&quot;</B>
<DD>
 
<DT><B>&quot;作者名字&quot;</B>
<DD>
 
<DT><B>&quot;参数&quot;</B>
<DD>
 
<DT><B>&quot;配置声明 (仅用于手册第四部分)&quot;</B>
<DD>
 
<DT><B>&quot;命令修饰&quot;</B>
<DD>
 
<DT><B>&quot;已定义的变量&quot;</B>
<DD>
 
<DT><B>&quot;Errno's (仅用于手册第二部分)&quot;</B>
<DD>
 
<DT><B>&quot;环境变量&quot;</B>
<DD>
 
<DT><B>&quot;函数参数&quot;</B>
<DD>
 
<DT><B>&quot;函数声明&quot;</B>
<DD>
 
<DT><B>&quot;标志 (Flags)&quot;</B>
<DD>
 
<DT><B>&quot;函数 (库例程)&quot;</B>
<DD>
 
<DT><B>&quot;函数类型&quot;</B>
<DD>
 

<DT><B>&quot;交互命令&quot;</B>
<DD>
 
<DT><B>&quot;名称&quot;</B>
<DD>
 
<DT><B>&quot;选项&quot;</B>
<DD>
 
<DT><B>&quot;路径&quot;</B>
<DD>
 
<DT><B>&quot;变量&quot;</B>
<DD>
 
<DT><B>&quot;参照&quot;</B>
<DD>
 
</DL>
<P>

<LI>

<B>基本正文宏域</B>

<DL COMPACT>
<P>

<DT><B>&quot;AT&amp;T 宏&quot;</B>
<DD>
 
<DT><B>&quot;BSD 宏&quot;</B>
<DD>
 
<DT><B>&quot;FreeBSD 宏&quot;</B>
<DD>
 
<DT><B>&quot;UNIX 宏&quot;</B>
<DD>
 
<DT><B>&quot;嵌入/引用宏 (Enclosure/Quoting)&quot;</B>
<DD>
<DL COMPACT>
<P>

<DT><B>&quot;尖括弧引用/嵌入&quot;</B>
<DD>
 
<DT><B>&quot;方括弧引用/嵌入&quot;</B>
<DD>
 
<DT><B>&quot;双引号引用/嵌入宏&quot;</B>
<DD>
 
<DT><B>&quot;圆括弧引用/嵌入&quot;</B>
<DD>
 
<DT><B>&quot;单引号引用/嵌入&quot;</B>
<DD>
 
<DT><B>&quot;前缀宏&quot;</B>
<DD>
 
</DL>
<P>

<DT><B>&quot;No-</B>[或正文宏]


<DD>
 
<DT><B>&quot;消除空白宏&quot;</B>
<DD>
 
<DT><B>&quot;手册节对照&quot;</B>
<DD>
 
<DT><B>&quot;参考和引用&quot;</B>
<DD>
 
<DT><B>&quot;返回值 (仅用于手册页第二和第三部分)&quot;</B>
<DD>
<DT><B>&quot;Trade Names (缩略和类型名称)&quot;</B>
<DD>
 
<DT><B>&quot;参数扩展&quot;</B>
<DD>
 
</DL>
<P>

<LI>

<B>页结构宏域</B>

<DL COMPACT>
<P>

<DT><B>&quot;小节首部&quot;</B>
<DD>
 
<DT><B>&quot;段落和空行&quot;</B>
<DD>
 
<DT><B>&quot;保持 (Keeps)&quot;</B>
<DD>
 
<DT><B>&quot;显示&quot;</B>
<DD>
 
<DT><B>&quot;字体模式 (加重, 原文和 Symbolic)&quot;</B>
<DD>
 
<DT><B>&quot;列表和栏&quot;</B>
<DD>
 
</DL>
<P>

<LI>

<B>预定义串</B>

<LI>

<B>诊断</B>

<LI>

<B>用 GROFF, TROFF 和 NROFF 格式化</B>

<LI>

<B>臭虫 BUGS</B>

</OL><P>



<H2>TROFF 特性</H2>

使用
<B>-mdoc</B>

宏包 的 目的 是 简化 写手册页 的 过程. 理论上讲, 要使用
<B>-mdoc</B>

不一定 要 学习
troff</A>(1)


的 腌脏细节; 然而, 有些 限制 无法回避, 最好 把它们 摆平.
而且 你 应该 知道, 这个 宏包 的 速度 比较
<I>慢.</I>


<H3>宏的用法 Macro Usage</H3>

在
troff</A>(1)


里, 宏调用的形式 是 在行首 以
`.'

(句点符) 起始, 紧随其后 是 作为 宏名 的 两个字符. 参数 跟在 宏名 之后,
用 空格符 隔开. 这个 位于行首的 句点符 使
troff</A>(1)


把 紧随其后 的 两个字符 视作 宏名. 在 某些情况下 要把
`.'

(句点符) 放在 行首, 但不希望 被理解成 宏请求, 方法是 在
`.'

(句点) 前 使用
`\&amp;'

转义序列.
`\&amp;'

被 解释成 一段 长度为零 的 空白, 所以 不会 在 输出端 显示 出来.
<P>

一般说来,
troff</A>(1)


宏 最多 接受 九个参数, 忽略掉 其余的. 大多数 在
<B>-mdoc</B>

里的 宏 支持 九个参数, 某些场合 可以 续加 参数, 或扩展到 下一行. (见
Sx 扩展 Extensions ) .

有些宏 能够 处理 引号 引起来的 参数 (见 下面的
Sx 在参数中传递空格符 ) .

<P>

大多数
<B>-mdoc</B>

的 基本正文宏域 和 手册宏域 的宏 拥有 一种特性, 表现在 把 参数列表 当成
可调用的宏 
<I>分析 (解释)</I>

 
这意味着 如果 参数列表里的参数 是 普通正文宏域 或 手册宏域
里的 宏, 并且 是 可调用宏, 那么 处理的时候 会 执行 或 调用.
这种情况下的 参数, 即 宏名, 不需要 用
`.'

(句点符) 引导.
这种风格 使 很多 宏 嵌套 在 一起; 例如 这个 选项宏
`.[,]

'

可能
<I>调用</I>

标志和参数宏,
`-

'

和
`<I>file ...</I>

'

 
用来 说明 一个 带参数的 选项:
<DL COMPACT>
<P>

<DT><B></B>[-<B>s </B><I>bytes</I>



]


<DD>
来自
<B>.</B>[-<B>s </B><I>bytes</I>



]



</DL>
<P>

<P>

为了 防止 把 两个字符的字符串 解释成 宏名, 在这个 字符串 前面 加上
`\&amp;'

<P>
转义序列:
<DL COMPACT>
<P>

<DT><B></B>[-<B>s </B><I>bytes</I>



]


<DD>
来自
<B>.</B>[\&amp;-<B>s \&amp;</B><I>bytes</I>



]



</DL>
<P>

<P>

这里的 字符串
`-

'

和
`<I>file ...</I>

'

没有
被解释成 宏.
在 这篇文档 和 相应的 快速参考手册
mdoc</A>(7)


中, 参数列表 按 可调用参数 分析 的 宏 称为 已分析, 可以 从 参数列表
调用 的 宏 称为 可调用.
这里 用的 术语 '分析' 可能是个 技术失误, 几乎 所有的
<B>-mdoc</B>

宏 都 被分析, 既 用它 指 可调用宏, 又 指 有 调用 其他宏的 能力, 显得 很笨拙.

<H3>在参数中传递空格符 Passing Space Characters in an Argument</H3>

某些时候 我们 希望 能够 把 含有 一个或多个 空格符 的 字符串 作为 单个参数
传递. 如果 要 突破 九个参数的限制, 或者 传递给 宏 的 参数 需要 一些 特定布置, 
这个 能力 是必须的. 例如, 函数宏
`.Fn 的

'

第一个参数 是 函数名称, 剩下的参数 作为 函数的参数.
<B>ANSI C</B>

规定 函数的参数 在 圆括弧内 声明, 每个 参数 至少 由 两个 标示符 组成.
例如,
Fa int foo .

<P>

有 两个方法 传递 嵌有空格符 的 参数.
<I>补充一点</I>

 
不幸的是, 在
<B>AT&amp;T</B>

troff


中, 那个 最容易的方法, 就是 作为 单个 参数 传递 两个引号之间的 
字符串和空格符, 非常 消耗 时间 和 内存空间.
虽然 它 对
groff


并不费事, 但是 为了 可移植性, 这种 做法 只限于 下列 有迫切需要 的 宏:
<P>

<DL COMPACT>
<P>

<DT><B>配置声明 (手册第四部分</B>




<DD>
Sx 概要 SYNOPSIS )

<DT><B><DL COMPACT>
<P>

</B>


<DD>
列表开始 (指定宽度的)
<DT><B></B><I>加重文字</I>




<DD>
<DT><B>Fn </B>函数 (手册第二, 四部分)




<DD>
<DT><B><DT>列表项</B>
<DD>



<DD>
<DT><B>原文</B>




<DD>
<DT><B>Symbolic text</B>




<DD>
<DT><B>%B</B>


<DD>
书题
<DT><B>%J</B>


<DD>
期刊名
<DT><B>%O</B>


<DD>
参考选注
<DT><B>%R</B>


<DD>
报告题目(在参考文件中)
<DT><B>%T</B>


<DD>
在书籍或期刊中的题目
</DL>
<P>

<P>

一种 传递 含空格符字符串 的 方法 是 用
`\<BR>&nbsp;'

硬编码 或 不可填充空格符, 也就是 在 空格符 前 加上 转义符
`\'

这个 方法 适用于 任何宏, 但 有个 副效应, 它 干扰了 对 长行 的 调整.
Troff


把 这种 硬编码的 空格符 看作 可显示字符, 因此 无法 在需要的时候 把 字符串
分段 或 换行. 这种 方法 适用于 字符串 不会 到达 行边界 时, 例如:
<DL COMPACT>
<P>

<DT><B>Fn </B>fetch char&nbsp;*str


<DD>
来自
`.Fn fetch

'

char\ *str
<DT><B>Fn </B>fetch char *str


<DD>
也可以来自
`.Fn fetch

'

\*qchar *str\*q
</DL>
<P>

<P>

如果 忽略
`\'

或 引号,
`.Fn 宏

'

会认为 有 三个参数, 结果 成为:
<P>


<BLOCKQUOTE><TT>Fn </TT>fetch char *str

</BLOCKQUOTE>
<P>

如果 想知道 参数列表 到达 行边界 时 出现什么, 参看
Sx BUGS

小节.
</DL>
</DL>

<H3>尾部的空白符 Trailing Blank Space Characters</H3>

Troff


可能 被 行尾的 空白符 搞乱, 它的防范规则 是 消除 所有 位于行末 的 空白符. 
如果 坚持 在 行末 加上 空白符, 可以 用 硬空格符 和
`\&amp;'

转义字符. 例如,
`string\\&amp; .'


<H3>转义特殊字符 Escaping Special Characters</H3>

特殊字符, 如 换行符
`\n'

,
是 通过 用
`\e'

替换
`\'

(e.g.例如
`\en'

)
保留住 反斜杠.

<H2>手册页结构分析 THE ANATOMY OF A MAN PAGE</H2>

手册页 可以 很容易的 通过 模板 构建, 模板 放在
/usr/share/misc/mdoc.template . 

另外 在
/usr/share/examples/mdoc

目录下 有一些 手册页 的 例子.
<P>


<H3>手册页的模板 A manual page template</H3>


<BLOCKQUOTE>
<PRE>
.\&quot; 所有的手册页都要求有下面的内容
.Dd 月 日, 年Month day, year
.Os 操作系统 [版本/发行号] 
.Dt 文档标题 [手册节号][卷] 
.Sh 名称 NAME
.Nm 名称 name
.Nd 对名称的简单描述 one line description of name
.Sh 总览 SYNOPSIS
.Sh 描述 DESCRIPTION
.\&quot; 后面的内容取消注释后可以用在你需要的任何地方.
.\&quot; 紧接着的这条命令用于手册第二和第三部分, 函数的返回值.
.\&quot; .Sh 返回值 RETURN VALUES
.\&quot; 下面的命令用于手册第1, 6, 7, 8部分.
.\&quot; .Sh 环境 ENVIRONMENT
.\&quot; .Sh 文件 FILES
.\&quot; .Sh 示例 EXAMPLES
.\&quot; 下面的命令用于手册第1, 6, 7, 8部分
.\&quot;     (在shell下的命令返回值和标准错误类型的诊断)
.\&quot; .Sh 诊断 DIAGNOSTICS
.\&quot; 下面的命令用于手册第二和第三部分中的错误和信号处理.
.\&quot; .Sh 错误 ERRORS
.\&quot; .Sh 另见 SEE ALSO
.\&quot; .Sh 遵循 CONFORMING TO
.\&quot; .Sh 历史 HISTORY
.\&quot; .Sh 作者 AUTHORS
.\&quot; .Sh BUGS
</PRE>
</BLOCKQUOTE>

<P>

模板中 的 第一个部分 是
(<B>., ., .




</B>

)

宏; 文档日期, 手册或其内容 针对的 操作系统, 手册页的标题
(<I>(大写)</I>

)

和 该手册页 所属的节 (部分号).
这些宏 确认和标识了 这个手册页. 在 后面的
Sx 标题宏 TITLE MACROS

将 继续 讨论.
<P>

这个 模板中 的 其余部分 是 小节首部 (section header)
(<B>.</B>
<H2>;</H2>



)

其中
Sx 名称 NAME ,

Sx 总览 SYNOPSIS

和
Sx 描述 DESCRIPTION

是 必不可少的.
这些 首部 在
Sx 页结构宏域

中 讨论 ( 介绍完
Sx 手册域

之后 ) .
有一些 内容宏 被用来 示范 页面布局宏; 建议 接触 页面布局宏 前 先看看 内容宏.

<H2>标题宏 TITLE MACROS</H2>

标题宏 是 页结构宏域 的 第一部分, 但 在 过去, 人们 如果 编写 手册页, 
它 是 手册的 第一部分, 也是 独立部分. 这里 设计了 三个宏 分别 描述
文档标题 或 手册标题, 操作系统, 和 制作日期. 它们 放在 文档的 最前面, 
一次 只 调用 一个, 用来 构建 文档的 页头 和 页脚.
<DL COMPACT>
<P>

<DT><B>.
</B>


<DD>
文档标题 是 手册页的 主题, 由于 troff 的 限制, 必须
<B>大写</B>

 
手册节号 (部分号) 介于 1,&nbsp;...,&nbsp;8, 如果 指明了 手册节号, 可以 忽略 卷标.
卷标 用 下列 标识的 一个 或 任意个:




<P>

<DL COMPACT>
<P>

<DT><B>AMD<TT>&nbsp;&nbsp;&nbsp;&nbsp;</TT>UNIX 历史遗留的手册文档 Ancestral Manual Documents</B>


<DD>
<DT><B>SMM<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>UNIX 系统管理员手册 System Manager's Manual</B>


<DD>
<DT><B>URMUNIX 参考手册 Reference Manual</B>


<DD>
<DT><B>PRMUNIX 程序员手册 Programmer's Manual</B>


<DD>
</DL>
<P>

<P>

缺省的卷标<BR>
<B>URM</B>

代表 手册区 1, 6, and 7;
<B>SMM</B>

代表 手册区 8;
<B>PRM</B>

代表 手册区 2, 3, 4, and 5.






<DT><B>.操作系统 发行号#

</B>


<DD>
操作系统 的 名字 可能 是 缩写, 像
<B>BSD</B>

或
<B>FreeBSD</B>

或
<B>ATT</B>

 
发行号 应该 是 系统 专用的 标准发行术语, 像 4.3, 4.3+Tahoe, V.3, V.4.
识别不出的 参数 就 照原样 显示在 页脚. 例如, 典型的页脚 可能是:
<P>


<BLOCKQUOTE><TT>.BSD 4.3

</TT></BLOCKQUOTE>
<P>

或

<BLOCKQUOTE><TT>.FreeBSD 2.2

</TT></BLOCKQUOTE>
<P>

或者 象 订制的产品
<P>


<BLOCKQUOTE><TT>.CS Department

</TT></BLOCKQUOTE>
<P>

作为 伯克利的缺省设置, 不带 参数 的
`.定义为

'

<B>BSD </B>

(指定在文件
/usr/share/tmac/mdoc/doc-common 

中). 你 应该 把缺省值 设成
<B>本机.</B>

注意, 如果 不设置
`.宏,

'

页面的左下角 会 很难看.
<DT><B>.月 日, 年 (month day, year)

</B>


<DD>
日期 应当 写的 正规点:
<P>



<BLOCKQUOTE><TT>January 25, 1989</TT></BLOCKQUOTE>
</DL>
<P>


<H2>手册宏域 和 基本正文宏域的介绍</H2>


<H3>名称背后 What's in a name...</H3>

手册宏域 的 宏名 来自 非正式的 日常用语, 用来 描述 命令, 子程序 及其 
相关文件. 在 写 手册页 时, 文字用语 有些 轻微的变化, 分别描述 三个 
不同 应用面. 首先是
<B>-mdoc</B>

宏请求 的 用法. 其次, 用
<B>-mdoc</B>

宏 描述
UNIX
命令. 最后, 对 用户 具体的描述 这条命令; 也就是 在 手册页 正文 里 
讨论这条命令.
<P>

第一种 情况 下,
troff</A>(1)


宏 本身 就是 一种 命令; troff 命令 的 基本语法 是:

<BLOCKQUOTE>

.Va argument1 argument2 ... argument9
</BLOCKQUOTE>

<P>

这里的
`.<I>是</I>

'

宏命令 或 宏请求, 紧随其后 的 是 待处理的参数.
第二种 情况 下, 使用 内容宏 描述 一条
UNIX
命令 要 复杂 些; 一个 典型的
Sx 总览 SYNOPSIS

命令行 显示 如下:

<BLOCKQUOTE>

<B>filter</B>

[-<B>flag</B>

]

<I>infile outfile</I>

</BLOCKQUOTE>

<P>

这里的
<B>filter</B>

是 命令名称, 方括弧内 的
-<B>flag</B>

是一个
<I>标志</I>

参数, 作为 可选参数 放在 代表 选项 的 方括弧内. 在
<B>-mdoc</B>

术语 中,
<I>infile</I>

和
<I>outfile</I>

称为
<I>参数</I>

 
产生 上述效果 的 宏 是 这样的:

<BLOCKQUOTE>
<PRE>
.Nm filter
.Op Fl flag
.Ar infile outfile
</PRE>
</BLOCKQUOTE>

<P>

第三种 情况 讨论 命令 及其语法, 包括 它们的例子, 可能 还有 更多细节.
上面的例子里, 可以把
<I>infile</I>

和
<I>outfile</I>

理解为
<I>操作参数 operands</I>

或
<I>文件参数 file arguments</I>

 
有些 命令行参数 罗列的 十分 长:
<DL COMPACT>
<P>

<DT><B>make</B>


<DD>
[-<B>eiknqrstv</B>

]

[-<B>D </B><I>variable</I>



]

[-<B>d </B><I>flags</I>



]

[-<B>f </B><I>makefile</I>



]

-words

[-<B>I </B><I>directory</I>



]

[-<B>j </B><I>max_jobs</I>



]



[<I>variable=value</I>

]

-words

[<I>target ...</I>

]

</DL>
<P>



<P>

这里 你 可能 讨论
<B>make</B>

命令 和 它的参数
<I>makefile</I>

 
作为 一个 标志的参数,
-<B>f</B>

 
或者 讨论 一个 可选的文件操作对象
<I>target</I>

 
在 具体的上下文 中, 这种细节 能够 防止 混淆. 然而
<B>-mdoc</B>

宏包中 没有为 标志的参数 准备 宏. 作为 替代 是
`<I>file ...</I>

'

参数宏,
用于 描述 操作对象 或 文件参数 如
<I>target</I>

以及 标志的参数 如
<I>variable</I>

 
上面的 make 命令行 是 这样 产生的:

<BLOCKQUOTE>
<PRE>
.Nm make
.Op Fl eiknqrstv
.Op Fl D Ar variable
.Op Fl d Ar flags
.Op Fl f Ar makefile
.Op Fl I Ar directory
.Op Fl j Ar max_jobs
.Op Ar variable=value
.Bk -words
.Op Ar target ...
.Ek
</PRE>
</BLOCKQUOTE>

<P>

在 
Sx Keeps 

小节中 将会 解释
`.和

'

`.宏.

'


<H3>基本语法 General Syntax</H3>

手册宏域 和 基本正文宏域 的 宏 有着 相似的语法, 仅有 微小差别:
`.<I>file ...</I>

'

 
`.-

'

 
`.<B>man mdoc.samples</B>

'

 
和
`.仅当

'

无参数调用时 才有 区别;
`.Fn 和

'

`.的

'

参数列表 要求 一定的 顺序;
`.[和]

'

`.Fn 宏有嵌套限制.

'

所有的 内容宏 能够 识别和正确处理 标点符号, 每个 标点符号 
要在 前面 用 空格 隔开. 如果 给出 这样的 宏请求:
<P>


<BLOCKQUOTE><TT>.</TT><B>sptr, ptr),</B>

</BLOCKQUOTE>
<P>

结果是:
<P>


<BLOCKQUOTE><TT></TT><B>sptr, ptr),</B>

</BLOCKQUOTE>
<P>

标点符号 没有 被识别 出来, 全都按 原文字体 输出. 如果 标点符号 前面用
空格符 隔开:
<P>


<BLOCKQUOTE><TT>.</TT><B>sptr , ptr ) ,</B>

</BLOCKQUOTE>
<P>

结果是:
<P>


<BLOCKQUOTE><TT></TT><B>sptr , ptr</B>

 </BLOCKQUOTE>
 
<P>

标点符号 被 识别出来 了, 缺省的字体 也 有别于 原文文字的字体.
<P>

用
`\&amp;'

转义符 可以 去掉 标点字符 的 特殊意义.
Troff


作为 宏语言 有一定 的 限制, 当 表达的字串 中 含有
数学, 逻辑 或 引用 符号时 将 难于 处理:

<BLOCKQUOTE>
<PRE>
{+,-,/,*,%,&lt;,&gt;,&lt;=,&gt;=,=,==,&amp;,`,',&quot;}
</PRE>
</BLOCKQUOTE>

<P>

问题是
troff


会 认为 它 应该 执行或运算 这些 符号 代表的操作.
要 防止 这一点 可以 用
`\&amp;'

转义 这些 字符. 典型语法 在 下面 显示的 第一个 内容宏 中 可以见到,
`.<I></I>

'


<H2>手册域 MANUAL DOMAIN</H2>


<H3>地址宏 Address Macro</H3>

地址宏 用 这种 格式 标明地址: addr1[,addr2[,addr3]].
<P>


<BLOCKQUOTE><TT>Usage: .</TT><I>address ... </I>

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.</B><I>addr1</I>




<DD>
<I>addr1</I>

<DT><B>.</B><I>addr1</I>




<DD>
<I>addr1</I>

 
<DT><B>.</B><I>addr1&nbsp;, file2</I>




<DD>
<I>addr1 , file2</I>

<DT><B>.</B><I>f1&nbsp;, f2&nbsp;, f3:</I>




<DD>
<I>f1 , f2 , f3</I>

 
<DT><B>.</B><I>addr&nbsp;)&nbsp;),</I>




<DD>
<I>addr ) )</I>

 
</DL>
<P>

<P>

不带参数 调用
`.<I>是个</I>

'

错误.
`.<I>可以被</I>

'

(其他宏) 调用和分析.

<H3>作者名称 Author Name</H3>

The
`.An 宏用以

'

说明 这个文档的 描述对象的 作者, 或者 这篇手册页的 作者.
名字 信息 后面的 其他参数 被认为是 标点符号.
<P>


<BLOCKQUOTE><TT>Usage: .An </TT>author_name 

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.An </B>Joe&nbsp;Author




<DD>
An Joe Author

<DT><B>.An </B>Joe&nbsp;Author,




<DD>
An Joe&nbsp;Author ,

<DT><B>.An </B>Joe&nbsp;Author&nbsp;Aq&nbsp;nobody@FreeBSD.ORG</A>




<DD>
An Joe Author Aq nobody@FreeBSD.ORG</A>

<DT><B>.An </B>Joe&nbsp;Author&nbsp;)&nbsp;),




<DD>
An Joe Author ) ) ,

</DL>
<P>

<P>

`.An 宏可以被

'

(其他宏) 分析和调用, 
不带参数调用
`.An 是个错误.

'


<H3>参数宏 Argument Macro</H3>

当 引用 命令行参数时 可以使用
`.<I>file ...</I>

'

参数宏.
<P>


<BLOCKQUOTE><TT>Usage: .</TT><I>argument ... </I>

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.</B><I>file ...</I>




<DD>
<I>file ...</I>


<DT><B>.</B><I>file1</I>




<DD>
<I>file1</I>

<DT><B>.</B><I>file1</I>




<DD>
<I>file1</I>

 
<DT><B>.</B><I>file1 file2</I>




<DD>
<I>file1 file2</I>

<DT><B>.</B><I>f1 f2 f3:</I>




<DD>
<I>f1 f2 f3</I>

 
<DT><B>.</B><I>file&nbsp;)&nbsp;),</I>




<DD>
<I>file ) )</I>

 
</DL>
<P>

<P>

如果不带参数调用
`.<I>file ...</I>

'

宏,
缺省为
`<I>file ...</I>

'

 
`.<I>file ...</I>

'

宏可以被
(其他宏) 分析和调用.

<H3>配置定义 (手册第四部分) Configuration Declaration</H3>

`.<B>宏用于描述</B>

'

config</A>(8)


对 设备接口的定义 (手册第四部分).
这个宏 接受 引号内的参数 (只能是双引号).
<P>

<DL COMPACT>
<P>

<DT><B>device le0 at scode?</B>


<DD>
来自:
`.<B>device</B>

'

le0 at scode? .
</DL>
<P>


<H3>命令修饰 Command Modifier</H3>

命令修饰宏和
`.-

'

(标志)
命令相似, 除了
`.<B>宏</B>

'

不在 任何参数 前 加 短横线 (dash).
传统的标志 以 短横线 开头, 但 一些 命令 或 命令的子集 不用这个.
命令修饰宏 也可以 和 交互命令 结合 使用, 如 编辑命令. 另见
Sx Flags .


<H3>已定义的变量 Defined Variables</H3>

在 头文件 中 已经 定义了的变量 用
`.<B>宏说明.</B>

'

<P>


<BLOCKQUOTE><TT>Usage: .</TT><B>defined_variable ... </B>

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.MAXHOSTNAMELEN</B>




<DD>
<B>MAXHOSTNAMELEN</B>

<DT><B>.TIOCGPGRP )</B>




<DD>
<B>TIOCGPGRP</B>

 
</DL>
<P>

<P>

不带参数调用
`.<B>是个错误.</B>

'

`.<B>宏可以被</B>

'

(其他宏) 分析和调用.

<H3>Errno's (仅供手册第二部分)</H3>

这个
`.Er errno

'

宏 指明 手册 第二部分, 库函数 的 错误返回值.(译注: 应该是系统调用)
下面的 第二个 例子 显示了
`.Er 配合

'

`.Bq 基本正文宏

'

的 使用, 就象 用在 手册 第二部分 一样.
<P>


<BLOCKQUOTE><TT>Usage: .Er </TT>ERRNOTYPE ... 

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.Er </B>ENOENT




<DD>
Er ENOENT

<DT><B>.Er </B>ENOENT&nbsp;);




<DD>
Er ENOENT ) ;

<DT><B>.Bq </B>Er ENOTDIR






<DD>
Bq Er ENOTDIR

</DL>
<P>

<P>

不带参数调用
`.Er 宏是个错误.

'

`.Er 宏可以被

'

(其他宏) 分析和调用.

<H3>环境变量 Environment Variables</H3>

`.<B>宏说明一个环境变量.</B>

'

<P>


<BLOCKQUOTE><TT>Usage: .</TT><B>argument ... </B>

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.DISPLAY</B>




<DD>
<B>DISPLAY</B>

<DT><B>.PATH</B>




<DD>
<B>PATH</B>

 
<DT><B>.PRINTER&nbsp;)&nbsp;),</B>




<DD>
<B>PRINTER ) )</B>

 
</DL>
<P>

<P>

不带参数调用
`.<B>宏是个错误.</B>

'

`.<B>宏可以被</B>

'

(其他宏) 分析和调用.

<H3>函数参数 Function Argument</H3>

`.Fa 宏

'

用来 说明 在手册的
Sx 总览 SYNOPSIS

小节 之外的 函数参数, 或者在
Sx 总览 SYNOPSIS

小节内, 其 参数列表对
`.Fn 宏

'

而言 过长, 并且 必须 使用
`.Fo 和

'

`.Fc 宏时.

'

`.Fa 也

'

有可能 用来 说明 结构成员.
<P>


<BLOCKQUOTE><TT>Usage: .Fa </TT>function_argument ... 

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.Fa </B>d_namlen&nbsp;)&nbsp;),




<DD>
Fa d_namlen ) ) ,

<DT><B>.Fa </B>iov_len




<DD>
Fa iov_len

</DL>
<P>

<P>

不带参数调用
`.Fa 宏是个错误.

'

`.Fa 宏可以被

'

(其他) 宏分析和调用.

<H3>函数声明 Function Declaration</H3>

`.Fd 宏

'

用于 第二或 第三部分 手册页 的
Sx 总览 SYNOPSIS

小节.
`.Fd 宏

'

既 不调用 其他宏, 也 不能 被 其他宏调用.
<P>


<BLOCKQUOTE><TT>Usage: .Fd </TT>include_file (or defined variable)

</BLOCKQUOTE>
<P>

在
Sx 总览 SYNOPSIS

小节, 如果 已经 说明了 某个 函数, 并且 没有 出现 省略号, 则
`.Fd 宏请求

'

能够 产生 一个 断行.
在 函数 和 函数声明 之间, 垂直方向上 产生 一定的 空白.

<H3>标志 Flags</H3>

`.-

'

宏
处理 命令行标志. 它 在 标志前 加一个 短横线
`-'

,
对于 交互命令 标志, 它 不需要 短横线, 可以用
`.<B>(命令修饰</B>

'

command modifier)
宏替换, 它 没有 短横线.
<P>


<BLOCKQUOTE><TT>Usage: .-</TT><B>argument ... </B>

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.-

</B>


<DD>
-


<DT><B>.-cfv</B>




<DD>
-<B>cfv</B>

<DT><B>.-cfv</B>




<DD>
-<B>cfv</B>

 
<DT><B>.-s v t</B>




<DD>
-<B>s v t</B>

<DT><B>.--,</B>




<DD>
-<B>-</B>

 
<DT><B>.-xyz&nbsp;),</B>




<DD>
-<B>xyz )</B>

 
</DL>
<P>

<P>

如果
`.-

'

宏
不带 任何 参数, 将 只产生 一个 短横线, 代表 stdin/stdout.
注意 如果 把 一个 短横线 做为
`.-

'

的参数,
结果 会 得到 两个短横线.
`.-

'

宏可以被
(其他宏) 分析和调用.

<H3>函数(库函数) Functions (library routines)</H3>

宏 .Fn 是 ANSI C 函数风格 的 模型.

<PRE>
Usage: .Fn [type] function [[type] parameters ... ]
</PRE>

<DL COMPACT>
<P>

<DT><B>.Fn </B>getchar




<DD>
Fn getchar

<DT><B>.Fn </B>strlen ) ,




<DD>
Fn strlen ) ,

<DT><B>.Fn </B>\*qint align\*q \*qconst * char *sptrs\*q




<DD>
 
Fn int align const * char *sptrs ,

</DL>
<P>

<P>

不带参数调用
`.Fn 是一个错误.

'

`.Fn 宏可以被

'

(其他宏) 分析和调用,
注意 任何 对 其他宏 的 调用 应该在
`.Fn 宏调用

'

的 结尾处 给出 标记 (反括弧).
<P>

对于 八个 参数 以上的 函数 (尽管少见), 可以 用 宏
`.Fo (function

'

open) 和
`.Fc (function

'

close) 配合
`.Fa (function

'

argument) 宏 的 使用, 突破 参数 过多 的 限制, 例如:

<BLOCKQUOTE>
<PRE>
.Fo &quot;int res_mkquery&quot;
.Fa &quot;int op&quot;
.Fa &quot;char *dname&quot;
.Fa &quot;int class&quot;
.Fa &quot;int type&quot;
.Fa &quot;char *data&quot;
.Fa &quot;int datalen&quot;
.Fa &quot;struct rrec *newrr&quot;
.Fa &quot;char *buf&quot;
.Fa &quot;int buflen&quot;
.Fc
</PRE>
</BLOCKQUOTE>

<P>

产生:

<BLOCKQUOTE>

Fo int res_mkquery

Fa int op

Fa char *dname

Fa int class

Fa int type

Fa char *data

Fa int datalen

Fa struct rrec *newrr

Fa char *buf

Fa int buflen

Fc </BLOCKQUOTE>



<P>

宏
`.Fo 和

'

`.Fc 可以被

'

(其他宏) 分析和调用. 在
Sx 总览 SYNOPSIS

小节, 函数 总是 位于 行的开始 处.
如果 在
Sx 总览 SYNOPSIS

小节 有 一个以上的 函数声明, 而且 函数类型 没有 说明, 则 会产生 一个 断行.
在 函数 和 函数 的 垂直方向 上 产生 一定的 空白. 此时
`.Fn 宏

'

不按 troff 的 行长 检查 单词 边界, 有可能 难看的 从 单词中间 断开.
以后 会 解决 这个 问题.

<H3>函数类型 Function Type</H3>

这个宏 设计 用在
Sx 总览 SYNOPSIS

小节. 它 可以 毫无困难的 用在 手册页的 其他 地方, 但 它的 主要 目的
是 为 第二 和 第三部分 手册页的
Sx 总览 SYNOPSIS

小节, 以 核心标准形式 (kernel normal form) 描述 函数类型
(它 导致 断行, 在 下一行 显示 函数 名称).
<P>


<BLOCKQUOTE><TT>Usage: .Ft </TT>type ... 

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.Ft </B>struct stat




<DD>
Ft struct stat

</DL>
<P>

<P>

`.Ft 宏不能被其他宏调用.

'


<H3>交互命令 Interactive Commands</H3>

宏
`.<B>用于</B>

'

说明 交互 或 内部命令.
<P>


<BLOCKQUOTE><TT>Usage: .</TT><B>argument ... </B>

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.:wq</B>




<DD>
<B>:wq</B>

<DT><B>.do while {...}</B>




<DD>
<B>do while {...}</B>

<DT><B>.setenv&nbsp;, unsetenv</B>




<DD>
<B>setenv , unsetenv</B>

</DL>
<P>

<P>

不带参数调用
`.<B>是个错误.</B>

'

`.<B>宏可以被</B>

'

(其他宏) 分析和调用.

<H3>名称宏 Name Macro</H3>

`.<B>man mdoc.samples</B>

'

宏
用于 说明 文档题目 或 主题. 它的特点 是 能够 记住 调用时 带的 第一个 
参数, 这个 参数 就是 该页的 主题. 当 不带 参数 调用它 时,
`.<B>man mdoc.samples</B>

'

宏
把 以前 记住的 参数 显示 出来, 可以 为作者 省点劲.
注意: 手册第二部分或第三部分的函数名称, 在
Sx 名称 NAME

小节 用
`.<B>man mdoc.samples</B>

'

说明,
在
Sx 总览 SYNOPSIS

和 其余 小节 用
`.Fn 说明.

'

对于 交互命令, 例如 在
csh</A>(1)


中的
`while'

命令, 应该 使用
`.<B>宏.</B>

'

`.<B>宏和</B>

'

`.<B>man mdoc.samples</B>

'

 
宏 非常接近, 只是 它 不能够 记忆 调用时的 参数.
<P>


<BLOCKQUOTE><TT>Usage: .</TT><B>argument ... </B>

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.mdoc.sample</B>




<DD>
<B>mdoc.sample</B>

<DT><B>.\-mdoc</B>




<DD>
<B>-mdoc</B>

 
<DT><B>.foo&nbsp;)&nbsp;),</B>




<DD>
<B>foo ) )</B>

 
<DT><B>.man mdoc.samples</B>




<DD>
<B>man mdoc.samples</B>


</DL>
<P>

<P>

`.<B>man mdoc.samples</B>

'

宏可以被
(其他宏) 分析和调用.

<H3>选项 Options</H3>

`.[宏]

'

把 命令行上 剩余的 所有 参数 用 方括弧 括在一起, 把 最后的 标点符号
放到 方括弧 外面. 宏
`.]
'

和
`.[用于
'

处理 跨行.
<P>


<BLOCKQUOTE><TT>Usage: .</TT>[options ... ]

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.</B>[[<DT><B>.</B>[-<B>k</B>

]




<DD>
]

]




<DD>
[-<B>k</B>

]

<DT><B>.</B>[-<B>k ) .</B>

]




<DD>
[-<B>k</B>

 ]

 
<DT><B>.</B>[-<B>k </B><I>kookfile</I>



]




<DD>
[-<B>k </B><I>kookfile</I>



]

<DT><B>.</B>[-<B>k </B><I>kookfile ,</I>



]




<DD>
[-<B>k </B><I>kookfile</I>



]

 
<DT><B>.</B>[<I>objfil </I>[<I>corfil</I>

]



]




<DD>
[<I>objfil </I>[<I>corfil</I>

]



]

<DT><B>.</B>[-<B>c </B><I>objfil </I>[<I>corfil ,</I>

]





]




<DD>
[-<B>c </B><I>objfil </I>[<I>corfil</I>

]





]

 
<DT><B>.</B>[word1 word2]




<DD>
[word1 word2]

</DL>
<P>

<P>

应用
`.]
'

和
`.[宏:
'


<BLOCKQUOTE>
<PRE>
.Oo
.Op Fl k Ar kilobytes
.Op Fl i Ar interval
.Op Fl c Ar count
.Oc
</PRE>
</BLOCKQUOTE>

<P>

产生:
[[-<B>k </B><I>kilobytes</I>



]


[-<B>i </B><I>interval</I>



]

[-<B>c </B><I>count</I>



]

]
<P>

宏
`.[,]

'

`.]
'

和
`.[可以被
'

(其他宏) 分析和调用.

<H3>路径名 Pathnames</H3>

`.宏

'

用于 格式化 路径 或 文件名.
<P>


<BLOCKQUOTE><TT>Usage: .pathname 

</TT></BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>./usr/share

</B>


<DD>
/usr/share

<DT><B>./tmp/fooXXXXX&nbsp;)

</B>


<DD>
/tmp/fooXXXXX )

 
</DL>
<P>

<P>

`.宏可以被

'

(其他宏) 分析和调用.

<H3>变量 Variables</H3>

基本的 变量 参考:
<P>


<BLOCKQUOTE><TT>Usage: .</TT><I>variable ... </I>

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.</B><I>count</I>




<DD>
<I>count</I>

<DT><B>.</B><I>settimer</I>




<DD>
 
<I>settimer</I>

 
<DT><B>.</B><I>int&nbsp;*prt&nbsp;):</I>




<DD>
<I>int&nbsp;*prt )</I>

 
<DT><B>.</B><I>char&nbsp;s&nbsp;]&nbsp;)&nbsp;),</I>




<DD>
<I>char&nbsp;s ] ) )</I>

 
</DL>
<P>

<P>

不带参数调用
`.<I>宏是个错误.</I>

'

`.<I>宏可以被</I>

'

(其他宏) 分析和调用.

<H3>手册页参照 Manual Page Cross References</H3>

`.宏

'

把 第一个参数 当做 手册页 名称, 第二个参数, 如果 存在,
当做 标点符号 或 手册页 的 部分号 (节号). 剩下 所有的参数
视做 标点符号.
<P>


<BLOCKQUOTE><TT>Usage: .man_page[1,...,8]

</TT></BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.mdoc

</B>


<DD>
mdoc


<DT><B>.mdoc

</B>


<DD>
 
mdoc,


<DT><B>.mdoc</A>(7)

</B>


<DD>
mdoc</A>(7)


<DT><B>.mdoc</A>(7)))

</B>


<DD>
 
mdoc</A>(7))),


</DL>
<P>

<P>

`.宏可以被

'

(其他宏) 分析和调用.
不带参数调用
`.宏是个错误.

'


<H2>基本正文宏域 GENERAL TEXT DOMAIN</H2>


<H3>AT&amp;T 宏</H3>


<BLOCKQUOTE>
<PRE>
Usage: .At [v6 | v7 | 32v | V.1 | V.4] ... 
</PRE>
</BLOCKQUOTE>

<DL COMPACT>
<P>

<DT><B>.At</B>


<DD>
AT&amp;T System

<DT><B>.AT&amp;T System
v6 .</B>


<DD>
AT&amp;T System
v6 .
</DL>
<P>

<P>

`.AT&amp;T System
'

宏
<I>不能</I>

被 (其他宏) 分析, 也
<I>不能</I>

被 (其他宏) 调用. 该宏 最多 接受 两个 参数.

<H3>BSD 宏</H3>


<BLOCKQUOTE><TT>Usage: .BSD [Version/release] ... 
</TT></BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.Bx</B>


<DD>
BSD <DT><B>.BSD 4.3 .
</B>


<DD>

BSD 4.3
 
</DL>
<P>

<P>

`.BSD 宏可以被
'

(其他宏) 分析和调用.

<H3>FreeBSD 宏</H3>


<BLOCKQUOTE>
<PRE>
Usage: .Fx Version.release ... 
</PRE>
</BLOCKQUOTE>

<DL COMPACT>
<P>

<DT><B>.Fx </B>2.2 .




<DD>
Fx 2.2 .

</DL>
<P>

<P>

`.Fx 宏

'

<I>不能</I>

被 (其他宏) 分析, 也
<I>不能</I>

被 (其他宏) 调用. 该宏 最多 接受 两个 参数.

<H3>UNIX 宏</H3>


<BLOCKQUOTE><TT>Usage: .UNIX
</TT></BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.Ux</B>


<DD>
UNIX
</DL>
<P>

<P>

`.UNIX
'

宏可以被
(其他宏) 分析和调用.

<H3>嵌入和引用宏 Enclosure and Quoting Macros</H3>

嵌入 的 概念 和 引用 类似. 把 一句 或 多句 引用对象 嵌到 一对 字符 中, 
象 引号 或 括弧. 本篇 文档中 将 混用 术语
`嵌入'

和
`引用.'

大多数 单行的 引用宏名 用 一个 小写字母
`q'

结尾, 表明 这是 一个 引用(quoting), 但 也有 不规则变化.
每个 引用宏 都有 一对 开始(open) 和 结束(close) 宏, 各自 以
`o'

和
`c'

结尾. 在 某些限制时 这些宏 可以 跨行 使用, 单行的引用宏 可以 嵌套在里面.
<P>



<BLOCKQUOTE>

<DL COMPACT>
<P>

<I> Quote<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT> Close<TT>&nbsp;&nbsp;</TT> Open<TT>&nbsp;&nbsp;&nbsp;</TT>Function<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>Result</I>

.Aq<TT>&nbsp;&nbsp;&nbsp;&nbsp;</TT>.Ac<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>.Ao<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>Angle Bracket Enclosure&lt;string&gt;<BR>
.Bq<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>.Bc<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>.Bo<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>Bracket Enclosure<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>[string]<BR>
.Dq<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>.Dc<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>.Do<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>Double Quote<TT>&nbsp;&nbsp;&nbsp;&nbsp;</TT>``string''<BR>
<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>.Ec<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>.Eo<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>Enclose String (in XX)<TT>&nbsp;&nbsp;</TT>XXstringXX<BR>
.Pq<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>.Pc<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>.Po<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>Parenthesis Enclosure<TT>&nbsp;&nbsp;&nbsp;</TT>(string)<BR>
.Ql<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT><TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>Quoted Literal<TT>&nbsp;&nbsp;</TT>`st' or string<BR>
.Qq<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>.Qc<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>.Qo<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>Straight Double Quote<TT>&nbsp;&nbsp;&nbsp;</TT>&quot;string&quot;<BR>
.Sq<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>.Sc<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>.So<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>Single Quote<TT>&nbsp;&nbsp;&nbsp;&nbsp;</TT>`string'<BR>
</DL>
<P>

</BLOCKQUOTE>

<P>

除了 下面的 不规则宏, 所有的 引用宏 可以被 (其他宏) 分析和调用. 所有的 
引用宏 能够 正确 处理 标点符号, 只要 一次 一个字符, 中间 用 空格 隔开.
引用宏 检查 开始和结束 符号, 以决定 把 它 放在 引用串的 前面还是后面.
这样 就 有了 一定的 嵌套能力.
<DL COMPACT>
<P>

<DT><B>.Ec </B>, .Eo 这些宏 的 第一个参数 是 各自的 开始和结束串.






<DD>
<DT><B>.`原文引用宏'

</B>


<DD>
的 表现在
troff


中和
nroff


不一样. 如果用
nroff


格式化, 引用的原文 始终 被引用. 如果用 troff 格式化,
只有 宽度 小于 三个定宽字符 的 项 才被 引用.
This is to make short strings more visible where the font change
to literal (constant width) is less noticeable.
当 字体 变成 原文(定宽) 时, 短串显得更容易被看到.
<DT><B>.前缀宏不能被 (其他宏) 调用, 但是可以被分析.

</B>


<DD>
<DL COMPACT>
<P>

<DT><B>.( Fa </B>name2






<DD>
变成
( Fa name2



 
</DL>
<P>

<P>

这个
`.<B>(无空格)</B>

'

宏 执行 类似的 后缀 功能.
</DL>
<P>

<P>


引用举例:
<DL COMPACT>
<P>

<DT><B>.Aq </B>Aq <DT><B>.Aq </B><I>ctype.h&nbsp;),</I>






<DD>







<DD>
Aq Ar ctype.h ) ,

<DT><B>.Bq </B>Bq <DT><B>.Bq </B><I>Greek , French .</I>






<DD>







<DD>
Bq Em Greek , French .

<DT><B>.````<DT>.``string abc .''

</B>


<DD>
''

''




<DD>
``string abc''

 
<DT><B>.``'^[A-Z]'''

</B>


<DD>
``'^[A-Z]'''

<DT><B>.`man'

</B>


<DD>
mdoc
`man'

mdoc
<DT><B>.Qq </B>Qq <DT><B>.Qq </B>string ) ,




<DD>







<DD>
Qq string ) ,

<DT><B>.Qq </B>string <B>),</B>






<DD>
Qq string Ns ),

<DT><B>.``<DT>.`string'

</B>


<DD>
'

'




<DD>
`string'

</DL>
<P>

<P>

作为 嵌套引用宏的 典型范例, 参见
`.[选项宏.]

'

它们 都 来自 上面 列出的 基本 引用宏.
`.
'

和
`.
'

扩展的
参数列表宏 同样 来自 相同的 基本例程, 并且, 在 最坏的情况 下, 是
<B>-mdoc</B>

宏 用法的 很好范例.

<H3>No-[或正文宏 or Normal Text Macro]

</H3>

宏
`.<B>用在</B>

'

某个 宏命令行 上, 意如其名, 将
<I>不</I>

被格式化, 语法 遵循 一般的 内容宏.

<H3>无空格宏 <B>Space Macro</B>

</H3>

`.<B>在</B>

'

宏请求 之间 消除 不需要的 空格.
它 用在 旧式风格的 参数列表 中, 标志和参数 间 没有 空格:
<DL COMPACT>
<P>

<DT><B>.</B>[-<B>I </B><I>directory</I>





]




<DD>
产生
[-<B>I </B><I>directory</I>





]

</DL>
<P>

<P>

注意:
`.<B>宏</B>

'

在 消除空格后 总会 调用
`.<B>宏,</B>

'

除非 还有 其他 宏名 跟在 后面.
`.<B>宏可以被</B>

'

(其他宏) 分析和调用.

<H3>手册页对照参考 Section Cross References</H3>

`.Sx 宏

'

指定了 到 同一个文档内的 小节首部 的 对照参考.
该宏可以被 (其他宏) 分析和调用.
<P>

<DL COMPACT>
<P>

<DT><B>.Sx </B>FILES




<DD>
Sx FILES

</DL>
<P>


<H3>参考和引言 References and Citations</H3>

The following macros make a modest attempt to handle references.
At best, the macros make it convenient to manually drop in a subset of
refer style references.
下面的宏 试图 适度的 处理 参考资料. 最好情况时, 这些宏 便于 手工
插入 一段 相关风格的 参考资料.
<P>

<DL COMPACT>
<P>

<DT><B>.Rs</B>


<DD>
参考开始. 它 导致 一次 断行, 并且 开始 收集 参考资料, 直到 遇到 参考结束宏.
<DT><B>.Re</B>


<DD>
参考结束. 则 打印出 参考信息.
<DT><B>.%A</B>


<DD>
参考资料 的 作者名字, 一次一个.
<DT><B>.%B</B>


<DD>
书名.
<DT><B>.%C</B>


<DD>
城市/地点.
<DT><B>.%D</B>


<DD>
日期.
<DT><B>.%J</B>


<DD>
期刊名.
<DT><B>.%N</B>


<DD>
发行号.
<DT><B>.%O</B>


<DD>
可选信息.
<DT><B>.%P</B>


<DD>
页码.
<DT><B>.%R</B>


<DD>
报告名.
<DT><B>.%T</B>


<DD>
文章题目.
<DT><B>.%V</B>


<DD>
卷.
</DL>
<P>

<P>

用
`%'

符号 开始的 宏 不能被 (其他宏) 调用, 只能 被 trade name macro 分析,
结果 返回给 调用者 (此时 结果 不太好 预测). 其目的 是 允许 trade name 
能够 很好的 打印在
troffNs/NsXrditroff


的 输出端.

<H3>返回值 Return Values</H3>

`.Rv 宏

'

产生 一些 用在
Sx 返回值 RETURN VALUES

小节的 文字.
<P>


<BLOCKQUOTE><TT>Usage: .Rv </TT>[-std function]

</BLOCKQUOTE>
<P>

`.Rv -std

'

atexit
将输出 下列文字:
<P>

Rv -std atexit

<P>

这个
-<B>std</B>

选项 仅用于 手册页的 第二和第三部分.

<H3>Trade Names (或缩略和类型名)</H3>

trade name 宏 一般说来 是 一个 很小的 大写字母宏, 用于 所有 大于
两个字符的 大写单词.
<P>


<BLOCKQUOTE><TT>Usage: .</TT><B>symbol ... </B>

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.DEC</B>




<DD>
<B>DEC</B>

<DT><B>.ASCII</B>




<DD>
<B>ASCII</B>

</DL>
<P>

<P>

`.<B>宏可以被</B>

'

(其他宏) 分析和调用.

<H3>扩展参数 Extended  Arguments</H3>

`.
'

和
`.
'

宏
可以 在 宏的边界 扩展 参数列表. 如果 某个宏 要求 所有的参数 在 一行上 
出现, 则 参数列表 不能 在 这儿 被 扩展. 例如
`.[]

'

<P>

这里有
`.
'

宏的一个示例,
用 空格模式宏 把 空格 去掉:

<BLOCKQUOTE>
<PRE>
.Sm off
.It Xo Sy I Ar operation
.No \en Ar count No \en
.Xc
.Sm on
</PRE>
</BLOCKQUOTE>

<P>

产生

<BLOCKQUOTE>

<DL COMPACT>
<P>


<DT><B>
I </B><I>operation</I>





<B>\n </B><I>count </I><B>\n</B>





<DD>


</DL>
<P>

</BLOCKQUOTE>

<P>

还有一个:

<BLOCKQUOTE>
<PRE>
.Sm off
.It Cm S No / Ar old_pattern Xo
.No / Ar new_pattern
.No / Op Cm g
.Xc
.Sm on
</PRE>
</BLOCKQUOTE>

<P>

产生

<BLOCKQUOTE>

<DL COMPACT>
<P>


<DT><B>S / </B><I>old_pattern 
</I>







<B>/ </B><I>new_pattern</I>



<B>/ </B>[<B>g</B>

]



<DD>


</DL>
<P>

</BLOCKQUOTE>

<P>

另一个示例用
`.
'

和
引用宏:
测试一个变量的值.

<BLOCKQUOTE>
<PRE>
.It Xo
.Ic .ifndef
.Oo \&amp;! Oc Ns Ar variable
.Op Ar operator variable ...
.Xc
</PRE>
</BLOCKQUOTE>

<P>

产生

<BLOCKQUOTE>

<DL COMPACT>
<P>

<DT><B>
</B>

<B>.ifndef</B>

[! <B></B><I>variable</I>



]

[<I>operator variable ...</I>

]

<DD>

</DL>
<P>

</BLOCKQUOTE>

<P>

上面 所有的例子 都在
`.
'

(list-item)
宏 的 参数列表 中 使用了
`.
'

宏.
扩展宏 不经常 使用, 一般用来 扩展 list-item 宏 的 参数列表.
这也 不幸的 是 扩展宏 最苛刻的 地方. 前两个例子里 空格 被去掉; 第三个 例子中, 
希望 能 输出 部分 空格, 而不是 全部. 在 这种情况下 用 这些宏, 要 确保
`.
'

和
`.<DD>
'

宏
摆放到 第三个例子 中 示范的位置. 如果
`.
'

宏
没有 单独 出现在
`.
'

的
参数表 中, 则 无法预测 空格 情况. 这种情况下,
`.<B>(no</B>

'

<DD>space macro) 一定 不能 作为 一行的 第一个宏 或 最后一个宏. 当前
BSD 发布的 超过 900个 手册页 (事实上大约1500个) 中,
只有 十五个 用到了
`.
'

宏.

<H2>页结构宏宏域 PAGE STRUCTURE DOMAIN</H2>


<H3>小节首部 Section Headers</H3>

每个 手册页 里 都用到了 下面 列出的 三个
`.
<H2>小节首部宏.</H2>

'

作者 写 手册页 时 可以 酌情考虑 其他 建议使用的 小节首部.
`.
<H2>宏</H2>

'

最多 带 九个 参数. 它 可以 被 (其他宏) 分析, 但不能 被调用.
<DL COMPACT>
<P>

<DT><B>.</DL>
</DL>
</B>
<H2>名称 NAME</H2>



`.
<H2>名称</H2>

'

<DD>NAME
宏是 必不可少的. 否则 无法设置 页头, 页脚 和 缺省的 页布局, 样子 会 很难看.
Sx 名称 NAME

小节 至少 由 三项 组成. 第一个 是
`.<B>man mdoc.samples</B>

'

名称宏,
命名 手册页的 主题. 第二个 是 名称描述宏
`. - ,

'

它 把 主题名称 和 第三项, 描述, 分离开来.
描述 应该 尽可能的 精简易懂, 少占空间.

.Sh 总览 SYNOPSIS
Sx SYNOPSIS

总览小节 描述 该 手册页对象 的 典型用途.
请求的宏 是 下面 的 任意一个,
`.Nm'

,
`.Cd'

,
`.Fn'

,
(也可能是
`.Fo'

,
`.Fc'

,
`.Fd'

,
`.Ft'

宏). 函数名称宏
`.Fn'

用在 手册页 的 第二第三部分, 命令 和 基本名称宏
`.<B>man mdoc.samples</B>

'

用在
手册页 的 1, 5, 6, 7, 8 部分. 手册 第四部分 需要
`.Nm'

, 
`.Fd'

或
`.Cd'

配制设备用途宏. 其他一些 宏 可能 用来 产生 概要行, 象下面的:
<P>


<BLOCKQUOTE>

<B>cat</B>

[-<B>benstuv</B>

]

[-

]

<I>file ...</I>


</BLOCKQUOTE>

<P>

下面 用到的 宏
<P>


<BLOCKQUOTE><TT>.</TT><B>cat</B>

</BLOCKQUOTE>

<BLOCKQUOTE><TT>.</TT>[-<B>benstuv</B>

]

</BLOCKQUOTE>

<BLOCKQUOTE><TT>.</TT>[-

]

</BLOCKQUOTE>

<BLOCKQUOTE><TT>.</TT><I>file ...</I>

</BLOCKQUOTE>
<P>

<B>注意</B>

 
宏
`.[,]

'

`.-

'

 
和
`.<I>file ...</I>

'

能够
识别 管道符
`'

 
因此 命令行 如:
<P>


<BLOCKQUOTE><TT>&quot;.</TT>[-<B>a | -b</B>



]

</BLOCKQUOTE>
<P>

的 表现 会 出轨.
Troff


一般把  当做 特殊符号. 参见
Sx 预定义串 PREDEFINED STRINGS ,

在 其他情况下  的使用.

.Sh 描述 DESCRIPTION
大多数 情况下
Sx 描述 DESCRIPTION

小节 的 第一段话 是 关于 这个 命令, 函数 或 文件 的 摘要, 后跟 字典式的
选项 以及 相应的解释. 创建 这样的 列表, 应该 使用
`.<DL COMPACT>
<P>

'

列表开始,
`.<DT><B>列表项和</B>

'

`.</DL>
<P>

'

列表结束宏
(参见下面的
Sx 列表和栏目 Lists and Columns

).
<P>

<P>

下面的
`.
<H2>小节首部</H2>

'

是 手册页 编排的 常见内容, 为了 保证 连续性, 应 适当 使用.
它们 按照 应该 出现 的 顺序 排列.
<DL COMPACT>
<P>

<DT><B>.</DL>
</DL>
</B>
<H2>环境 ENVIRONMENT</H2>



Sx 环境 ENVIRONMENT

小节 用来 揭示 相关的 环境变量 和 线索, 它们的 行为, 表现, 用法.

.Sh 示例 EXAMPLES
有 很多 办法 创建 示例, 详见 下面的
Sx 示例 EXAMPLES

小节.

.Sh 文件 FILES
由 手册页的 主题对象 创建 或 使用 的 文件, 应该 通过
`.宏在

'

Sx 文件 FILES

小节 陈列 出来.

.Sh 另见 SEE ALSO
如果 提及 其他 手册页 或 参照 相应的 手册, 应 把它们 放在
Sx 另见 SEE ALSO

小节. 参照主题 由
`.宏指定.

'

在
Sx 另见 SEE ALSO

小节 的 参照主题 应该按 手册节号 排序, 按 字母顺序 陈列, 并用 逗号 隔开, 
例如:
<P>

ls</A>(1),


ps</A>(1),


group</A>(5),


passwd</A>(5).


<P>

这时候 不太适合 用
refer</A>(1)


风格 的 参考引用.

.Sh 遵循 CONFORMING TO
如果 那些 命令, 库函数 或 文件 遵循 一定的 标准 实现, 如
St -p1003.2

或
St -ansiC ,

那就 不需要 这一小节. 如果 命令 不符合 任何标准, 应该 把 它的历史 放在
Sx 历史 HISTORY

小节.

.Sh 历史 HISTORY
任何 不属于 已知标准 的 命令 应该 在 这一节 给出 它的 大致历史.

.Sh 作者 AUTHORS
如果 有 必要, 把 致谢名单 也 列这儿.

.Sh 诊断 DIAGNOSTICS
应该 把 诊断命令 放在 这一节.

.Sh 错误 ERRORS
特定的 错误处理, 尤其是 库函数 (手册页第二第三部分), 放这儿.
`.Er 宏

'

用来 指定 一个 errno.

.Sh BUGS
明显的 问题 放这儿...
<P>

<P>

可以 增加一些 用户 制定的
`.
<H2>小节,</H2>

'

例如, 这样 设 小节:

<PRE>
.Sh PAGE STRUCTURE DOMAIN
</PRE>


<H3>段落和空行 Paragraphs and Line Spacing.</H3>

<DL COMPACT>
<P>

<DT><B>.<P>

</B>

`.<P>

'

把
段落命令 放在 所需的位置, 可以 产生 一个空行. 在
`.</DL>
</DL>

<H2>或</H2>

'

`.
<H3>宏</H3>

'

后面 不需要 这个 宏, 
`.<DL COMPACT>
<P>

'

宏
的 前面 也不需要. (
`.<DL COMPACT>
<P>

'

声明了
垂直方向 的 距离, 除非 给出 -compact 标志).
</DL>
<P>























































































































</DL>
</DL>

<H3>保持 Keeps</H3>

目前 只实现了 对单词的 保持 能力. 这个宏 有
`.(开始保持

'

<DD>begin-keep) 和
`.(结束保持

'

end-keep ) .
`.宏

'

的 唯一 参数是
-<B>words</B>

 
用于 防止 在 选项语句 的 中间 断行. 在 make 命令行参数的 例子里 (参见
Sx 名称背后 What's in a name ) ,

keep 宏防止
nroff


把 标志 和 参数 分成 两行.
(事实上 可以 用 选项宏 防止 此类 事情, 但 当我们 决定 在
troff


中 作为 基本选项, 强制 右边界对齐 时, 它 在 稀疏行里 展开的 很糟糕.
使用 保持宏 时 需要 多做点事, 增加 一个
-<B>line</B>

选项 ) .

<H3>示例和显示</H3>

有 五种类型 的 显示, 一个 快速的单行缩进显示
`.D1'

,
快速的单行原文显示
`.
<BLOCKQUOTE><TT>,</TT></BLOCKQUOTE>
'

原文块, 填充块, 和由
`.

'

(begin-display)
显示开始 和
`.
'

(end-display)
显示结束 宏对 组成的 不规则块.
<P>

<DL COMPACT>
<P>

<DT><B>.D1</B>



(D-one) 显示 一行 缩进文字. 该宏 可以被 (其他宏) 分析, 但 不能 被调用.
<P>


<BLOCKQUOTE><TT>-</TT><B>ldghfstru</B>

</BLOCKQUOTE>
<P>

上面是这样产生的:
<B>.
<BLOCKQUOTE></B><TT>-</TT><B>ldghfstru</B>

</BLOCKQUOTE>


 
<DT><B>.
<BLOCKQUOTE></B><TT>(D-ell) 显示 一行 缩进的</TT></BLOCKQUOTE>




<I>原文 literal</I>

 
`.
<BLOCKQUOTE><TT>示例宏</TT></BLOCKQUOTE>
'

已经 遍布 这篇 文档. 它 允许 缩进 (显示) 一行 文字.
其 缺省字体 设为 定宽 (原文), 它 可以 被 其他宏 分析 和 识别.
然而 不能 被 其他宏 调用.
<P>


<BLOCKQUOTE><TT>% ls -ldg /usr/local/bin</TT></BLOCKQUOTE>
<P>

上面是这样产生的
<B>.
<BLOCKQUOTE></B><TT>% ls -ldg /usr/local/bin</TT></BLOCKQUOTE>


 
<DT><B>.

</B>



显示开始.
`.

'

的
显示 必须由
`.
'

宏
结束. 显示 可以 嵌套在 显示 和 列表中.
`.

'

有
这样的 语法:
<P>


<BLOCKQUOTE><TT>&quot;.

</TT></BLOCKQUOTE>
<P>

显示类型 必须是 下面四个 之一, 可以 指定 一个 缩进量.
`.

'

 
<P>

<DL COMPACT>
<P>

<DT><B>-ragged</B>



以 打字 形式 显示 一块 正文, 其 右(和左)边界 是 不平整边界.
<DT><B>-filled</B>



显示 填充 (格式化) 块. 块中文字 被 格式化 (边界 已经 填充过, 
不再是 左边 不对齐 ).
<DT><B>-literal</B>



显示 原文块, 适用于 源程序, 或 那种 简单的, 用 table 和
空格 调整的 文字.
<DT><B>-file </B><I>file_name</I>





阅读 并 显示 跟在
-<B>file</B>

标志 后面的 文件. 原文模式 被打开, table 设为 8个字符 宽, 然而 文件中 
出现的 任何
troff/NsNm-mdoc


命令 都将 被处理.
<DT><B>-offset </B><I>string</I>





如果
-<B>offset</B>

指定为 下面 字符串 之一, 这些 字符串 解释为 对 以后的 正文块的 缩进层次.
<P>

<DL COMPACT>
<P>

<DT><B></B><I>left</I>



正文块 按 当前 左边界 对齐, 这是
`.

'

的
缺省模式.
<DT><B></B><I>center</I>



应该 是把 正文块 布在 中间. 不幸的是, 目前 只能在 大致的 中间位置
靠左 对齐.
<DT><B></B><I>indent</I>



按 缺省 缩进值 或 table 值 缩进. 这个 缺省 缩进值 同时 用于
`.D1'

显示, 因此 你 应该 使 这两种 显示 一致. 缩进值 一般 设为 6n, 
大约 2/3 英寸 (六个字符宽度).
<DT><B></B><I>indent-two</I>



缩进 缺省值的 两倍.
<DT><B></B><I>right</I>



在 距离 右边界 大约 两英寸处 把 正文块 靠
<I>左</I>

对齐. 这个宏 要 试验 效果, 有可能
troff


怎么 都 弄不对.
</DL>
<P>

</DL>
<P>

<DT><B>&quot;.Ed&quot;</B>

<DD>End-display.
显示结束.
</DL>
<P>


<H3>字体模式 Font Modes</H3>

现有 五个宏 用于 改变 手册页的 文字外观:
<DL COMPACT>
<P>

<DT><B>.</B><I>文字 可以 用</I>



`.<I>宏</I>

'

加重或强调. 常用的 强调字体 是 斜体 (italic).
<P>


<BLOCKQUOTE><TT>Usage: .</TT><I>argument ... </I>

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.</B><I>does not</I>





<I>does not</I>

<DT><B>.</B><I>exceed 1024 .</I>





<I>exceed 1024</I>

 
<DT><B>.</B><I>vide infra ) ) ,</I>





<I>vide infra ) )</I>

 
</DL>
<P>

<P>

`.<I>宏可以被</I>

'

(其他宏) 分析和调用. 不带参数 调用
`.<I>宏</I>

'

是 一个错误.
<DT><B>.`.原文宏</B>

'





用来 显示 字符, 变量, 常数, 任何 希望 照 输入文字 原样显示 的 内容.
<P>


<BLOCKQUOTE><TT>Usage: .</TT><B>argument ... </B>

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.\en</B>





<B>\n</B>

<DT><B>.M1 M2 M3;</B>





<B>M1 M2 M3</B>

 
<DT><B>.cntrl-D&nbsp;),</B>





<B>cntrl-D )</B>

 
<DT><B>.1024&nbsp;...</B>





<B>1024 ...</B>

</DL>
<P>

<P>

`.<B>宏可以被</B>

'

(其他宏) 分析和调用.
<DT><B>.一般说来 symbolic 强调宏 无论在 象徵主义 角度, 还是 传统的英语 里,</B>



都是 用 黑体 (bold) 显示.
<P>


<BLOCKQUOTE><TT>Usage: .</TT><B>symbol ... </B>

</BLOCKQUOTE>
<DL COMPACT>
<P>

<DT><B>.Important Notice</B>





<B>Important Notice</B>

</DL>
<P>

<P>

`.<B>宏可以被</B>

'

(其他宏) 分析和调用.
`.<B>的参数</B>

'

可以 用 引号括起.
<DT><B>.Bf </B>字体模式开始.





`.Bf 字体模式

'

必须用
`.Ef 宏结束.

'

字体模式宏 可以 嵌套.
`.Bf 宏

'

用 下面的 语法:
<P>


<BLOCKQUOTE><TT>&quot;.Bf </TT>font-mode

</BLOCKQUOTE>
<P>

字体模式 必须 是 下列 三种 之一:
`.Bf 

'

<P>

<DL COMPACT>
<P>

<DT><B></B><I>| -</I><B>emphasis</B>







就象 是 把
`.<I>宏</I>

'

用在 整个 正文块 一样.
<DT><B>| -literal</B>







就象 是 把
`.<B>宏</B>

'

用在 整个 正文块 一样.
<DT><B>| -symbolic</B>







就象 是 把
`.<B>宏</B>

'

用在 整个 正文块 一样.
</DL>
<P>

<DT><B>&quot;.Ef&quot;</B>

字体模式结束.
</DL>
<P>


<H3>标记栏和列表 Tagged Lists and Columns</H3>

有 多种 用
`.Bl'

列表开始宏 初始化的 列表. 表项 用
`.It'

项目宏 指定, 每一个 列表 必须 用
`.El'

宏结束. 列表 可以 嵌套在 列表和显示 中. 栏 可以 用在 列表 中, 但是 列表 
不能 列在 栏里.
<P>

另外 还可以 指定 列表属性, 像标记宽度, 列表偏移, 以及 紧凑模式
(允许 或 不允许 表项间的 空行)
在本文中 大多 使用了 标记风格 (tag style) 的 列表
(-<B>tag</B>

)

 
作为 步距变化, 表示 列表类型的 列表类型 是个 突出来 (overhanging) 的 列表
(-<B>ohang</B>

)

 
这种 列表类型 在
<B>TeX</B>

用户中 很流行, 但 看过 很多 页 的 标记列表 后 可能会 觉得 有点 滑稽.
`.Bl'

<P>
宏 可以 接受 下面的 列表类型:
<P>

<DL COMPACT>
<P>

<DT><B>-bullet</B>



<DT><B>-item</B>



<DT><B>-enum</B>



这三个 是 最简单的 列表类型. 一旦 使用了
`.Bl'

宏, 只能用
`.It'

宏 组织 表项 . 例如, 可以 这样 写 一个 简单的 数字列表&quot;

<BLOCKQUOTE>
<PRE>
.Bl -enum -compact
.It
Item one goes here.
.It
And item two here.
.It
Lastly item three goes here.
.El
</PRE>
</BLOCKQUOTE>

<P>

结果是:
<P>

<OL><P>

<LI>

<DD>Item one goes here.
<LI>

And item two here.
<LI>

Lastly item three goes here.
</OL><P>

<P>

简单的布告栏:

<BLOCKQUOTE>
<PRE>
.Bl -bullet -compact
.It
Bullet one goes here.
.It
Bullet two here.
.El
</PRE>
</BLOCKQUOTE>

<P>

产生:
<UL><P>

<LI>

Bullet one goes here.
<LI>

Bullet two here.
</UL><P>

<P>

<DT><B>-tag</B>



<DT><B>-diag</B>



<DT><B>-hang</B>



<DT><B>-ohang</B>



<DT><B>-inset</B>



这些 列表类型 收集
`.<DT><B>宏</B>

'

指定的 参数, 并且 创建 一个 标签, 它 可能会
<I>插入 inset</I>

后面的 文字中,
<I>悬挂 (hanged)</I>

显示在 后面的 文字前,
<I>突前 (overhanged)</I>

显示在 更高 位置, 并且 不能 缩进 或
<I>标记 tagged</I>

 
这个 列表 由
`-<B>ohang</B>

'

列表类型 构建.
`.<DT><B>宏</B>

'

只能 被 插入 (inset), 悬挂 (hang), 和 标记列表类型宏 分析,
且 不能 被调用. 
</DL>
<P>

这是 一个 插入标签 的 例子:
<DL COMPACT>
<P>

<DT><B></B><I>Tag</I>



<DD>The tagged list (also called a tagged paragraph) is the
most common type of list used in the Berkeley manuals.
<DT><B></B><I>Diag</I>



<DD>Diag lists create section four diagnostic lists
and are similar to inset lists except callable
macros are ignored.
<DT><B></B><I>Hang</I>



<DD>Hanged labels are a matter of taste.
<DT><B></B><I>Ohang</I>



<DD>Overhanging labels are nice when space is constrained.
<DT><B></B><I>Inset</I>



<DD>Inset labels are useful for controlling blocks of
paragraphs and are valuable for converting
<B>-mdoc</B>

manuals to other formats.
</DL>
<P>

<P>

下面是 产生 这个例子 的 源文本:

<BLOCKQUOTE>
<PRE>
.Bl -inset -offset indent
.It Em Tag
The tagged list (also called a tagged paragraph) is the
most common type of list used in the Berkeley manuals.
.It Em Diag
Diag lists create section four diagnostic lists
and are similar to inset lists except callable
macros are ignored.
.It Em Hang
Hanged labels are a matter of taste.
.It Em Ohang
Overhanging labels are nice when space is constrained.
.It Em Inset
Inset labels are useful for controlling blocks of
paragraphs and are valuable for converting
.Nm -mdoc
manuals to other formats.
.El
</PRE>
</BLOCKQUOTE>

<P>

这是 含有 两个表项 的 悬挂列表:
<DL COMPACT>
<P>

<DT><B></B><I>Hanged</I>



<DD>labels appear similar to tagged lists when the
label is smaller than the label width.
<DT><B></B><I>Longer hanged list labels</I>



<DD>blend in to the paragraph unlike
tagged paragraph labels.
</DL>
<P>

<P>

它们的 源文本为:

<BLOCKQUOTE>
<PRE>
.Bl -hang -offset indent
.It Em Hanged
labels appear similar to tagged lists when the
label is smaller than the label width.
.It Em Longer hanged list labels
blend in to the paragraph unlike
tagged paragraph labels.
.El
</PRE>
</BLOCKQUOTE>

<P>

带有 可选 宽度项的 标记列表 可以 控制 标记的 宽度.
<P>

<DL COMPACT>
<P>

<DT><B>SL</B>

<DD>sleep time of the process (seconds blocked)
<DT><B>PAGEIN</B>

<DD>number of disk
<B>I/O 's</B>



resulting from references
by the process to pages not loaded in core.
<DT><B>UID</B>

<DD>numerical user-id of process owner
<DT><B>PPID</B>

<DD>numerical id of parent of process process priority
(non-positive when in non-interruptible wait)
</DL>
<P>

<P>

源文本是:

<BLOCKQUOTE>
<PRE>
.Bl -tag -width &quot;PAGEIN&quot; -compact -offset indent
.It SL
sleep time of the process (seconds blocked)
.It PAGEIN
number of disk
.Tn I/O Ns 's
resulting from references
by the process to pages not loaded in core.
.It UID
numerical user-id of process owner
.It PPID
numerical id of parent of process process priority
(non-positive when in non-interruptible wait)
.El
</PRE>
</BLOCKQUOTE>

<P>

可接受的 宽度说明:
<DL COMPACT>
<P>

<DT><B>-width </B><I>Fl</I>





把 宽度 设置为 标志 (flag) 的 缺省 宽度. 所有 可调用的 宏 都有
一个 缺省 宽度值. 目前
`.-

'

的
值 设为 十个 字符宽度, 大约 5/6 英寸.
<DT><B>-width </B><I>24n</I>





设置 宽度 为 24 个 字符宽度, 大约 两英寸. 要使 比例 调整正常, 字母
`n'

必不可少
<DT><B>-width </B><I>ENAMETOOLONG</I>





设置 宽度为 所给串的 长度.
<DT><B>-width  </B><I>\*qint mkfifo\*q</I>





同样, 设置 宽度为 所给串的 长度.
</DL>
<P>

<P>

如果 没有 为 标记列表类型 指定 宽度, 第一次 调用
`.
'

的
时候, 格式化软件 试图 决定 适当的宽度. 如果
`.It'

的 第一个 参数 是 可调用宏, 就 使用 这个宏的 缺省宽度, 就像 把 宏名 当做宽度.
可是 如果 列表中 的 其他表项 得到 另一个 可调用宏, 则 认为 它是 新的, 
嵌套的 列表.

<H2>预定义串 PREDEFINED STRINGS</H2>

下面的串 是 预定义的, 可以 用在 troff 的 串翻译序列
`\*(xx'

中, 这里的
<I>xx</I>

就是 定义的 串名; 以及 串翻译序列
`\*x'

,
这里的
<I>x</I>

是串名. 翻译序列 可以 用在 文本 的 任何地方.
<P>

<DL COMPACT>
<P>

<DT><B>String<TT>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TT>Nroff<TT>&nbsp;&nbsp;&nbsp;</TT>Troff</B>



<DT><B>&lt;= Ta </B>&lt;= Ta 







<DT><B>&gt;= Ta </B>&gt;= Ta 







<DT><B>Rq Ta </B>'' Ta 







<DT><B>Lq Ta </B>`` Ta 







<DT><B>ua Ta </B>^ Ta 







<DT><B>aa Ta </B>' Ta 







<DT><B>ga Ta </B>` Ta 









<DT><B>q Ta </B> Ta 







<DT><B>Pi Ta </B>pi Ta 







<DT><B>Ne Ta </B>!= Ta 







<DT><B>Le Ta </B>&lt;= Ta 







<DT><B>Ge Ta </B>&gt;= Ta 







<DT><B>Lt Ta </B>&lt; Ta 







<DT><B>Gt Ta </B>&gt; Ta 







<DT><B>Pm Ta </B>+- Ta 







<DT><B>If Ta </B>infinity Ta 







<DT><B>Na Ta </B><I>NaN</I> Ta 







<DT><B>Ba Ta </B>| Ta 







</DL>
<P>

<P>

<B>注意</B>

 <BR>
那个 名为
`q'

的 串 应该 写成
`\*q'

,
因为 它 只有 一个字符.

<H2>诊断 DIAGNOSTICS</H2>

<B>-mdoc</B>

的 除错系统 比较 有限, 但是 可以 帮助你 检测出 微妙的 错误,
例如 参数名 和 内部寄存器 或 宏名 冲突. (是什么?) 寄存器 是
troff


的 算术存储类, 用 一到二个字符 命名.
<B>-mdoc</B>

对
troff


和
ditroff


而言, 所有
<B>-mdoc</B>

的 内部寄存器 由 两个字符 组成, 格式是 &lt;大写字母&gt; &lt;小写字母&gt; 如
`<I>file ...</I>

'

 
&lt;小写字母&gt; &lt;大写字母&gt; 如
`aR'

或 &lt;字母&gt; &lt;数字&gt; 如
`C1'

作为 乱上加乱,
troff


有 它 自己的 内部寄存器, 由 两个 小写字母 组成, 或者 是 一个点 加上 
一个字母, 或者 是 转义字符 (meta-character) 和 字符. 已经 介绍过的 
示例中 展示过 怎样用 转义序列
`\&amp;'

<P>
防止 解释宏. 这办法 同样 适用于 内部寄存器名.
<P>


















如果 未经转义的 寄存器名 出现在 宏请求的 参数列表 中, 其 后果 不可预测.
一般说来, 如果 大段的文字 没有 出现在 该出现的 地方, 或者 短句, 如标签, 
消失了, 多半是 这个地方 误解了 参数列表中的 参数类型.
既然 你的母亲 都 没打算 让你 记住 那些 乱七八糟的 东西, 那就 用 一种办法
来 找出 参数 是否 有效: 
`.Db (debug)

'

宏 可以 显示出 对 大多数宏 的 参数列表的 解释.
诸如
`.<P>

'

之类
的 宏 不包含 调试信息, 但是 所有 可调用宏 包含, 我们 强烈建议 一旦
有 疑点, 打开
`.Db 宏.

'

<P>


<BLOCKQUOTE><TT>Usage: .Db </TT>[on | off]

</BLOCKQUOTE>
<P>

在 这个 示例中, 我们把 介于 debug 宏 之间 的 文本 故意 弄出点 错误 (标志参数
`aC'

应该 写成
`\&amp;aC'

):

<BLOCKQUOTE>
<PRE>
.Db on
.Op Fl aC Ar file )
.Db off
</PRE>
</BLOCKQUOTE>

<P>

结果输出为:

<BLOCKQUOTE>
<PRE>
<DD>DEBUGGING ON
DEBUG(argv) MACRO: `.Op'  Line #: 2
        Argc: 1  Argv: `Fl'  Length: 2
        Space: `'  Class: Executable
        Argc: 2  Argv: `aC'  Length: 2
        Space: `'  Class: Executable
        Argc: 3  Argv: `Ar'  Length: 2
        Space: `'  Class: Executable
        Argc: 4  Argv: `file'  Length: 4
        Space: ` '  Class: String
        Argc: 5  Argv: `)'  Length: 1
        Space: ` '  Class: Closing Punctuation or suffix
        MACRO REQUEST: .Op Fl aC Ar file )
DEBUGGING OFF
</PRE>
</BLOCKQUOTE>

<P>

调试信息的 第一行 是 调用的 宏名, 这里是
`.[和]

'

它 所在的 行号. 如果 涉及了 一个 或 多个 文件 (特别是 其他文件 
包含进来), 行号有可能失灵. 但如果 只有 一个文件, 它 应该是 准的.
第二行 给出了 参数计数, 参数
(`-

'

)

和
它的长度. 如果 参数的长度 是 两个字符, 将会 测试 看它 能否 执行 
(不幸的是,含有 非零值 的 寄存器 看上去 都能执行).
第三行 给出 分配给类的 空间, 以及 类的类型. 这里的 问题是, 参数 aC 
不应该 可执行. 类的 四种类型是 字符串, 可执行类, 结束标点, 和开始标点.
最后一行 显示了 读入的 完整 参数行. 下个例子里, 惹祸的
`aC'

被转义了:

<BLOCKQUOTE>
<PRE>
.Db on
.Em An escaped \&amp;aC
.Db off
</PRE>
</BLOCKQUOTE>


<BLOCKQUOTE>
<PRE>
DEBUGGING ON
DEBUG(fargv) MACRO: `.Em'  Line #: 2
        Argc: 1  Argv: `An'  Length: 2
        Space: ` '  Class: String
        Argc: 2  Argv: `escaped'  Length: 7
        Space: ` '  Class: String
        Argc: 3  Argv: `aC'  Length: 2
        Space: ` '  Class: String
        MACRO REQUEST: .Em An escaped &amp;aC
DEBUGGING OFF
</PRE>
</BLOCKQUOTE>

<P>

参数
`\&amp;aC'

表现出 同样的 长度2, 这是 因为
`\&amp;'

序列的 长度 为零, 但是 不存在 叫做
`\&amp;aC'

的 寄存器, 因此 它的类型 是 字符串.
<P>

其他 诊断内容 是 使用报告等, 能够 自我解释的.

<H2>GROFF, TROFF AND NROFF</H2>

The
<B>-mdoc</B>

宏包 不需要 和
groff


的 兼容模式.
<P>

为了 便于 在线阅读, 这个宏包 阻止了 分页, 页头, 页脚 之类 常常在
nroff


中 出现的 中断. 此时 即使在 手册页 尾,
groff


(和参数
-<B>T </B><I>ascii</I>





) 也 不会 提示 什么. 对 分页的 阻止 使得
nroffNs'd


文件 不适合 硬拷贝 (hardcopy). 有一个 名为
`cR'

的 寄存器 可以 通过 在 文件
/usr/src/share/tmac/doc-nroff

(依赖于宿主系统) 中置零, 恢复 传统风格.

<H2>相关文件 FILES</H2>

<DL COMPACT>
<P>

<DT><B>/usr/share/tmac/tmac.doc

</B>

手册宏包
<DT><B>/usr/share/misc/mdoc.template

</B>

编写 手册 的 模板
<DT><B>/usr/share/examples/mdoc/*

</B>

一些 手册页 的 例子
</DL>
<P>


<H2>另见 SEE ALSO</H2>

man</A>(1),


troff</A>(1),


mdoc</A>(7)



<H2>BUGS</H2>

仍然 没有 解决 在 标志参数中的 连字符, 在
Sx 描述 DESCRIPTION

小节 偶尔 会 出点麻烦 (在 连字符处 断行).
<P>

文档中 没有 声明 预定义串.
<P>

还没有 把 3f 小节 加进 头例程 (header routine) 中.
<P>

`.<B>man mdoc.samples</B>

'

字体
不应当在
Sx NAME

小节 中 改变.
<P>

应该 检查
`.Fn 防止

'

行 太短 的 时候 断行.
偶然 它会 断开 反括弧, 而 有时候 如果 某行 已满时, 看上去 会 很可笑.
<P>

当 使用 nroff 格式化 文档 时, 防止 页头和页脚 (不是 初始的 头和脚) 断开 的 方法
有可能 偶尔 在 页的底部 产生 一个 不可见的 部分填满的 行 (空行).
<P>

列表和显示宏不做任何保存, 显然它应该做的.






































Bf 
<H2>[中文版维护人]</H2>



<B>徐明 &lt;xuming@users.sourceforge.net</A>&gt;</B>


<H2>[中文版最新更新]</H2>

<B>2003/05/13</B>


<H2>《中国Linux论坛man手册页翻译计划》</H2>

<B>http://cmpp.linuxforum.net</A></B>

Ef 


<HR>
<H2>Index</H2>
<DL>
<DT>NAME (名字)</A><DD>
<DT>SYNOPSIS (总览)</A><DD>
<DT>DESCRIPTION (描述)</A><DD>
<DT>开始 GETTING STARTED</A><DD>
<DT>TROFF 特性</A><DD>
<DL>
<DT>宏的用法 Macro Usage</A><DD>
<DT>在参数中传递空格符 Passing Space Characters in an Argument</A><DD>
<DT>尾部的空白符 Trailing Blank Space Characters</A><DD>
<DT>转义特殊字符 Escaping Special Characters</A><DD>
</DL>
<DT>手册页结构分析 THE ANATOMY OF A MAN PAGE</A><DD>
<DL>
<DT>手册页的模板 A manual page template</A><DD>
</DL>
<DT>;</A><DD>
<DT>标题宏 TITLE MACROS</A><DD>
<DT>手册宏域 和 基本正文宏域的介绍</A><DD>
<DL>
<DT>名称背后 What's in a name...</A><DD>
<DT>基本语法 General Syntax</A><DD>
</DL>
<DT>手册域 MANUAL DOMAIN</A><DD>
<DL>
<DT>地址宏 Address Macro</A><DD>
<DT>作者名称 Author Name</A><DD>
<DT>参数宏 Argument Macro</A><DD>
<DT>配置定义 (手册第四部分) Configuration Declaration</A><DD>
<DT>命令修饰 Command Modifier</A><DD>
<DT>已定义的变量 Defined Variables</A><DD>
<DT>Errno's (仅供手册第二部分)</A><DD>
<DT>环境变量 Environment Variables</A><DD>
<DT>函数参数 Function Argument</A><DD>
<DT>函数声明 Function Declaration</A><DD>
<DT>标志 Flags</A><DD>
<DT>函数(库函数) Functions (library routines)</A><DD>
<DT>函数类型 Function Type</A><DD>
<DT>交互命令 Interactive Commands</A><DD>
<DT>名称宏 Name Macro</A><DD>
<DT>选项 Options</A><DD>
<DT>路径名 Pathnames</A><DD>
<DT>变量 Variables</A><DD>
<DT>手册页参照 Manual Page Cross References</A><DD>
</DL>
<DT>基本正文宏域 GENERAL TEXT DOMAIN</A><DD>
<DL>
<DT>AT&amp;T 宏</A><DD>
<DT>BSD 宏</A><DD>
<DT>FreeBSD 宏</A><DD>
<DT>UNIX 宏</A><DD>
<DT>嵌入和引用宏 Enclosure and Quoting Macros</A><DD>
<DT>No-Op 或正文宏 or Normal Text Macro</A><DD>
<DT>无空格宏 No Space Macro</A><DD>
<DT>手册页对照参考 Section Cross References</A><DD>
<DT>参考和引言 References and Citations</A><DD>
<DT>返回值 Return Values</A><DD>
<DT>Trade Names (或缩略和类型名)</A><DD>
<DT>扩展参数 Extended  Arguments</A><DD>
</DL>
<DT>页结构宏宏域 PAGE STRUCTURE DOMAIN</A><DD>
<DL>
<DT>小节首部 Section Headers</A><DD>
</DL>
<DT>小节首部宏.</A><DD>
<DT>宏</A><DD>
<DT>名称 NAME</A><DD>
<DT>名称</A><DD>
<DT>小节首部</A><DD>
<DT>环境 ENVIRONMENT</A><DD>
<DT>小节,</A><DD>
<DL>
<DT>段落和空行 Paragraphs and Line Spacing.</A><DD>
</DL>
<DT>或</A><DD>
<DL>
<DT>宏</A><DD>
<DT>保持 Keeps</A><DD>
<DT>示例和显示</A><DD>
<DT>字体模式 Font Modes</A><DD>
<DT>标记栏和列表 Tagged Lists and Columns</A><DD>
</DL>
<DT>预定义串 PREDEFINED STRINGS</A><DD>
<DT>诊断 DIAGNOSTICS</A><DD>
<DT>GROFF, TROFF AND NROFF</A><DD>
<DT>相关文件 FILES</A><DD>
<DT>另见 SEE ALSO</A><DD>
<DT>BUGS</A><DD>
<DT>[中文版维护人]</A><DD>
<DT>[中文版最新更新]</A><DD>
<DT>《中国Linux论坛man手册页翻译计划》</A><DD>
</DL>
<HR>
This document was created by
man2html</A>,
using the manual pages.<BR>
Time:  GMT, January 14, 2004
</BODY>
</HTML>
