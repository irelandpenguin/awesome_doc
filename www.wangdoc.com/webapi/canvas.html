<!DOCTYPE html><html lang="zh-CN" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Canvas API - Web API 教程 - 网道</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="Canvas API"><link rel="apple-touch-icon" sizes="57x57" href="assets/icons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="assets/icons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="assets/icons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="assets/icons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="assets/icons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="assets/icons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="assets/icons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="assets/icons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="assets/icons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="assets/icons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="assets/icons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="assets/icons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="assets/icons/favicon-16x16.png"><link rel="manifest" href="assets/icons/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="assets/icons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">网道 / WangDoc.com </a><a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu" id="navMenu"><div class="navbar-end"><div class="navbar-item"><form action="https://sourcegraph.com/search" target="_blank" method="get" onsubmit='this.q.value="repo:^github.com/wangdoc/webapi-tutorial$ "+this.origin.value'><p class="control has-icons-right"><input class="input" type="text" name="origin" placeholder="搜索..."> <span class="icon is-small is-right"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24"><path fill="#ddd" d="M23.822 20.88l-6.353-6.354c.93-1.465 1.467-3.2 1.467-5.059.001-5.219-4.247-9.467-9.468-9.467s-9.468 4.248-9.468 9.468c0 5.221 4.247 9.469 9.468 9.469 1.768 0 3.421-.487 4.839-1.333l6.396 6.396 3.119-3.12zm-20.294-11.412c0-3.273 2.665-5.938 5.939-5.938 3.275 0 5.94 2.664 5.94 5.938 0 3.275-2.665 5.939-5.94 5.939-3.274 0-5.939-2.664-5.939-5.939z"/></svg></span></p><input type="hidden" name="q" value=""> <input type="hidden" name="patternType" value="literal"></form></div><a class="navbar-item is-hidden-desktop-only" target="_blank" href="https://github.com/wangdoc/webapi-tutorial"><span class="icon" style="color: #333;"><i class="fa fa-lg fa-github"></i></span></a></div></div></div></nav><section class="section main article"><div class="container"><div class="columns"><div class="column is-8"><nav class="breadcrumb is-size-5-desktop" aria-label="breadcrumbs"><ul><li><a href="index.html"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;Web API 教程</a></li><li class="is-active"><a class="has-text-grey" href="canvas.html">Canvas API</a></li></ul></nav><nav class="level level-previous-next is-size-5 is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="index.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> Home</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="clipboard.html">Clipboard API <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content is-size-4-widescreen"><h1 class="title">Canvas API</h1><div class="page-meta"><p>网道（WangDoc.com），互联网文档计划</p></div><h2 id="概述">概述 <a class="markdownIt-Anchor" href="#概述">#</a></h2><p><code>&lt;canvas&gt;</code>元素用于生成图像。它本身就像一个画布，JavaScript 通过操作它的 API，在上面生成图像。它的底层是一个个像素，基本上<code>&lt;canvas&gt;</code>是一个可以用 JavaScript 操作的位图（bitmap）。</p><p>它与 SVG 图像的区别在于，<code>&lt;canvas&gt;</code>是脚本调用各种方法生成图像，SVG 则是一个 XML 文件，通过各种子元素生成图像。</p><p>使用 Canvas API 之前，需要在网页里面新建一个<code>&lt;canvas&gt;</code>元素。</p><pre class="hljs"><code><span class="hljs-tag">&lt;<span class="hljs-name">canvas</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;400&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;250&quot;</span>&gt;</span>
  您的浏览器不支持 Canvas
<span class="hljs-tag">&lt;/<span class="hljs-name">canvas</span>&gt;</span>
</code></pre><p>如果浏览器不支持这个 API，就会显示<code>&lt;canvas&gt;</code>标签中间的文字：“您的浏览器不支持 Canvas”。</p><p>每个<code>&lt;canvas&gt;</code>元素都有一个对应的<code>CanvasRenderingContext2D</code>对象（上下文对象）。Canvas API 就定义在这个对象上面。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);
</code></pre><p>上面代码中，<code>&lt;canvas&gt;</code>元素节点对象的<code>getContext()</code>方法，返回的就是<code>CanvasRenderingContext2D</code>对象。</p><p>注意，Canvas API 需要<code>getContext</code>方法指定参数<code>2d</code>，表示该<code>&lt;canvas&gt;</code>节点生成 2D 的平面图像。如果参数是<code>webgl</code>，就表示用于生成 3D 的立体图案，这部分属于 WebGL API。</p><p>按照用途，Canvas API 分成两大部分：绘制图形和图像处理。</p><h2 id="canvas-api：绘制图形">Canvas API：绘制图形 <a class="markdownIt-Anchor" href="#canvas-api：绘制图形">#</a></h2><p>Canvas 画布提供了一个作图的平面空间，该空间的每个点都有自己的坐标。原点<code>(0, 0)</code>位于图像左上角，<code>x</code>轴的正向是原点向右，<code>y</code>轴的正向是原点向下。</p><h3 id="路径">路径 <a class="markdownIt-Anchor" href="#路径">#</a></h3><p>以下方法和属性用来绘制路径。</p><ul><li><code>CanvasRenderingContext2D.beginPath()</code>：开始绘制路径。</li><li><code>CanvasRenderingContext2D.closePath()</code>：结束路径，返回到当前路径的起始点，会从当前点到起始点绘制一条直线。如果图形已经封闭，或者只有一个点，那么此方法不会产生任何效果。</li><li><code>CanvasRenderingContext2D.moveTo()</code>：设置路径的起点，即将一个新路径的起始点移动到<code>(x，y)</code>坐标。</li><li><code>CanvasRenderingContext2D.lineTo()</code>：使用直线从当前点连接到<code>(x, y)</code>坐标。</li><li><code>CanvasRenderingContext2D.fill()</code>：在路径内部填充颜色（默认为黑色）。</li><li><code>CanvasRenderingContext2D.stroke()</code>：路径线条着色（默认为黑色）。</li><li><code>CanvasRenderingContext2D.fillStyle</code>：指定路径填充的颜色和样式（默认为黑色）。</li><li><code>CanvasRenderingContext2D.strokeStyle</code>：指定路径线条的颜色和样式（默认为黑色）。</li></ul><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.beginPath();
ctx.moveTo(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);
ctx.lineTo(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>);
ctx.lineTo(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);
</code></pre><p>上面代码只是确定了路径的形状，画布上还看不出来，因为没有颜色。所以还需要着色。</p><pre class="hljs"><code>ctx.fill()
<span class="hljs-comment">// 或者</span>
ctx.stroke()
</code></pre><p>上面代码中，这两个方法都可以使得路径可见。<code>fill()</code>在路径内部填充颜色，使之变成一个实心的图形；<code>stroke()</code>只对路径线条着色。</p><p>这两个方法默认都是使用黑色，可以使用<code>fillStyle</code>和<code>strokeStyle</code>属性指定其他颜色。</p><pre class="hljs"><code>ctx.fillStyle = <span class="hljs-string">&#x27;red&#x27;</span>;
ctx.fill();
<span class="hljs-comment">// 或者</span>
ctx.strokeStyle = <span class="hljs-string">&#x27;red&#x27;</span>;
ctx.stroke();
</code></pre><p>上面代码将填充和线条的颜色指定为红色。</p><h3 id="线型">线型 <a class="markdownIt-Anchor" href="#线型">#</a></h3><p>以下的方法和属性控制线条的视觉特征。</p><ul><li><code>CanvasRenderingContext2D.lineWidth</code>：指定线条的宽度，默认为1.0。</li><li><code>CanvasRenderingContext2D.lineCap</code>：指定线条末端的样式，有三个可能的值：<code>butt</code>（默认值，末端为矩形）、<code>round</code>（末端为圆形）、<code>square</code>（末端为突出的矩形，矩形宽度不变，高度为线条宽度的一半）。</li><li><code>CanvasRenderingContext2D.lineJoin</code>：指定线段交点的样式，有三个可能的值：<code>round</code>（交点为扇形）、<code>bevel</code>（交点为三角形底边）、<code>miter</code>（默认值，交点为菱形)。</li><li><code>CanvasRenderingContext2D.miterLimit</code>：指定交点菱形的长度，默认为10。该属性只在<code>lineJoin</code>属性的值等于<code>miter</code>时有效。</li><li><code>CanvasRenderingContext2D.getLineDash()</code>：返回一个数组，表示虚线里面线段和间距的长度。</li><li><code>CanvasRenderingContext2D.setLineDash()</code>：数组，用于指定虚线里面线段和间距的长度。</li></ul><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.beginPath();
ctx.moveTo(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);
ctx.lineTo(<span class="hljs-number">200</span>, <span class="hljs-number">200</span>);
ctx.lineTo(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);

ctx.lineWidth = <span class="hljs-number">3</span>;
ctx.lineCap = <span class="hljs-string">&#x27;round&#x27;</span>;
ctx.lineJoin = <span class="hljs-string">&#x27;round&#x27;</span>;
ctx.setLineDash([<span class="hljs-number">15</span>, <span class="hljs-number">5</span>]);
ctx.stroke();
</code></pre><p>上面代码中，线条的宽度为3，线条的末端和交点都改成圆角，并且设置为虚线。</p><h3 id="矩形">矩形 <a class="markdownIt-Anchor" href="#矩形">#</a></h3><p>以下方法用来绘制矩形。</p><ul><li><code>CanvasRenderingContext2D.rect()</code>：绘制矩形路径。</li><li><code>CanvasRenderingContext2D.fillRect()</code>：填充一个矩形。</li><li><code>CanvasRenderingContext2D.strokeRect()</code>：绘制矩形边框。</li><li><code>CanvasRenderingContext2D.clearRect()</code>：指定矩形区域的像素都变成透明。</li></ul><p>上面四个方法的格式都一样，都接受四个参数，分别是矩形左上角的横坐标和纵坐标、矩形的宽和高。</p><p><code>CanvasRenderingContext2D.rect()</code>方法用于绘制矩形路径。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.rect(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);
ctx.fill();
</code></pre><p>上面代码绘制一个正方形，左上角坐标为<code>(10, 10)</code>，宽和高都为100。</p><p><code>CanvasRenderingContext2D.fillRect()</code>用来向一个矩形区域填充颜色。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.fillStyle = <span class="hljs-string">&#x27;green&#x27;</span>;
ctx.fillRect(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);
</code></pre><p>上面代码绘制一个绿色的正方形，左上角坐标为<code>(10, 10)</code>，宽和高都为100。</p><p><code>CanvasRenderingContext2D.strokeRect()</code>用来绘制一个矩形区域的边框。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.strokeStyle = <span class="hljs-string">&#x27;green&#x27;</span>;
ctx.strokeRect(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);
</code></pre><p>上面代码绘制一个绿色的空心正方形，左上角坐标为<code>(10, 10)</code>，宽和高都为100。</p><p><code>CanvasRenderingContext2D.clearRect()</code>用于擦除指定矩形区域的像素颜色，等同于把早先的绘制效果都去除。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.fillRect(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);
ctx.clearRect(<span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">90</span>, <span class="hljs-number">90</span>);
</code></pre><p>上面代码先绘制一个 100 x 100 的正方形，然后在它的内部擦除 90 x 90 的区域，等同于形成了一个5像素宽度的边框。</p><h3 id="弧线">弧线 <a class="markdownIt-Anchor" href="#弧线">#</a></h3><p>以下方法用于绘制弧形。</p><ul><li><code>CanvasRenderingContext2D.arc()</code>：通过指定圆心和半径绘制弧形。</li><li><code>CanvasRenderingContext2D.arcTo()</code>：通过指定两根切线和半径绘制弧形。</li></ul><p><code>CanvasRenderingContext2D.arc()</code>主要用来绘制圆形或扇形。</p><pre class="hljs"><code><span class="hljs-comment">// 格式</span>
ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise)

<span class="hljs-comment">// 实例</span>
ctx.arc(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI, <span class="hljs-literal">true</span>)
</code></pre><p><code>arc()</code>方法的<code>x</code>和<code>y</code>参数是圆心坐标，<code>radius</code>是半径，<code>startAngle</code>和<code>endAngle</code>则是扇形的起始角度和终止角度（以弧度表示），<code>anticlockwise</code>表示做图时应该逆时针画（<code>true</code>）还是顺时针画（<code>false</code>），这个参数用来控制扇形的方向（比如上半圆还是下半圆）。</p><p>下面是绘制实心圆形的例子。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.beginPath();
ctx.arc(<span class="hljs-number">60</span>, <span class="hljs-number">60</span>, <span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>); 
ctx.fill();
</code></pre><p>上面代码绘制了一个半径50，起始角度为0，终止角度为 2 * PI 的完整的圆。</p><p>绘制空心半圆的例子。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.beginPath();
ctx.moveTo(<span class="hljs-number">50</span>, <span class="hljs-number">20</span>);
ctx.arc(<span class="hljs-number">100</span>, <span class="hljs-number">20</span>, <span class="hljs-number">50</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.PI, <span class="hljs-literal">false</span>);
ctx.stroke();
</code></pre><p><code>CanvasRenderingContext2D.arcTo()</code>方法主要用来绘制圆弧，需要给出两个点的坐标，当前点与第一个点形成一条直线，第一个点与第二个点形成另一条直线，然后画出与这两根直线相切的弧线。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.beginPath();
ctx.moveTo(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
ctx.arcTo(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">25</span>);
ctx.lineTo(<span class="hljs-number">100</span>, <span class="hljs-number">0</span>);
ctx.stroke();
</code></pre><p>上面代码中，<code>arcTo()</code>有5个参数，前两个参数是第一个点的坐标，第三个参数和第四个参数是第二个点的坐标，第五个参数是半径。然后，<code>(0, 0)</code>与<code>(50, 50)</code>形成一条直线，然后<code>(50, 50)</code>与<code>(100, 0)</code>形成第二条直线。弧线就是与这两根直线相切的部分。</p><h3 id="文本">文本 <a class="markdownIt-Anchor" href="#文本">#</a></h3><p>以下方法和属性用于绘制文本。</p><ul><li><code>CanvasRenderingContext2D.fillText()</code>：在指定位置绘制实心字符。</li><li><code>CanvasRenderingContext2D.strokeText()</code>：在指定位置绘制空心字符。</li><li><code>CanvasRenderingContext2D.measureText()</code>：返回一个 TextMetrics 对象。</li><li><code>CanvasRenderingContext2D.font</code>：指定字型大小和字体，默认值为<code>10px sans-serif</code>。</li><li><code>CanvasRenderingContext2D.textAlign</code>：文本的对齐方式，默认值为<code>start</code>。</li><li><code>CanvasRenderingContext2D.direction</code>：文本的方向，默认值为<code>inherit</code>。</li><li><code>CanvasRenderingContext2D.textBaseline</code>：文本的垂直位置，默认值为<code>alphabetic</code>。</li></ul><p><code>fillText()</code>方法用来在指定位置绘制实心字符。</p><pre class="hljs"><code>CanvasRenderingContext2D.fillText(text, x, y [, maxWidth])
</code></pre><p>该方法接受四个参数。</p><ul><li><code>text</code>：所要填充的字符串。</li><li><code>x</code>：文字起点的横坐标，单位像素。</li><li><code>y</code>：文字起点的纵坐标，单位像素。</li><li><code>maxWidth</code>：文本的最大像素宽度。该参数可选，如果省略，则表示宽度没有限制。如果文本实际长度超过这个参数指定的值，那么浏览器将尝试用较小的字体填充。</li></ul><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.fillText(<span class="hljs-string">&#x27;Hello world&#x27;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
</code></pre><p>上面代码在<code>(50, 50)</code>位置写入字符串<code>Hello world</code>。</p><p>注意，<code>fillText()</code>方法不支持文本断行，所有文本一定出现在一行内。如果要生成多行文本，只有调用多次<code>fillText()</code>方法。</p><p><code>strokeText()</code>方法用来添加空心字符，它的参数与<code>fillText()</code>一致。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.strokeText(<span class="hljs-string">&#x27;Hello world&#x27;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
</code></pre><p>上面这两种方法绘制的文本，默认都是<code>10px</code>大小、<code>sans-serif</code>字体，<code>font</code>属性可以改变字体设置。该属性的值是一个字符串，使用 CSS 的<code>font</code>属性即可。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.font = <span class="hljs-string">&#x27;Bold 20px Arial&#x27;</span>;
ctx.fillText(<span class="hljs-string">&#x27;Hello world&#x27;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
</code></pre><p><code>textAlign</code>属性用来指定文本的对齐方式。它可以取以下几个值。</p><ul><li><code>left</code>：左对齐</li><li><code>right</code>：右对齐</li><li><code>center</code>：居中</li><li><code>start</code>：默认值，起点对齐（从左到右的文本为左对齐，从右到左的文本为右对齐）。</li><li><code>end</code>：结尾对齐（从左到右的文本为右对齐，从右到左的文本为左对齐）。</li></ul><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.font = <span class="hljs-string">&#x27;Bold 20px Arial&#x27;</span>;
ctx.textAlign = <span class="hljs-string">&#x27;center&#x27;</span>;
ctx.fillText(<span class="hljs-string">&#x27;Hello world&#x27;</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
</code></pre><p><code>direction</code>属性指定文本的方向，默认值为<code>inherit</code>，表示继承<code>&lt;canvas&gt;</code>或<code>document</code>的设置。其他值包括<code>ltr</code>（从左到右）和<code>rtl</code>（从右到左）。</p><p><code>textBaseline</code>属性指定文本的垂直位置，可以取以下值。</p><ul><li><code>top</code>：上部对齐（字母的基线是整体上移）。</li><li><code>hanging</code>：悬挂对齐（字母的上沿在一根直线上），适用于印度文和藏文。</li><li><code>middle</code>：中部对齐（字母的中线在一根直线上）。</li><li><code>alphabetic</code>：默认值，表示字母位于字母表的正常位置（四线格的第三根线）。</li><li><code>ideographic</code>：下沿对齐（字母的下沿在一根直线上），使用于东亚文字。</li><li><code>bottom</code>：底部对齐（字母的基线下移）。对于英文字母，这个设置与<code>ideographic</code>没有差异。</li></ul><p><code>measureText()</code>方法接受一个字符串作为参数，返回一个 TextMetrics 对象，可以从这个对象上面获取参数字符串的信息，目前主要是文本渲染后的宽度（<code>width</code>）。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

<span class="hljs-keyword">var</span> text1 = ctx.measureText(<span class="hljs-string">&#x27;Hello world&#x27;</span>);
text.width <span class="hljs-comment">// 49.46</span>

ctx.font = <span class="hljs-string">&#x27;Bold 20px Arial&#x27;</span>;
text2.width <span class="hljs-comment">// 107.78</span>
</code></pre><p>上面代码中，<code>10px</code>大小的字符串<code>Hello world</code>，渲染后宽度为<code>49.46</code>。放大到<code>20px</code>以后，宽度为<code>107.78</code>。</p><h3 id="渐变色和图像填充">渐变色和图像填充 <a class="markdownIt-Anchor" href="#渐变色和图像填充">#</a></h3><p>以下方法用于设置渐变效果和图像填充效果。</p><ul><li><code>CanvasRenderingContext2D.createLinearGradient()</code>：定义线性渐变样式。</li><li><code>CanvasRenderingContext2D.createRadialGradient()</code>：定义辐射渐变样式。</li><li><code>CanvasRenderingContext2D.createPattern()</code>：定义图像填充样式。</li></ul><p><code>createLinearGradient()</code>方法按照给定直线，生成线性渐变的样式。</p><pre class="hljs"><code>ctx.createLinearGradient(x0, y0, x1, y1)
</code></pre><p><code>ctx.createLinearGradient(x0, y0, x1, y1)</code>方法接受四个参数：<code>x0</code>和<code>y0</code>是起点的横坐标和纵坐标，<code>x1</code>和<code>y1</code>是终点的横坐标和纵坐标。通过不同的坐标值，可以生成从上至下、从左到右的渐变等等。</p><p>该方法的返回值是一个<code>CanvasGradient</code>对象，该对象只有一个<code>addColorStop()</code>方向，用来指定渐变点的颜色。<code>addColorStop()</code>方法接受两个参数，第一个参数是0到1之间的一个位置量，0表示起点，1表示终点，第二个参数是一个字符串，表示 CSS 颜色。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

<span class="hljs-keyword">var</span> gradient = ctx.createLinearGradient(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">200</span>, <span class="hljs-number">0</span>);
gradient.addColorStop(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;green&#x27;</span>);
gradient.addColorStop(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;white&#x27;</span>);
ctx.fillStyle = gradient;
ctx.fillRect(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">200</span>, <span class="hljs-number">100</span>);
</code></pre><p>上面代码中，定义了渐变样式<code>gradient</code>以后，将这个样式指定给<code>fillStyle</code>属性，然后<code>fillRect()</code>就会生成以这个样式填充的矩形区域。</p><p><code>createRadialGradient()</code>方法定义一个辐射渐变，需要指定两个圆。</p><pre class="hljs"><code>ctx.createRadialGradient(x0, y0, r0, x1, y1, r1)
</code></pre><p><code>createRadialGradient()</code>方法接受六个参数，<code>x0</code>和<code>y0</code>是辐射起始的圆的圆心坐标，<code>r0</code>是起始圆的半径，<code>x1</code>和<code>y1</code>是辐射终止的圆的圆心坐标，<code>r1</code>是终止圆的半径。</p><p>该方法的返回值也是一个<code>CanvasGradient</code>对象。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

<span class="hljs-keyword">var</span> gradient = ctx.createRadialGradient(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);
gradient.addColorStop(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;white&#x27;</span>);
gradient.addColorStop(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;green&#x27;</span>);
ctx.fillStyle = gradient;
ctx.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">200</span>, <span class="hljs-number">200</span>);
</code></pre><p>上面代码中，生成辐射样式以后，用这个样式填充一个矩形。</p><p><code>createPattern()</code>方法定义一个图像填充样式，在指定方向上不断重复该图像，填充指定的区域。</p><pre class="hljs"><code>ctx.createPattern(image, repetition)
</code></pre><p>该方法接受两个参数，第一个参数是图像数据，它可以是<code>&lt;img&gt;</code>元素，也可以是另一个<code>&lt;canvas&gt;</code>元素，或者一个表示图像的 Blob 对象。第二个参数是一个字符串，有四个可能的值，分别是<code>repeat</code>（双向重复）、<code>repeat-x</code>(水平重复)、<code>repeat-y</code>(垂直重复)、<code>no-repeat</code>(不重复)。如果第二个参数是空字符串或<code>null</code>，则等同于<code>null</code>。</p><p>该方法的返回值是一个<code>CanvasPattern</code>对象。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

<span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> Image();
img.src = <span class="hljs-string">&#x27;https://example.com/pattern.png&#x27;</span>;
img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> </span>) </span>{
  <span class="hljs-keyword">var</span> pattern = ctx.createPattern(img, <span class="hljs-string">&#x27;repeat&#x27;</span>);
  ctx.fillStyle = pattern;
  ctx.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">400</span>, <span class="hljs-number">400</span>);
};
</code></pre><p>上面代码中，图像加载成功以后，使用<code>createPattern()</code>生成图像样式，然后使用这个样式填充指定区域。</p><h3 id="阴影">阴影 <a class="markdownIt-Anchor" href="#阴影">#</a></h3><p>以下属性用于设置阴影。</p><ul><li><code>CanvasRenderingContext2D.shadowBlur</code>：阴影的模糊程度，默认为<code>0</code>。</li><li><code>CanvasRenderingContext2D.shadowColor</code>：阴影的颜色，默认为<code>black</code>。</li><li><code>CanvasRenderingContext2D.shadowOffsetX</code>：阴影的水平位移，默认为<code>0</code>。</li><li><code>CanvasRenderingContext2D.shadowOffsetY</code>：阴影的垂直位移，默认为<code>0</code>。</li></ul><p>下面是一个例子。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.shadowOffsetX = <span class="hljs-number">10</span>;
ctx.shadowOffsetY = <span class="hljs-number">10</span>;
ctx.shadowBlur = <span class="hljs-number">5</span>;
ctx.shadowColor = <span class="hljs-string">&#x27;rgba(0,0,0,0.5)&#x27;</span>;

ctx.fillStyle = <span class="hljs-string">&#x27;green&#x27;</span>;
ctx.fillRect(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);
</code></pre><h2 id="canvas-api：图像处理">Canvas API：图像处理 <a class="markdownIt-Anchor" href="#canvas-api：图像处理">#</a></h2><h3 id="canvasrenderingcontext2ddrawimage">CanvasRenderingContext2D.drawImage() <a class="markdownIt-Anchor" href="#canvasrenderingcontext2ddrawimage">#</a></h3><p>Canvas API 允许将图像文件写入画布，做法是读取图片后，使用<code>drawImage()</code>方法将这张图片放上画布。</p><p><code>CanvasRenderingContext2D.drawImage()</code>有三种使用格式。</p><pre class="hljs"><code>ctx.drawImage(image, dx, dy);
ctx.drawImage(image, dx, dy, dWidth, dHeight);
ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
</code></pre><p>各个参数的含义如下。</p><ul><li>image：图像元素</li><li>sx：图像内部的横坐标，用于映射到画布的放置点上。</li><li>sy：图像内部的纵坐标，用于映射到画布的放置点上。</li><li>sWidth：图像在画布上的宽度，会产生缩放效果。如果未指定，则图像不会缩放，按照实际大小占据画布的宽度。</li><li>sHeight：图像在画布上的高度，会产生缩放效果。如果未指定，则图像不会缩放，按照实际大小占据画布的高度。</li><li>dx：画布内部的横坐标，用于放置图像的左上角</li><li>dy：画布内部的纵坐标，用于放置图像的右上角</li><li>dWidth：图像在画布内部的宽度，会产生缩放效果。</li><li>dHeight：图像在画布内部的高度，会产生缩放效果。</li></ul><p>下面是最简单的使用场景，将图像放在画布上，两者左上角对齐。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

<span class="hljs-keyword">var</span> img = <span class="hljs-keyword">new</span> Image();
img.src = <span class="hljs-string">&#x27;image.png&#x27;</span>;
img.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  ctx.drawImage(img, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
};
</code></pre><p>上面代码将一个 PNG 图像放入画布。这时，图像将是原始大小，如果画布小于图像，就会只显示出图像左上角，正好等于画布大小的那一块。</p><p>如果要显示完整的图片，可以用图像的宽和高，设置成画布的宽和高。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

<span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> Image(<span class="hljs-number">60</span>, <span class="hljs-number">45</span>);
image.onload = drawImageActualSize;
image.src = <span class="hljs-string">&#x27;https://example.com/image.jpg&#x27;</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">drawImageActualSize</span>(<span class="hljs-params"></span>) </span>{
  canvas.width = <span class="hljs-built_in">this</span>.naturalWidth;
  canvas.height = <span class="hljs-built_in">this</span>.naturalHeight;
  ctx.drawImage(<span class="hljs-built_in">this</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>.naturalWidth, <span class="hljs-built_in">this</span>.naturalHeight);
}
</code></pre><p>上面代码中，<code>&lt;canvas&gt;</code>元素的大小设置成图像的本来大小，就能保证完整展示图像。由于图像的本来大小，只有图像加载成功以后才能拿到，因此调整画布的大小，必须放在<code>image.onload</code>这个监听函数里面。</p><h3 id="像素读写">像素读写 <a class="markdownIt-Anchor" href="#像素读写">#</a></h3><p>以下三个方法与像素读写相关。</p><ul><li><code>CanvasRenderingContext2D.getImageData()</code>：将画布读取成一个 ImageData 对象</li><li><code>CanvasRenderingContext2D.putImageData()</code>：将 ImageData 对象写入画布</li><li><code>CanvasRenderingContext2D.createImageData()</code>：生成 ImageData 对象</li></ul><p><strong>（1）getImageData()</strong></p><p><code>CanvasRenderingContext2D.getImageData()</code>方法用来读取<code>&lt;canvas&gt;</code>的内容，返回一个 ImageData 对象，包含了每个像素的信息。</p><pre class="hljs"><code>ctx.getImageData(sx, sy, sw, sh)
</code></pre><p><code>getImageData()</code>方法接受四个参数。<code>sx</code>和<code>sy</code>是读取区域的左上角坐标，<code>sw</code>和<code>sh</code>是读取区域的宽度和高度。如果想要读取整个<code>&lt;canvas&gt;</code>区域，可以写成下面这样。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

<span class="hljs-keyword">var</span> imageData = ctx.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, canvas.width, canvas.height);
</code></pre><p><code>getImageData()</code>方法返回的是一个<code>ImageData</code>对象。该对象有三个属性。</p><ul><li>ImageData.data：一个一维数组。该数组的值，依次是每个像素的红、绿、蓝、alpha 通道值（每个值的范围是 0～255），因此该数组的长度等于<code>图像的像素宽度 x 图像的像素高度 x 4</code>。这个数组不仅可读，而且可写，因此通过操作这个数组，就可以达到操作图像的目的。</li><li>ImageData.width：浮点数，表示 ImageData 的像素宽度。</li><li>ImageData.height：浮点数，表示 ImageData 的像素高度。</li></ul><p><strong>（2）putImageData()</strong></p><p><code>CanvasRenderingContext2D.putImageData()</code>方法将<code>ImageData</code>对象的像素绘制在<code>&lt;canvas&gt;</code>画布上。该方法有两种使用格式。</p><pre class="hljs"><code>ctx.putImageData(imagedata, dx, dy)
ctx.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight)
</code></pre><p>该方法有如下参数。</p><ul><li>imagedata：包含像素信息的 ImageData 对象。</li><li>dx：<code>&lt;canvas&gt;</code>元素内部的横坐标，用于放置 ImageData 图像的左上角。</li><li>dy：<code>&lt;canvas&gt;</code>元素内部的纵坐标，用于放置 ImageData 图像的左上角。</li><li>dirtyX：ImageData 图像内部的横坐标，用于作为放置到<code>&lt;canvas&gt;</code>的矩形区域的左上角的横坐标，默认为0。</li><li>dirtyY：ImageData 图像内部的纵坐标，用于作为放置到<code>&lt;canvas&gt;</code>的矩形区域的左上角的纵坐标，默认为0。</li><li>dirtyWidth：放置到<code>&lt;canvas&gt;</code>的矩形区域的宽度，默认为 ImageData 图像的宽度。</li><li>dirtyHeight：放置到<code>&lt;canvas&gt;</code>的矩形区域的高度，默认为 ImageData 图像的高度。</li></ul><p>下面是将 ImageData 对象绘制到<code>&lt;canvas&gt;</code>的例子。</p><pre class="hljs"><code>ctx.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
</code></pre><p><strong>（3）createImageData()</strong></p><p><code>CanvasRenderingContext2D.createImageData()</code>方法用于生成一个空的<code>ImageData</code>对象，所有像素都是透明的黑色（即每个值都是<code>0</code>）。该方法有两种使用格式。</p><pre class="hljs"><code>ctx.createImageData(width, height)
ctx.createImageData(imagedata)
</code></pre><p><code>createImageData()</code>方法的参数如下。</p><ul><li>width：ImageData 对象的宽度，单位为像素。</li><li>height：ImageData 对象的高度，单位为像素。</li><li>imagedata：一个现有的 ImageData 对象，返回值将是这个对象的拷贝。</li></ul><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

<span class="hljs-keyword">var</span> imageData = ctx.createImageData(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>);
</code></pre><p>上面代码中，<code>imageData</code>是一个 100 x 100 的像素区域，其中每个像素都是透明的黑色。</p><h3 id="canvasrenderingcontext2dsave，canvasrenderingcontext2drestore">CanvasRenderingContext2D.save()，CanvasRenderingContext2D.restore() <a class="markdownIt-Anchor" href="#canvasrenderingcontext2dsave，canvasrenderingcontext2drestore">#</a></h3><p><code>CanvasRenderingContext2D.save()</code>方法用于将画布的当前样式保存到堆栈，相当于在内存之中产生一个样式快照。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.save();
</code></pre><p>上面代码中，<code>save()</code>会为画布的默认样式产生一个快照。</p><p><code>CanvasRenderingContext2D.restore()</code>方法将画布的样式恢复到上一个保存的快照，如果没有已保存的快照，则不产生任何效果。</p><p>上下文环境，restore方法用于恢复到上一次保存的上下文环境。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.save();

ctx.fillStyle = <span class="hljs-string">&#x27;green&#x27;</span>;
ctx.restore();

ctx.fillRect(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);
</code></pre><p>上面代码画一个矩形。矩形的填充色本来设为绿色，但是<code>restore()</code>方法撤销了这个设置，将样式恢复上一次保存的状态（即默认样式），所以实际的填充色是黑色（默认颜色）。</p><h3 id="canvasrenderingcontext2dcanvas">CanvasRenderingContext2D.canvas <a class="markdownIt-Anchor" href="#canvasrenderingcontext2dcanvas">#</a></h3><p><code>CanvasRenderingContext2D.canvas</code>属性指向当前<code>CanvasRenderingContext2D</code>对象所在的<code>&lt;canvas&gt;</code>元素。该属性只读。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.canvas === canvas <span class="hljs-comment">// true</span>
</code></pre><h3 id="图像变换">图像变换 <a class="markdownIt-Anchor" href="#图像变换">#</a></h3><p>以下方法用于图像变换。</p><ul><li><code>CanvasRenderingContext2D.rotate()</code>：图像旋转</li><li><code>CanvasRenderingContext2D.scale()</code>：图像缩放</li><li><code>CanvasRenderingContext2D.translate()</code>：图像平移</li><li><code>CanvasRenderingContext2D.transform()</code>：通过一个变换矩阵完成图像变换</li><li><code>CanvasRenderingContext2D.setTransform()</code>：取消前面的图像变换</li></ul><p><strong>（1）rotate()</strong></p><p><code>CanvasRenderingContext2D.rotate()</code>方法用于图像旋转。它接受一个弧度值作为参数，表示顺时针旋转的度数。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.rotate(<span class="hljs-number">45</span> * <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">180</span>);
ctx.fillRect(<span class="hljs-number">70</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">30</span>);
</code></pre><p>上面代码会显示一个顺时针倾斜45度的矩形。注意，<code>rotate()</code>方法必须在<code>fillRect()</code>方法之前调用，否则是不起作用的。</p><p>旋转中心点始终是画布左上角的原点。如果要更改中心点，需要使用<code>translate()</code>方法移动画布。</p><p><strong>（2）scale()</strong></p><p><code>CanvasRenderingContext2D.scale()</code>方法用于缩放图像。它接受两个参数，分别是<code>x</code>轴方向的缩放因子和<code>y</code>轴方向的缩放因子。默认情况下，一个单位就是一个像素，缩放因子可以缩放单位，比如缩放因子<code>0.5</code>表示将大小缩小为原来的50%，缩放因子<code>10</code>表示放大十倍。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.scale(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>);
ctx.fillRect(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);
</code></pre><p>上面代码中，原来的矩形是 10 x 10，缩放后展示出来是 100 x 30。</p><p>如果缩放因子为1，就表示图像没有任何缩放。如果为-1，则表示方向翻转。<code>ctx.scale(-1, 1)</code>为水平翻转，<code>ctx.scale(1, -1)</code>表示垂直翻转。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.scale(<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>);
ctx.font = <span class="hljs-string">&quot;16px serif&quot;</span>;
ctx.fillText(<span class="hljs-string">&#x27;Hello world!&#x27;</span>, <span class="hljs-number">20</span>, -<span class="hljs-number">20</span>);
</code></pre><p>上面代码会显示一个水平倒转的、高度放大2倍的<code>Hello World!</code>。</p><p>注意，负向缩放本质是坐标翻转，所针对的坐标轴就是画布左上角原点的坐标轴。</p><p><strong>（3）translate()</strong></p><p><code>CanvasRenderingContext2D.translate()</code>方法用于平移图像。它接受两个参数，分别是 x 轴和 y 轴移动的距离（单位像素）。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.translate(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
ctx.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);
</code></pre><p><strong>（4）transform()</strong></p><p><code>CanvasRenderingContext2D.transform()</code>方法接受一个变换矩阵的六个元素作为参数，完成缩放、旋转、移动和倾斜等变形。</p><p>它的使用格式如下。</p><pre class="hljs"><code>ctx.transform(a, b, c, d, e, f);
<span class="hljs-comment">/*
a:水平缩放(默认值1，单位倍数)
b:水平倾斜(默认值0，单位弧度)
c:垂直倾斜(默认值0，单位弧度)
d:垂直缩放(默认值1，单位倍数)
e:水平位移(默认值0，单位像素)
f:垂直位移(默认值0，单位像素)
*/</span>
</code></pre><p>下面是一个例子。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.transform(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
ctx.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);
</code></pre><p>上面代码中，原始图形是 100 x 100 的矩形，结果缩放成 200 x 100 的矩形，并且左上角从<code>(0, 0)</code>移动到<code>(50, 50)</code>。</p><p>注意，多个<code>transform()</code>方法具有叠加效果。</p><p><strong>（5）setTransform()</strong></p><p><code>CanvasRenderingContext2D.setTransform()</code>方法取消前面的图形变换，将画布恢复到该方法指定的状态。该方法的参数与<code>transform()</code>方法完全一致。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

ctx.translate(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>);
ctx.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);

ctx.setTransform(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
ctx.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>);
</code></pre><p>上面代码中，第一个<code>fillRect()</code>方法绘制的矩形，左上角从<code>(0, 0)</code>平移到<code>(50, 50)</code>。<code>setTransform()</code>方法取消了这个变换（已绘制的图形不受影响），将画布恢复到默认状态（变换矩形<code>1, 0, 0, 1, 0, 0</code>），所以第二个矩形的左上角回到<code>(0, 0)</code>。</p><h2 id="canvas-元素的方法"><code>&lt;canvas&gt;</code> 元素的方法 <a class="markdownIt-Anchor" href="#canvas-元素的方法">#</a></h2><p>除了<code>CanvasRenderingContext2D</code>对象提供的方法，<code>&lt;canvas&gt;</code>元素本身也有自己的方法。</p><h3 id="htmlcanvaselementtodataurl">HTMLCanvasElement.toDataURL() <a class="markdownIt-Anchor" href="#htmlcanvaselementtodataurl">#</a></h3><p><code>&lt;canvas&gt;</code>元素的<code>toDataURL()</code>方法，可以将 Canvas 数据转为 Data URI 格式的图像。</p><pre class="hljs"><code>canvas.toDataURL(type, quality)
</code></pre><p><code>toDataURL()</code>方法接受两个参数。</p><ul><li>type：字符串，表示图像的格式。默认为<code>image/png</code>，另一个可用的值是<code>image/jpeg</code>，Chrome 浏览器还可以使用<code>image/webp</code>。</li><li>quality：浮点数，0到1之间，表示 JPEG 和 WebP 图像的质量系数，默认值为0.92。</li></ul><p>该方法的返回值是一个 Data URI 格式的字符串。</p><pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convertCanvasToImage</span>(<span class="hljs-params">canvas</span>) </span>{
  <span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> Image();
  image.src = canvas.toDataURL(<span class="hljs-string">&#x27;image/png&#x27;</span>);
  <span class="hljs-keyword">return</span> image;
}
</code></pre><p>上面的代码将<code>&lt;canvas&gt;</code>元素，转化成PNG Data URI。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> fullQuality = canvas.toDataURL(<span class="hljs-string">&#x27;image/jpeg&#x27;</span>, <span class="hljs-number">0.9</span>);
<span class="hljs-keyword">var</span> mediumQuality = canvas.toDataURL(<span class="hljs-string">&#x27;image/jpeg&#x27;</span>, <span class="hljs-number">0.6</span>);
<span class="hljs-keyword">var</span> lowQuality = canvas.toDataURL(<span class="hljs-string">&#x27;image/jpeg&#x27;</span>, <span class="hljs-number">0.3</span>);
</code></pre><p>上面代码将<code>&lt;canvas&gt;</code>元素转成高画质、中画质、低画质三种 JPEG 图像。</p><h3 id="htmlcanvaselementtoblob">HTMLCanvasElement.toBlob() <a class="markdownIt-Anchor" href="#htmlcanvaselementtoblob">#</a></h3><p><code>HTMLCanvasElement.toBlob()</code>方法用于将<code>&lt;canvas&gt;</code>图像转成一个 Blob 对象，默认类型是<code>image/png</code>。它的使用格式如下。</p><pre class="hljs"><code><span class="hljs-comment">// 格式</span>
canvas.toBlob(callback, mimeType, quality)

<span class="hljs-comment">// 示例</span>
canvas.toBlob(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blob</span>) </span>{...}, <span class="hljs-string">&#x27;image/jpeg&#x27;</span>, <span class="hljs-number">0.95</span>)
</code></pre><p><code>toBlob()</code>方法可以接受三个参数。</p><ul><li>callback：回调函数。它接受生成的 Blob 对象作为参数。</li><li>mimeType：字符串，图像的 MIMEType 类型，默认是<code>image/png</code>。</li><li>quality：浮点数，0到1之间，表示图像的质量，只对<code>image/jpeg</code>和<code>image/webp</code>类型的图像有效。</li></ul><p>注意，该方法没有返回值。</p><p>下面的例子将<code>&lt;canvas&gt;</code>图像复制成<code>&lt;img&gt;</code>图像。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">blobToImg</span>(<span class="hljs-params">blob</span>) </span>{
  <span class="hljs-keyword">var</span> newImg = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;img&#x27;</span>);
  <span class="hljs-keyword">var</span> url = URL.createObjectURL(blob);

  newImg.onload = functio () {
    <span class="hljs-comment">// 使用完毕，释放 URL 对象</span>
    URL.revokeObjectURL(url);
  };

  newImg.src = url;
  <span class="hljs-built_in">document</span>.body.appendChild(newImg);
}

canvas.toBlob(blobToImg);
</code></pre><h2 id="canvas-使用实例">Canvas 使用实例 <a class="markdownIt-Anchor" href="#canvas-使用实例">#</a></h2><h3 id="动画效果">动画效果 <a class="markdownIt-Anchor" href="#动画效果">#</a></h3><p>通过改变坐标，很容易在画布 Canvas 元素上产生动画效果。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> canvas = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);
<span class="hljs-keyword">var</span> ctx = canvas.getContext(<span class="hljs-string">&#x27;2d&#x27;</span>);

<span class="hljs-keyword">var</span> posX = <span class="hljs-number">20</span>;
<span class="hljs-keyword">var</span> posY = <span class="hljs-number">100</span>;

<span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  ctx.fillStyle = <span class="hljs-string">&#x27;black&#x27;</span>;
  ctx.fillRect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, canvas.width, canvas.height);

  posX += <span class="hljs-number">1</span>;
  posY += <span class="hljs-number">0.25</span>;

  ctx.beginPath();
  ctx.fillStyle = <span class="hljs-string">&#x27;white&#x27;</span>;

  ctx.arc(posX, posY, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.PI * <span class="hljs-number">2</span>, <span class="hljs-literal">true</span>);
  ctx.closePath();
  ctx.fill();
}, <span class="hljs-number">30</span>);
</code></pre><p>上面代码会产生一个小圆点，每隔30毫秒就向右下方移动的效果。<code>setInterval()</code>函数的一开始，之所以要将画布重新渲染黑色底色，是为了抹去上一步的小圆点。</p><p>在这个例子的基础上，通过设置圆心坐标，可以产生各种运动轨迹。下面是先上升后下降的例子。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> vx = <span class="hljs-number">10</span>;
<span class="hljs-keyword">var</span> vy = -<span class="hljs-number">10</span>;
<span class="hljs-keyword">var</span> gravity = <span class="hljs-number">1</span>;

<span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  posX += vx;
  posY += vy;
  vy += gravity;
  <span class="hljs-comment">// ...</span>
});
</code></pre><p>上面代码中，<code>x</code>坐标始终增大，表示持续向右运动。<code>y</code>坐标先变小，然后在重力作用下，不断增大，表示先上升后下降。</p><h3 id="像素处理">像素处理 <a class="markdownIt-Anchor" href="#像素处理">#</a></h3><p>通过<code>getImageData()</code>方法和<code>putImageData()</code>方法，可以处理每个像素，进而操作图像内容，因此可以改写图像。</p><p>下面是图像处理的通用写法。</p><pre class="hljs"><code><span class="hljs-keyword">if</span> (canvas.width &gt; <span class="hljs-number">0</span> &amp;&amp; canvas.height &gt; <span class="hljs-number">0</span>) {
  <span class="hljs-keyword">var</span> imageData = context.getImageData(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, canvas.width, canvas.height);
  filter(imageData);
  context.putImageData(imageData, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
}
</code></pre><p>上面代码中，<code>filter</code>是一个处理像素的函数。以下是几种常见的<code>filter</code>。</p><p><strong>（1）灰度效果</strong></p><p>灰度图（grayscale）就是取红、绿、蓝三个像素值的算术平均值，这实际上将图像转成了黑白形式。</p><pre class="hljs"><code>grayscale = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pixels</span>) </span>{
  <span class="hljs-keyword">var</span> d = pixels.data;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; d.length; i += <span class="hljs-number">4</span>) {
    <span class="hljs-keyword">var</span> r = d[i];
    <span class="hljs-keyword">var</span> g = d[i + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">var</span> b = d[i + <span class="hljs-number">2</span>];
    d[i] = d[i + <span class="hljs-number">1</span>] = d[i + <span class="hljs-number">2</span>] = (r + g + b) / <span class="hljs-number">3</span>;
  }
  <span class="hljs-keyword">return</span> pixels;
};
</code></pre><p>上面代码中，<code>d[i]</code>是红色值，<code>d[i+1]</code>是绿色值，<code>d[i+2]</code>是蓝色值，<code>d[i+3]</code>是 alpha 通道值。转成灰度的算法，就是将红、绿、蓝三个值相加后除以3，再将结果写回数组。</p><p><strong>（2）复古效果</strong></p><p>复古效果（sepia）是将红、绿、蓝三种值，分别取这三个值的某种加权平均值，使得图像有一种古旧的效果。</p><pre class="hljs"><code>sepia = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pixels</span>) </span>{
    <span class="hljs-keyword">var</span> d = pixels.data;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; d.length; i += <span class="hljs-number">4</span>) {
      <span class="hljs-keyword">var</span> r = d[i];
      <span class="hljs-keyword">var</span> g = d[i + <span class="hljs-number">1</span>];
      <span class="hljs-keyword">var</span> b = d[i + <span class="hljs-number">2</span>];
      d[i]     = (r * <span class="hljs-number">0.393</span>) + (g * <span class="hljs-number">0.769</span>) + (b * <span class="hljs-number">0.189</span>); <span class="hljs-comment">// red</span>
      d[i + <span class="hljs-number">1</span>] = (r * <span class="hljs-number">0.349</span>) + (g * <span class="hljs-number">0.686</span>) + (b * <span class="hljs-number">0.168</span>); <span class="hljs-comment">// green</span>
      d[i + <span class="hljs-number">2</span>] = (r * <span class="hljs-number">0.272</span>) + (g * <span class="hljs-number">0.534</span>) + (b * <span class="hljs-number">0.131</span>); <span class="hljs-comment">// blue</span>
    }
    <span class="hljs-keyword">return</span> pixels;
};
</code></pre><p><strong>（3）红色蒙版效果</strong></p><p>红色蒙版指的是，让图像呈现一种偏红的效果。算法是将红色通道设为红、绿、蓝三个值的平均值，而将绿色通道和蓝色通道都设为0。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> red = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pixels</span>) </span>{
  <span class="hljs-keyword">var</span> d = pixels.data;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; d.length; i += <span class="hljs-number">4</span>) {
    <span class="hljs-keyword">var</span> r = d[i];
    <span class="hljs-keyword">var</span> g = d[i + <span class="hljs-number">1</span>];
    <span class="hljs-keyword">var</span> b = d[i + <span class="hljs-number">2</span>];
    d[i] = (r + g + b)/<span class="hljs-number">3</span>;        <span class="hljs-comment">// 红色通道取平均值</span>
    d[i + <span class="hljs-number">1</span>] = d[i + <span class="hljs-number">2</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 绿色通道和蓝色通道都设为0</span>
  }
  <span class="hljs-keyword">return</span> pixels;
};
</code></pre><p><strong>（4）亮度效果</strong></p><p>亮度效果（brightness）是指让图像变得更亮或更暗。算法将红色通道、绿色通道、蓝色通道，同时加上一个正值或负值。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> brightness = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pixels, delta</span>) </span>{
  <span class="hljs-keyword">var</span> d = pixels.data;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; d.length; i += <span class="hljs-number">4</span>) {
    d[i] += delta;     <span class="hljs-comment">// red</span>
    d[i + <span class="hljs-number">1</span>] += delta; <span class="hljs-comment">// green</span>
    d[i + <span class="hljs-number">2</span>] += delta; <span class="hljs-comment">// blue</span>
  }
  <span class="hljs-keyword">return</span> pixels;
};
</code></pre><p><strong>（5）反转效果</strong></p><p>反转效果（invert）是指图片呈现一种色彩颠倒的效果。算法为红、绿、蓝通道都取各自的相反值（<code>255 - 原值</code>）。</p><pre class="hljs"><code>invert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pixels</span>) </span>{
  <span class="hljs-keyword">var</span> d = pixels.data;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; d.length; i += <span class="hljs-number">4</span>) {
    d[i] = <span class="hljs-number">255</span> - d[i];
    d[i + <span class="hljs-number">1</span>] = <span class="hljs-number">255</span> - d[i + <span class="hljs-number">1</span>];
    d[i + <span class="hljs-number">2</span>] = <span class="hljs-number">255</span> - d[i + <span class="hljs-number">2</span>];
  }
  <span class="hljs-keyword">return</span> pixels;
};
</code></pre><h2 id="参考链接">参考链接 <a class="markdownIt-Anchor" href="#参考链接">#</a></h2><ul><li>David Walsh, <a href="https://davidwalsh.name/convert-canvas-image" target="_blank" rel="noopener">JavaScript Canvas Image Conversion</a></li><li>Matt West, <a href="http://blog.teamtreehouse.com/getting-started-with-the-canvas-api" target="_blank" rel="noopener">Getting Started With The Canvas API</a></li><li>John Robinson, <a href="http://www.storminthecastle.com/2013/04/06/how-you-can-do-cool-image-effects-using-html5-canvas/" target="_blank" rel="noopener">How You Can Do Cool Image Effects Using HTML5 Canvas</a></li><li>Ivaylo Gerchev, <a href="http://www.sitepoint.com/html5-canvas-tutorial-introduction/" target="_blank" rel="noopener">HTML5 Canvas Tutorial: An Introduction</a></li><li>Donovan Hutchinson, <a href="http://hop.ie/blog/particles/" target="_blank" rel="noopener">Particles in canvas</a></li></ul></article><nav class="level level-previous-next is-size-5 is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="index.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> Home</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="clipboard.html">Clipboard API <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info is-size-5-widescreen"><p>本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>。</p><p>分享本文 <span class="social-share"></span></p></div></div><div class="column is-3 is-offset-1"><nav class="panel panel-menu"><p class="panel-heading"><i class="fa fa-book" aria-hidden="true"></i> Web API 教程</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="canvas.html" class="is-active"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Canvas API</span></a></li><li><a href="clipboard.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Clipboard API</span></a></li><li><a href="fetch.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Fetch API</span></a></li><li><a href="fontface.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">FontFace API</span></a></li><li><a href="geolocation.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Geolocation API</span></a></li><li><a href="intersectionObserver.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">IntersectionObserver</span></a></li><li><a href="intl-relativetimeformat.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Intl.RelativeTimeFormat</span></a></li><li><a href="page-lifecycle.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Page Lifecycle API</span></a></li><li><a href="page-visibility.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Page Visibility API</span></a></li><li><a href="server-sent-events.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Server-Sent Events</span></a></li><li><a href="svg.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">SVG 图像</span></a></li><li><a href="websocket.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">WebSocket</span></a></li><li><a href="web-share-api.html"><span class="icon"></span> <i class="fa fa-file-text-o" aria-hidden="true" style="width: 14px;"></i> &nbsp; <span class="menu-list-title">Web Share API</span></a></li></ul></aside></div></nav><nav class="panel panel-info"><p class="panel-heading"><i class="fa fa-link" aria-hidden="true"></i> 链接</p><div class="panel-block"><aside class="menu"><p class="menu-label"></p><ul class="menu-list"><li><a href="https://raw.githubusercontent.com/wangdoc/webapi-tutorial/master/docs/canvas.md" target="_blank"><span class="icon"></span><i class="fa fa-code" aria-hidden="true" style="width: 14px;"></i>&nbsp;本文源码</a></li><li><a href="https://github.com/wangdoc/webapi-tutorial" target="_blank"><span class="icon"></span><i class="fa fa-hdd-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;代码仓库</a></li><li><a href="https://github.com/wangdoc/webapi-tutorial/issues" target="_blank"><span class="icon"></span><i class="fa fa-flag-o" aria-hidden="true" style="width: 14px;"></i>&nbsp;反馈</a></li></ul></aside></div></nav></div></div><div class="columns"><div class="column is-8"><div id="disqus_thread"></div></div></div></div></section><footer class="footer is-size-5-widescreen"><div class="container"><div class="content has-text-centered"><p>联系：<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="781b17160c191b0c380f19161f1c171b561b1715">[email&#160;protected]</a></p></div></div></footer><script data-cfasync="false" src="/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script><script>var LOPPO={current_path:"canvas.md",relative_root_path:"",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>\n<li><a href="#canvas-api%EF%BC%9A%E7%BB%98%E5%88%B6%E5%9B%BE%E5%BD%A2">Canvas API：绘制图形</a>\n<ul>\n<li><a href="#%E8%B7%AF%E5%BE%84">路径</a></li>\n<li><a href="#%E7%BA%BF%E5%9E%8B">线型</a></li>\n<li><a href="#%E7%9F%A9%E5%BD%A2">矩形</a></li>\n<li><a href="#%E5%BC%A7%E7%BA%BF">弧线</a></li>\n<li><a href="#%E6%96%87%E6%9C%AC">文本</a></li>\n<li><a href="#%E6%B8%90%E5%8F%98%E8%89%B2%E5%92%8C%E5%9B%BE%E5%83%8F%E5%A1%AB%E5%85%85">渐变色和图像填充</a></li>\n<li><a href="#%E9%98%B4%E5%BD%B1">阴影</a></li>\n</ul>\n</li>\n<li><a href="#canvas-api%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86">Canvas API：图像处理</a>\n<ul>\n<li><a href="#canvasrenderingcontext2ddrawimage">CanvasRenderingContext2D.drawImage()</a></li>\n<li><a href="#%E5%83%8F%E7%B4%A0%E8%AF%BB%E5%86%99">像素读写</a></li>\n<li><a href="#canvasrenderingcontext2dsave%EF%BC%8Ccanvasrenderingcontext2drestore">CanvasRenderingContext2D.save()，CanvasRenderingContext2D.restore()</a></li>\n<li><a href="#canvasrenderingcontext2dcanvas">CanvasRenderingContext2D.canvas</a></li>\n<li><a href="#%E5%9B%BE%E5%83%8F%E5%8F%98%E6%8D%A2">图像变换</a></li>\n</ul>\n</li>\n<li><a href="#canvas-%E5%85%83%E7%B4%A0%E7%9A%84%E6%96%B9%E6%B3%95"><code>&lt;canvas&gt;</code> 元素的方法</a>\n<ul>\n<li><a href="#htmlcanvaselementtodataurl">HTMLCanvasElement.toDataURL()</a></li>\n<li><a href="#htmlcanvaselementtoblob">HTMLCanvasElement.toBlob()</a></li>\n</ul>\n</li>\n<li><a href="#canvas-%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B">Canvas 使用实例</a>\n<ul>\n<li><a href="#%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C">动画效果</a></li>\n<li><a href="#%E5%83%8F%E7%B4%A0%E5%A4%84%E7%90%86">像素处理</a></li>\n</ul>\n</li>\n<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>\n</ul>\n'}</script><script src="assets/js/app.js"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=UA-111269443-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-111269443-1")</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?5eec262881855af3dede6a71234571f6";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script>var disqus_config=function(){var t=window.location,e=t.protocol+"//"+t.host+(t.port?":"+t.port:"")+t.pathname;this.page.url=e,this.page.identifier=t.pathname};!function(){var t=document,e=t.createElement("script");e.src="https://wangdoc-webapi.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><!--script src="assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《Canvas API》，出自网道（WangDoc.com）的《Web API 教程》。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"WangDoc_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script></body></html>