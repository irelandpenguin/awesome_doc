<HEAD><TITLE>鸟哥的 Linux 私房菜 -- 档案与目录管理</TITLE>
<META http-equiv=Content-Type content="text/html; charset=gb2312">
<META content=VBird name=Author>
<META content="Mozilla/4.5 [zh-TW] (WinNT; I) [Netscape]" name=GENERATOR><!-- saved from url=(0022)http://internet.e-mail -->
<STYLE>
   <!--
   body{background-image=url("17_files/VBirdLinux[1].jpg");background-ATTACHMENT=FIXED}
   -->
</STYLE>
</head>
<BODY style="CURSOR: auto" background="17_files/VBirdLinux[1].jpg" nosave>
<CENTER>
<CENTER><B><FONT color=#3333ff size=+2><FONT face=SimSun>鸟哥的</FONT><FONT face="Times New Roman,Times"> Linux </FONT><FONT face=SimSun>与</FONT><FONT face="Times New Roman,Times"> ADSL </FONT><FONT face=SimSun>私房菜</FONT></FONT></B> <BR><A href="http://linux.vbird.org/" target=_top><IMG height=25 src="61_files/VBirdTitle2[10].jpg" width=90 border=0 NOSAVE></A> <A href="http://linux.vbird.org/linux_basic"><IMG height=25 src="39_files/icon_system[3].gif" width=90 border=0 NOSAVE></A> <A href="http://linux.vbird.org/linux_server"><IMG height=25 src="55_files/icon_server[13].gif" width=90 border=0 NOSAVE></A> <A href="http://linux.vbird.org/linux_security"><IMG height=25 src="71_files/icon_security[10].jpg" width=90 border=0 NOSAVE></A> <A href="http://phorum.vbird.org/" target=_blank><IMG height=25 src="60_files/icon_forums[10].gif" width=90 border=0 NOSAVE></A> <A href="http://linux.vbird.org/adsl"><IMG height=25 src="50_files/icon_adsl[13].gif" width=90 border=0 NOSAVE></A> <BR>
<HR width="100%">
</CENTER><FONT color=#3333ff size=+2><A href="http://linux-vbird.3322.org/linux_base/0220filemanager.php" target=_self><FONT face="Times New Roman,Times">Linux </FONT><FONT face=SimSun>档案与目录管理</FONT></A></FONT></CENTER>
<DIV align=right><FONT face=SimSun color=#3333ff size=-1>最近更新日期：2003/02/06</FONT></DIV><FONT color=#000099 size=+1><A href="#directory">目录与路径</A></FONT>： <A href="#abslut_relate">相对路径与绝对路径</A>, <A href="#cd">cd</A>, <A href="#pwd">pwd</A>, <A href="#mkdir">mkdir</A>, <A href="#rmdir">rmdir</A>, <A href="#env_PATH">环境变量PATH</A>, <BR><FONT color=#000099 size=+1><A href="#file_directory_manag">档案与目录管理</A></FONT>： <A href="#ls">ls</A>, <A href="#cp">cp</A>, <A href="#rm">rm</A>, <A href="#mv">mv</A>, <A href="#basename">basename</A>, <A href="#dirname">dirname</A>, <BR><FONT size=+1><A href="#lookfile">观看档案内容</A></FONT>： <A href="#cat">cat</A>, <A href="#tac">tac</A>, <A href="#more">more</A>, <A href="#less">less</A>, <A href="#head">head</A>, <A href="#tail">tail</A>, <A href="#nl">nl</A>, <A href="#od">od</A>, <BR><FONT size=+1><A href="#linkfiles">连结档的介绍</A></FONT>： <A href="#inodes">什么是 inode</A> , <A href="#ln">ln</A>, <BR><FONT color=#000099 size=+1><A href="#file_dir_own">档案与目录权限</A></FONT>： <A href="#chown">chown</A>, <A href="#chmod">chmod</A>, <A href="#umask">umask</A>, <A href="#chattr">chattr</A>, <A href="#lsattr">lsattr</A>, <BR><FONT color=#000099 size=+1><A href="#Search">搜寻档案或目录</A></FONT>： <A href="#which">which</A>, <A href="#whereis">whereis</A>, <A href="#locate">locate</A>, <A href="#find">find</A>, <BR><FONT color=#000099><FONT size=+1><A href="#suid_sgid_sticky">SetUID, SetGID, Sticky bit 与 file 指令</A></FONT>：</FONT> <BR><FONT color=#000099 size=+1><A href="#FAQ">本章习题练习</A></FONT> <BR>
<HR width="100%">
<A name=directory></A><FONT color=#000099 size=+1>目录与路径：</FONT> 
<BLOCKQUOTE>由前一章节『<A href="http://linux-vbird.3322.org/linux_base/0170filepermission.php">Linux 的档案权限与目录配置</A>』中约略了解到 Linux 的『树状目录』概念之后，接下来就得要实际的来搞定一些基本的路径问题了！这些问题当中，最重要的莫过于『绝对路径』与『相对路径』的意义啦！赶紧来了解一下！ 
<UL>
<HR width="100%">

<LI><A name=abslut_relate></A><B><FONT color=#000099>绝对路径与相对路径：</FONT></B> <BR>在开始目录的切换之前，你必须要先了解一下所谓的『<B><FONT color=#000066>路径, PATH</FONT></B>』，有趣的是：什么是『<B><FONT color=#000066>相对路径</FONT></B>』与『<B><FONT color=#000066>绝对路径</FONT></B>』？如果你还记得前一章的内容的话，那么应该还记得 Linux 里面的目录是呈现『<B><FONT color=#000066>树状目录</FONT></B>』的情况，有就是有分支的啦！好了，假设你需要在任意一个目录下变换到根目录的 etc 底下，那么你就应该要使用『 <FONT face=SimSun color=#000066>cd /etc</FONT> 』这个情况，这也就是所谓的『<FONT color=#000066>绝对路径</FONT>』，他是从根目录连续写上来的一个情况，所以不论你在哪一个路径现执行这一个指令，都会将你移动到该路径下。那如果我是使用『<FONT face=SimSun color=#000066> cd etc </FONT>』呢？那表示你要切换到『<FONT color=#000066>目前这个目录下的 etc 目录中</FONT>』，情况可是不一样的呦！通常第一次接触 Linux 的使用者常会搞错这一个路径的观念！ <BR>　 
<UL>
<LI><B><FONT color=#000066>绝对路径</FONT></B>：路径的写法『<FONT color=#000066>一定由根目录 / 写起</FONT>』，例如： /usr/share/doc 这个目录。 
<LI><B><FONT color=#000066>相对路径</FONT></B>：路径的写法『<FONT color=#000066>不是由 / 写起</FONT>』，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：『<FONT face=SimSun>cd ../man</FONT>』这就是相对路径的写法啦！ </LI></UL><FONT face=SimSun>　</FONT> <BR><FONT face=SimSun>那么相对路径与绝对路径有什么了不起呀！？喝！那可真的是了不起了！假设您写了一个套件，这个套件共需要三个目录，分别是 etc, bin, man 这三个目录，然而由于不同的人喜欢安装在不同的目录之下，假设甲安装的目录是 /usr/local/packages/etc, /usr/local/packages/bin 及 /usr/local/packages/man ，不过乙却喜欢安装在 /home/packages/etc, /home/packages/bin, /home/packages/man 这三个目录中，请问如果需要用到绝对路径的话，那么是否很麻烦呢？是的！如此一来每个目录下的东西就很难对应的起来！这个时候相对路径的写法就显的特别的重要了！</FONT> <BR><FONT face=SimSun>　</FONT> <BR><FONT face=SimSun>此外，如果您跟我一样，喜欢将路径的名字写的很长，好让自己知道那个目录是在干什么的，例如：/data4/staiwan19961109/models-3/smoke 这个目录，而另一个目录在 /data4/staiwan19961109/models-3/cctm ，那么我从第一个要到第二个目录去的话，怎么写比较方便？当然是『 cd ../cctm 』比较方便！对吧！</FONT> <BR><FONT face=SimSun>　</FONT> <BR><FONT face=SimSun>好了，既然要谈到目录这个东西，自然就需要了解一下有哪些常用的目录『符号』代表的意义啦！</FONT> <BR><FONT face=SimSun>　</FONT> 
<TABLE cols=1 width=400 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun color=#ffff00 size=-1>.&nbsp;&nbsp;&nbsp;&nbsp; 代表此层目录</FONT> <BR><FONT face=SimSun color=#ffff00 size=-1>..&nbsp;&nbsp;&nbsp; 代表上层目录</FONT> <BR><FONT face=SimSun color=#ffff00 size=-1>~&nbsp;&nbsp;&nbsp;&nbsp; 代表自己的家目录</FONT> <BR><FONT face=SimSun color=#ffff00 size=-1>~user 代表到 user 这个人的家目录</FONT></TD></TR></TBODY></TABLE><FONT face=SimSun>　</FONT> <BR><FONT face=SimSun>底下我们要来谈一谈目录与路径的几个常用的指令：</FONT></LI></UL>
<UL>
<UL>
<LI><FONT face=SimSun><B>cd</B>&nbsp;&nbsp;&nbsp;&nbsp; 变换目录</FONT> 
<LI><FONT face=SimSun><B>pwd</B>&nbsp;&nbsp;&nbsp; 显示目前的目录</FONT> 
<LI><FONT face=SimSun><B>mkdir</B> 建立一个新目录</FONT> 
<LI><FONT face=SimSun><B>rmdir</B> 删除一个里面是空的空目录</FONT> </LI></UL><FONT face=SimSun>　</FONT> <BR>
<HR width="100%">

<LI><B><FONT color=#000099>cd 与 pwd</FONT></B> <BR>这两个指令主要是在『变换目前目录』与『显示目前所在目录』的工作，底下说一说他们的用途与语法吧！ <BR>　 
<LI><A name=cd></A><B><FONT face=SimSun color=#000099>cd</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>cd [相对路径或绝对路径]&nbsp;</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>路径有『相对路径』与『绝对路径』的分别，请千万小心！</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]#</FONT><FONT color=#ffff00> cd ..　</FONT><FONT color=#ffffff>　　　</FONT><FONT color=#ffff00>　　　</FONT><FONT color=#ff9900>&lt;==回到上一层目录</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]#</FONT><FONT color=#ffff00> cd ../home　　</FONT><FONT color=#ffffff>　</FONT><FONT color=#ffff00>　</FONT><FONT color=#ff9900> &lt;==相对路径的写法</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>cd /var/www/html</FONT><FONT color=#ffffff>　 </FONT><FONT color=#ff9900>&lt;==绝对路径的写法</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /etc]# </FONT><FONT color=#ffff00>cd　</FONT><FONT color=#ffffff>　　　　　　</FONT><FONT color=#ffff00>　　</FONT><FONT color=#ff9900>&lt;==回到使用者的家目录</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /etc]#</FONT><FONT color=#ffff00> cd ~ </FONT><FONT color=#ffffff>　　　　　　　</FONT><FONT color=#ff9900> &lt;==回到使用者的家目录！</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /etc]# </FONT><FONT color=#ffff00>cd ~test　</FONT><FONT color=#ffffff>　　　　　</FONT><FONT color=#ff9900>&lt;==回到 test 这个使用者的家目录</FONT></FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>cd 是 change directory 的缩写，这是用来变换工作路径的指令。注意，路径与 cd 指令之间存在一个空格！一登入 Linux 系统后，root 会在 root 的家目录，亦即 /root 下，至于使用者会在预设的 /home/username 底下，例如鸟哥的 ID 为 vbird ，则以 vbird 的身份登入后，会到 /home/vbird 这个路径下。OK！那回到上一层可以用『 cd .. 』而到相对路径可到『 cd ../bird』，至于绝对路径则是 cd /usr/sbin ！注意喔，在前面的提示字符会改变路径名称！此外，<FONT color=#000066>家目录还有一个代码，那就是『 ~ 』符号</FONT>！例如上面的例子可以发现，使用『 cd ~ 』可以回到个人的家目录里头去呢！此外，如果你的 Linux 主机当中有个 testing 的账号，你要到他的家目录去，可以下达『 <FONT face=SimSun color=#000066>cd ~testing</FONT>』立刻去到 testing 的家目录！ <BR>　 <BR>
<HR width="100%">

<LI><A name=pwd></A><B><FONT face=SimSun color=#000099>pwd</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>pwd&nbsp;</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test root]# </FONT><FONT color=#ffff00>cd /home/test</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test test]# </FONT><FONT color=#ffff00>pwd&nbsp;</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>/home/test&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </FONT><FONT color=#ff9900>&lt;==显示目前你所在的目录呦！</FONT></FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>pwd 是 print working directory 的缩写，也就是显示目前所在目录的指令，例如在上个表格最后的目录是 /home/test 这个目录，但是提示字符仅显示 test ，如果你想要知道目前所在的目录，可以输入 pwd 即可： <BR>　 <BR>此外，由于很多的套件所使用的目录名称都相同，例如 /usr/local/etc 还有 /etc ，但是通常 Linux 仅列出最后面那一个目录而已，这个时候你就可以使用 pwd 来知道你的所在目录！免得搞错目录，结果…… <BR>　 <BR>
<HR width="100%">

<LI><B><FONT color=#000099>mkdir 与 rmdir 管理目录：</FONT></B> <BR>那么要如何建立删除目录呢？很简单呀！就用 mkdir 与 rmdir ，看出来了吗？没错啦！就是 make/remove directory 的缩写说！看要怎么用吧！ <BR>　 
<LI><A name=mkdir></A><B><FONT face=SimSun color=#000099>mkdir</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=600 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]#</FONT><FONT color=#ffff00> mkdir [-mp] [目录名称]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-m ：设定档案的权限喔！直接设定，不需要看 umask 这个内容的脸色！</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-p ：帮助你直接将上面的目录递归建立起来！</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>cd tmp</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /tmp]# </FONT><FONT color=#ffff00>mkdir test</FONT><FONT color=#ff9900>&lt;==建立名称为 test 的目录</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /tmp]# </FONT><FONT color=#ffff00>mkdir -p test1/test2/test3/test4</FONT><FONT color=#ff9900> &lt;==直接建立 test2...等上层目录</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /tmp]# </FONT><FONT color=#ffff00>mkdir -m 711 testqq&nbsp; </FONT><FONT color=#ff9900>&lt;==建立权限为 711 的目录！</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /tmp]# </FONT><FONT color=#ffff00>ll test*</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>drwxrwxr-x&nbsp;&nbsp;&nbsp; 2 test&nbsp;&nbsp;&nbsp; test&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096 Feb&nbsp; 6 20:47 test/</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>drwxrwxr-x&nbsp;&nbsp;&nbsp; 3 test&nbsp;&nbsp;&nbsp; test&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096 Feb&nbsp; 6 20:48 test1/</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>drwx--x--x&nbsp;&nbsp;&nbsp; 2 test&nbsp;&nbsp;&nbsp; test&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096 Feb&nbsp; 6 20:48 testqq/</FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>如果想要建立新的目录的话，那么就使用 mkdir 吧！ 不过，请注意呦！在预设的情况下，你所需要的目录得一层一层的建立才行！例如：假如你要建立一个目录为 /home/bird/testing/test1，那么首先必须要有 /home 然后 /home/bird ，再来 /home/bird/testing 都必须要存在，才可以建立 test1 这个目录！假如没有 /home/bird/testing 时，就没有办法建立 test1 的目录！不过，现在有个更简单有效的方法啦！那就是加上 -p 这个参数喔！你可以直接下达：『 <FONT face=SimSun color=#000066>mkdir -p /home/bird/testing</FONT>』则系统会自动的帮你将 /home, /home/bird, /home/bird/testing 依序的建立起目录！并且，如果该目录本来就已经存在时，系统也不会显示错误讯息喔！挺快乐的吧！ ^_^ <BR>　 <BR>
<HR width="100%">

<LI><A name=rmdir></A><B><FONT face=SimSun color=#000099>rmdir</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>rmdir [-p] [目录名称]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-p ：将上层的目录也删除吧！</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>rmdir test</FONT><FONT color=#ff9900>&lt;==删除名称为 test 的目录</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test tmp]# </FONT><FONT color=#ffff00>ll</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>drwxrwxr-x&nbsp;&nbsp;&nbsp; 3 test&nbsp;&nbsp;&nbsp; test&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096 Feb&nbsp; 6 20:48 test1/</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test tmp]# </FONT><FONT color=#ffff00>rmdir test1</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>rmdir: `test1': Directory not empty</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test tmp]# </FONT><FONT color=#ffff00>rmdir -p test1/test2/test3/test4</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test tmp]$</FONT><FONT color=#ffff00> ll</FONT></FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>如果想要建立删除旧有的目录时，就使用 rmdir 吧！例如将刚刚建立的 test 杀掉，使用 rmdir test 即可！请注意呦！目录需要一层一层的删除才行！<B>而且被删除的目录里面必定不能还有其它的目录或档案</B>！那如果要将所有目录下的东西都杀掉呢？！这个时候就必须使用 rm -rf test ！不过，<B>还是使用 rmdir 比较不危险</B>！不过，你也可以尝试以 -p 的参数加入，来删除上层的目录喔！ <BR>　 <BR>
<HR width="100%">

<LI><A name=env_PATH></A><B><FONT color=#000099>环境变量 PATH</FONT></B> <BR>在提过了绝对路径、相对路径与指令的下达方式之后，您应该会稍微注意到一件事情，那就是：『<B><FONT color=#000066>为什么我可以在 /root 底下执行 /bin/ls 这个档案呢？</FONT></B>』对呀！为什么我可以直接执行 ls 就一定可以显示出一些讯息而不会说找不到该档案呢？这是因为环境变量 PATH 的帮助所致呀！<B><FONT color=#000066>当我们在执行一个指令的时候，系统会依照 PATH 的设定去每个 PATH 定义的路径下搜寻档案，先搜寻到的指令档案先被执行之</FONT></B>！现在，请下达 echo $PATH ， echo 有『显示、印出』的意思，而 PATH 前面加的 $ 表示后面接的是变量，所以即会显示出目前的 PATH 了！ <BR>　 
<TABLE cols=1 width=600 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root@test root]# </FONT><FONT color=#ffff00>echo $PATH</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>/sbin:/usr/sbin:/bin:/usr/bin:/usr/X11R6/bin:/usr/local/bin:/usr/local/sbin</FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>　</FONT> <BR>注意到了吗？对啦！ /bin 在 PATH 的设定之中，所以自然就可以找的到 ls 啦！ <BR>&nbsp; 
<UL>
<LI>如果你将 ls 移动到 /root 底下的话，然后你自己本身也在 /root 底下，但是当你执行 ls 的时候，他就是不理你？怎么办？这是因为 PATH 没有 /root 这个目录，而你又将 ls 移动到 /root 底下了，自然系统就找不到可执行文件了，因此就会告诉你， command not found ！那么该怎么克服这种问题呢？有两个方法，其一：直接将 /root 的路径加入 PATH 当中！如何增加？可以使用： <BR>　 
<UL><FONT face=SimSun color=#000066>PATH=”$PATH”:/root</FONT></UL>　 <BR>这种方式来增加即可！另一种方式则是使用完整档名，亦即直接使用相对或绝对路径来执行，例如： <BR>　 
<UL><FONT face=SimSun color=#000066>&nbsp; /root/ls</FONT> <BR><FONT face=SimSun color=#000066>&nbsp; ./ls</FONT> <BR>&nbsp;</UL>因为在同一个目录中，而我们又知道在同一个目录中的目录符号为『 . 』，因此，就以上面的 ./ls 来执行也可以！这种执行方式以后您应该会很常见到才对！</LI></UL>　 
<UL>
<LI>如果我有两个 ls 档案在不同的目录中，例如 /usr/local/bin/ls 底下与 /bin/ls 那么当我下达 ls 的时候，那个 ls 会被执行？那还用说，就找出 PATH 里面那个目录先被查询，则那个目录下的档案就会被先执行了！ </LI></UL>　 
<UL>
<LI>咦！既然如此的话，那么为何不要在 PATH 里面加入 . 这个目录，如此一来的话，不就可以直接在所在目录执行档案了吗？因为 . 代表所在目录嘛！是这样没错！但是有没有想过，如果某天，某个怪怪的使用者在 /tmp 里面写了一个 ls 的档案，偏偏他是有害的档案，那么当你在 /tmp 底下执行 ls 时，怎么办？！没错，可能会『中标』，所以，<B><FONT color=#000066>为了安全起见，不建议将『 . 』加入 PATH 的搜寻当中</FONT></B>！ </LI></UL></LI></UL></BLOCKQUOTE>
<HR width="100%">
<A name=file_directory_manag></A><FONT color=#000099 size=+1>档案与目录管理：</FONT> 
<BLOCKQUOTE><FONT color=#000000>谈了谈目录与路径之后，再来讨论一下关于档案的一些基本管理吧！档案与目录的管理上，不外乎『</FONT><B><FONT color=#000066>显示属性</FONT></B><FONT color=#000000>』、『</FONT><B><FONT color=#000066>拷贝</FONT></B><FONT color=#000000>』、『</FONT><B><FONT color=#000066>删除档案</FONT></B><FONT color=#000000>』及『</FONT><B><FONT color=#000066>移动档案或目录</FONT></B><FONT color=#000000>』等等，由于档案与目录的管理在 Linux 当中是很重要的！尤其是每个人自己家目录的数据也都需要注意管理！由于我们在执行程序的时后，系统预设有一个搜寻的路径顺序，如果有两个以上相同档名的执行档分别在不同的路径时，呵呵，就需要特别留意！这里我们来谈一谈有关档案与目录的一些基础管理部分吧！</FONT> 
<BLOCKQUOTE><FONT face=SimSun color=#000000><B>ls</B> 显示文件名称、属性等</FONT> <BR><FONT face=SimSun color=#000000><B>cp</B> 拷贝档案或目录</FONT> <BR><FONT face=SimSun color=#000000><B>rm</B> 删除档案或目录</FONT> <BR><FONT face=SimSun color=#000000><B>mv</B> 移动档案或目录</FONT> <BR><FONT face=SimSun color=#000000>　</FONT> <BR>
<HR width="100%">

<LI><A name=ls></A><B><FONT face=SimSun color=#000099>ls</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]#</FONT><FONT color=#ffff00> ls [-ailS]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :全部的档案都列出（连同隐藏档）</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :印出 inode 的值</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-l&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :长的列出，连同档案大小的数据等等</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-S&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :以档案大小排序</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>--color=never&nbsp;&nbsp;&nbsp;&nbsp; :不要显示颜色</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>--color=always&nbsp;&nbsp;&nbsp; :均显示颜色</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>--color=auto&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :由系统自行判断！</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>ls -al</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>total 48</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>drwxr-x---&nbsp;&nbsp;&nbsp; 4 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096 Mar 10 00:37 .</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>drwxr-xr-x&nbsp;&nbsp; 21 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096 Mar 10 20:16 ..</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-rw-------&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 524 Mar 10 00:40 .bash_history</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-rw-r--r--&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24 Jun 11&nbsp; 2000 .bash_logout</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-rw-r--r--&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 266 Jun 11&nbsp; 2000 .bash_profile</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-rw-r--r--&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 249 Mar&nbsp; 6 20:50 .bashrc</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-rw-r--r--&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 210 Jun 11&nbsp; 2000 .cshrc</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>drwx------&nbsp;&nbsp;&nbsp; 2 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096 Mar&nbsp; 9 11:06 </FONT><FONT color=#3333ff>.gnupg</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-rw-------&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 524 Jan 16 14:37 .mysql_history</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>drwx------&nbsp;&nbsp;&nbsp; 2 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096 Mar&nbsp; 9 11:06 </FONT><FONT color=#3333ff>.ssh</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-rw-r--r--&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 196 Jul 11&nbsp; 2000 .tcshrc</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-rw-r--r--&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1126 Aug 24&nbsp; 1995 .Xresources</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /]# </FONT><FONT color=#ffff00>ls</FONT></FONT> <BR><FONT face=SimSun color=#3333ff size=-1>bin&nbsp;&nbsp; dev&nbsp;&nbsp;&nbsp; etc&nbsp;&nbsp; lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; misc&nbsp; opt&nbsp;&nbsp; root&nbsp; tftpboot&nbsp; usr</FONT> <BR><FONT face=SimSun color=#3333ff size=-1>boot&nbsp; disk1&nbsp; home&nbsp; lost+found&nbsp; mnt&nbsp;&nbsp; proc&nbsp; sbin&nbsp; tmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /]# </FONT><FONT color=#ffff00>ls --color=never</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>bin&nbsp;&nbsp; dev&nbsp;&nbsp;&nbsp; etc&nbsp;&nbsp; lib&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; misc&nbsp; opt&nbsp;&nbsp; root&nbsp; tftpboot&nbsp; usr</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>boot&nbsp; disk1&nbsp; home&nbsp; lost+found&nbsp; mnt&nbsp;&nbsp; proc&nbsp; sbin&nbsp; tmp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /]# </FONT><FONT color=#ffff00>ls -al|more</FONT></FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>还记得我们在解释<A href="http://linux-vbird.3322.org/linux_base/0170filepermission.php">档案的一些属性与目录的结构</A>的那一章吗？！对啦！我们使用的第一支指令就是 ls 啦！通常我们都需要知道这个文件名称『目录』还是『档案』？所以，我都喜欢使用『 <FONT face=SimSun color=#000066>ll</FONT>』这个指令，其实那就是<FONT face=SimSun><FONT color=#000066>ls -l</FONT><FONT color=#3333ff> </FONT></FONT>的意思啦！不论如何，你都可以尝试着执行这之指令来视察你的档案！ <BR>　 <BR>请注意呦！不要忘记你的资料的主要咚咚！尤其是前面几个主要的属性呦！另外，你有没有发现如果在远程以 telnet 或者是 putty 的联机程序登入主机的时后，由于 Linux 预设使用有颜色的方式显示方式，但是像上表一样，蓝色的字样根本就是很难看到！这个时候通常我都是使用『<FONT face=SimSun color=#000066>ls --color=never</FONT> 』来丢掉颜色！那如果想让 ls 预设没有颜色的话，可以在 /root/.bashrc 或者是你的家目录的 .bashrc 这个档案中加入下面这一行： 
<BLOCKQUOTE><FONT face=SimSun color=#000066>alias ls='ls --color=never'</FONT></BLOCKQUOTE><FONT face=SimSun color=#000000>这样就可以把颜色去到了！至于 alias 是在干嘛的？我们到了 bash 这个 shell 的时候再来谈吧！</FONT> <BR><FONT face=SimSun color=#000000>　</FONT> <BR>
<HR width="100%">

<LI><A name=cp></A><B><FONT face=SimSun color=#000099>cp</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=800 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>cp [-drsu] [来源档] [目的档]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-d　　　　　：在进行 copy 的时候，如果是 copy 到 link 档案，若不加任何参数，则预设情况中会将 link 到的源文件</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>　　　　　　　copy 到目的地，若加 -d 时，则 link 档案可原封不动的将 link 这个快捷方式其拷贝到目的地！</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-r　　　　　：可以进行目录的 copy 呦！</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ：做成连结档，而不 copy 之意！与 ln 指令相同功能！</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-u, --update：如果来源档比较新，或者是没有目的档，那么才会进行 copy 的动作！可用于备份的动作中！</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>cp&nbsp;&nbsp;&nbsp; .bashrc bashrc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#ff9900> &lt;==将 .bashrc 拷贝成 bashrc 这个档案！</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>cp -r /bin /tmp/bin&nbsp;&nbsp;</FONT><FONT color=#ffffff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#ff9900> &lt;==这个功能就好玩啦！这是用来 copy 整个目录的参数！</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffcc00>cp -s .bashrc bashrc&nbsp;</FONT><FONT color=#ffffff>&nbsp;&nbsp;</FONT><FONT color=#ffff00>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#ff9900> &lt;==将 .bashrc 建立一个连结档，档名为 bashrc</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>cp -u /home/.bashrc .bashrc</FONT><FONT color=#ffffff>&nbsp;</FONT><FONT color=#ff9900> &lt;==先检查 /home/.bashrc 是否与 .bashrc 不同，如果不同的话就开始 copy 一份！如果相同则不做任何动作！</FONT></FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR><FONT color=#000000>这个指令会常用到的呦！因为我们得常常需要 copy 资料呀！所以需要了解一下喔！</FONT>如果你有些很大档案的需要备份，偏偏这个档案的更新率很低，那么每次备份都需要在 copy 一份吗？看来是不需要了！你可以使用『<FONT face=SimSun color=#000066>cp -u 来源档 目的档</FONT>』来备份呦！如此一来，当档案被改变过后，才会进行 copy 的动作！ <BR>　 <BR>
<HR width="100%">

<LI><A name=rm></A><B><FONT face=SimSun color=#000099>rm</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=650 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>rm [-fir] [n名]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-i&nbsp;&nbsp;&nbsp;&nbsp; :提供使用者确认（这是默认值）</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-r&nbsp;&nbsp;&nbsp;&nbsp; :循环，就是一直杀掉，直到没有东西为止的意思</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-f&nbsp;&nbsp;&nbsp;&nbsp; :force ，就是强力杀掉啦！</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>cp .bashrc bashrc</FONT><FONT color=#ff9900>&lt;==建立一个新档案， bashrc</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>rm bashrc&nbsp;</FONT><FONT color=#ffffff>&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#ffff00>&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#ff9900>&nbsp; &lt;==会显示如下的提示：</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>rm: remove `bashrc'?</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]#</FONT><FONT color=#ffff00> mkdir testing</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>cp .bashrc testing</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>rmdir testing</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>rmdir: `testing': Directory not empty&nbsp;&nbsp;</FONT><FONT color=#ff9900> &lt;==由于 testing 里面有 .bashrc ，所以砍不掉！</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>rm -rf testing&nbsp;</FONT><FONT color=#ffffff>&nbsp;&nbsp;&nbsp;</FONT><FONT color=#ffff00>&nbsp;</FONT><FONT color=#ff9900> &lt;==持续删除该目录下的所有档案与目录</FONT></FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>这是移除的指令，相当于 dos 下的 del 指令！这里要注意的是，通常在 Linux 系统下，为了怕档案被误杀，所以都已经有 -i 这个参数， -i 是指每个档案被杀掉之前都会让使用者确认一次，以预防误杀档案！而如果要连目录下的东西都一起杀掉的话，例如子目录里面还有子目录时，那就要使用 -rf 这个参数了！<B><FONT color=#000066>不过，使用『 <FONT face=SimSun>rm -rf</FONT> 』这个指令之前，请千万注意了，因为，该目录或档案『肯定』会被 root 杀掉</FONT></B>！因为系统不会再次询问你是否要砍掉呦！ 所以那是个超级严重的指令下达呦！得特别注意！不过，如果你确定该目录不要了，那么使用 rm -rf 来循环杀掉是不错的方式！ <BR>　 <BR>
<HR width="100%">

<LI><A name=mv></A><B><FONT face=SimSun color=#000099>mv</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=520 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>mv [-u] [来源档] [目的档]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-u&nbsp;&nbsp; :同样的，为 update 的简写，当来源档比目的档还新的时后才会动作！</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>cp .bashrc bashrc</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]#</FONT><FONT color=#ffff00> mv bashrc bashrc.old</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>mv bashrc bashrc2 /tmp</FONT><FONT color=#ff9900>&lt;==将 bashrc 与 bashrc2 移动到 /tmp 这个目录下！请注意，最后一个才是最终的目标，其它的都是 SOURCE</FONT></FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>这是搬移的意思！当你要移动档案或目录的时后，呵呵！这个指令就很重要啦！同样的，你也可以使用 -u ( update )才测试新旧档案，看看是否需要搬移！另外一个用途就是『变更档名！』，我们可以很轻易的使用 mv 来变更一的档案的档名呢！ <BR>　 <BR>
<HR width="100%">

<LI><A name=basename></A><B><FONT face=SimSun color=#000099>basename</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=520 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>basename [目录]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>basename /usr/local/etc</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>etc</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>这个指令会将后面的[目录]仅撷取出最后面的那个目录或档案，</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>以上面的例子来看， /usr/local/etc 不论 etc 是目录或档案，</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>他都会被撷取出来，因为他是最后一个出现的咚咚！</FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>这个指令颇有点意思～他可以将一个目录或档案的最后一个咚咚秀出来！所以，未来如果你有要使用变量，并且取出最后一个数据(不论是档案还是目录)，那么使用这个玩意儿就对啦！ ^_^ <BR>　 <BR>
<HR width="100%">

<LI><A name=dirname></A><B><FONT face=SimSun color=#000099>dirname</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=520 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>dirname [目录]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>dirname /usr/local/etc</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>/usr/local</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>恰恰与 basename 相反，他仅是秀出来前面的『目录』部分喔！</FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>这个指令恰恰与 basename 相反的啦！呵呵！很好玩吧！这部份也最常用在我们第三部分要讲的 Shell 的学习中喔！用最多的地方应该是 scripts 啦！用这两个宝贝蛋来撷取部分数据的内容！有用的很！</LI></BLOCKQUOTE></BLOCKQUOTE>
<HR width="100%">
<A name=lookfile></A><FONT size=+1><FONT color=#000099>观看档案内容</FONT>：</FONT>cat, tac, more, less, head, tail, nl, 
<BLOCKQUOTE>刚刚我们提到的都只是在于显示档案的外观，或者是移动与复制一个档案或目录而已，那么如果我们要视察一个档案的内容时，该如何是好呢？！这里有相当多有趣的指令可以来分享一下：<FONT color=#000066>最常使用的显示档案内容的指令可以说是 cat 与 more 及 less 了</FONT>！此外，如果我们要查看一个很大型的档案（好几百MB时），但是我们只需要后端的几行字而已，那么该如何是好？呵呵！用 tail 呀，此外， tac 这个指令也可以达到！好了，说说各个指令的用途吧！ 
<BLOCKQUOTE><FONT face=SimSun><B>cat</B>&nbsp; 由第一行开始显示档案内容</FONT> <BR><FONT face=SimSun><B>tac</B>&nbsp; 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</FONT> <BR><FONT face=SimSun><B>more</B> 一页一页的显示档案内容</FONT> <BR><FONT face=SimSun><B>less</B> 与 more 类似，但是比 more 更好的是，他可以往前翻页！</FONT> <BR><FONT face=SimSun><B>head</B> 只看头几行</FONT> <BR><FONT face=SimSun><B>tail</B> 只看尾巴几行</FONT> <BR><FONT face=SimSun><B>nl</B>&nbsp;&nbsp; 显示的时候，顺道输出 行号！</FONT> <BR><FONT face=SimSun><B>od</B>&nbsp;&nbsp; 以二进制的方式读取档案内容！</FONT></BLOCKQUOTE>底下我们来谈一谈每个指令的基本用法吧！ 
<BLOCKQUOTE>
<HR width="100%">

<LI><A name=cat></A><B><FONT face=SimSun color=#000099>cat</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=600 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>cat [-nAE]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-n:&nbsp;&nbsp; 显示时，连行号印出屏幕上。</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-A:&nbsp;&nbsp; 将 DOS 下的 &lt;tab&gt; 与断行字符都列出来！</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-E:&nbsp;&nbsp; 将 DOS 编辑的文件中，仅列出 断行字符出来！</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>cat ~/.bashrc&nbsp;</FONT><FONT color=#ffffff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#ff9900> &lt;==显示 .bashrc 这个档案</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1># .bashrc</FONT> 
<P><FONT face=SimSun color=#ffffff size=-1># User specific aliases and functions</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>PATH="/bin:/sbin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:$PATH"</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>alias rm='rm -i'</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>alias cp='cp -i'</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>alias mv='mv -i'</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>alias ll='ls -l --color=never'</FONT><FONT face=SimSun color=#ffffff size=-1></FONT> 
<P><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>cat ~/.bashrc -n&nbsp;&nbsp;&nbsp;</FONT><FONT color=#ffffff>&nbsp;</FONT><FONT color=#ff9900>&nbsp; &lt;==显示 .bashrc 并且加上行号！</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffff00>&nbsp;</FONT><FONT color=#ffffff>&nbsp;&nbsp;&nbsp; 1&nbsp; # .bashrc</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>&nbsp;&nbsp;&nbsp;&nbsp; 2</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp; # User specific aliases and functions</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp; PATH="/bin:/sbin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:$PATH"</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp; alias rm='rm -i'</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp; alias cp='cp -i'</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp; alias mv='mv -i'</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp; alias ll='ls -l --color=never'</FONT><FONT face=SimSun color=#ffffff size=-1></FONT> 
<P><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>cat -A regexp.txt</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>This is a cat, however, I need a dog.</FONT><FONT color=#ffff99>^M$</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>I want to "Happy" and &lt;Happy&gt; and /Happy/ here.</FONT><FONT color=#ffff99>^M$</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>OK! </FONT><FONT color=#ffff99>^I</FONT><FONT color=#ffffff>everythins is OK</FONT><FONT color=#ffff99>^M$</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>Now, I will eat my food</FONT><FONT color=#ffff99>^M$</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>are you </FONT><FONT color=#ffff99>^I</FONT><FONT color=#ffffff>finished your work</FONT><FONT color=#ffff99>^M$</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>what do you 123 goto where</FONT><FONT color=#ffff99>^M$</FONT></FONT> <BR><FONT face=SimSun color=#ff6666 size=-1>显示出 DOS 档案的几个特殊符号，以上面档案为例，</FONT> <BR><FONT face=SimSun color=#ff6666 size=-1>可发现 ^M 为断行符号，而每行的 $ 为行尾符号，</FONT> <BR><FONT face=SimSun color=#ff6666 size=-1>至于 ^I 则是 &lt;tab&gt; 按键啦！&nbsp;</FONT></P></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>嘿嘿！ Linux 里面有『猫』？！喔！不是的， cat 是 Concatenate （连续）的简写，主要的功能是将一个档案的内容连续的印出在屏幕上面！例如上面的例子中，我们将重要的参数档 .bashrc 印出来！如果加上 -n 的话，则每一行前面还会加上行号呦！cat 比较少用！毕竟当你的档案内容的行数超过 40 行以上，嘿嘿！根本来不及看！所以，配合 more 或者是 |more 来执行比较好！此外，如果是一般的 DOS 档案时，就需要特别留意一些奇奇怪怪的符号了，例如断行与&lt;tab&gt;等，要显示出来，就得加入 -A 之类的参数了！。 <BR>　 <BR>
<HR width="100%">

<LI><A name=tac></A><B><FONT face=SimSun color=#000099>tac</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>tac [n名]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>tac ~/.bashrc </FONT><FONT color=#ff9900>&lt;==发现了没？反向印出呦！</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>fi</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; . /etc/bashrc</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>if [ -f /etc/bashrc ]; then</FONT> <BR><FONT face=SimSun color=#ffffff size=-1># Source global definitions</FONT> 
<P><FONT face=SimSun color=#ffffff size=-1>alias h='history'</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>alias lm='ls -al|more'</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>alias ll='ls -l'</FONT> <BR><FONT face=SimSun color=#ffffff size=-1># alias ll='ls -l --color=never'</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>alias mv='mv -i'</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>alias cp='cp -i'</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>alias rm='rm -i'</FONT> 
<P><FONT face=SimSun color=#ffffff size=-1>export PATH</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>PATH="/bin:/sbin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:$PATH"</FONT> <BR><FONT face=SimSun color=#ffffff size=-1># User specific aliases and functions</FONT> 
<P><FONT face=SimSun color=#ffffff size=-1># .bashrc</FONT></P></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR><FONT color=#000000>tac 这个好玩了！怎么说呢？详细的看一下， cat 与 tac ，有没有发现呀！对啦！ tac 刚好是将 cat 反写过来，所以他的功能就跟 cat 相反啦， cat 是由『第一行到最后一行连续显示在屏幕上』，而 tac 则是『<B>由最后一行到第一行反向在屏幕上显示出来</B>』，很好玩吧！</FONT> <BR><FONT color=#000000>　</FONT> <BR>
<HR width="100%">

<LI><A name=more></A><B><FONT face=SimSun color=#000099>more</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>more [n名]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]#</FONT><FONT color=#ffff00> more ~/.bashrc</FONT><FONT color=#ffffff>&nbsp;</FONT><FONT color=#ff9900> &lt;==一页一页的显示档案内容</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /]# </FONT><FONT color=#ffff00>ls -al | more&nbsp;</FONT><FONT color=#ffffff> </FONT><FONT color=#ff9900>&lt;==一页一页的将 ls 的内容显示出来</FONT></FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR><FONT color=#000000>more 真是个很有用的指令！我好喜欢呦！当你的档案太大的时后，那么使用 cat 将没有办法看清楚！这个时候你可以使用 more 来做动作！</FONT>more 也可以用来做为管线的同时执行之用！例如你在执行 find 这个寻找的指令时，可以同时使用 |more ，则搜寻结果可以一页一页的列出呦！关于管线( pipe )的用法我们在 bash shell 的地方再来谈！ <BR>　 <BR>
<HR width="100%">

<LI><A name=less></A><B><FONT face=SimSun color=#000099>less</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]#</FONT><FONT color=#ffff00> less [n名]&nbsp;</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：&nbsp;</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：&nbsp;</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>less ~/.bashrc&nbsp;</FONT></FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>less 的用法比起 more 又更加的有弹性，怎么说呢？在 more 的时候，我们并没有办法向前面翻，只能往后面看，但若使用了 less 时，呵呵！就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，您瞧，是不是更容易使用来观看一个档案的内容了呢！？ <BR>　 <BR>more 与 less 的用途与用法真的是很广啦！首先，你可以在 more 与 less 的画面中进行『搜寻』的工作！如何进行呢？我们以 less 来说明好了，如果你想要知道 /etc/man.config 这个档案里面有没有一个叫做 GER 的大写字眼，那么可以： <BR>　 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]#</FONT><FONT color=#ffff00> less /etc/man.config&nbsp;</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>按键说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>/word：在 /etc/man.config 这个档案中搜寻 word 这个字符串的所在</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>q&nbsp;&nbsp;&nbsp; ：离开 less 的画面</FONT></TD></TR></TBODY></TABLE>　 <BR>然后在输入 / 之后，光标会移动到最左下角等待输入，这个时候您只要输入你的字符串之后，就会自动的帮你找出来该关键词！ <BR>　 <BR>
<HR width="100%">

<LI><A name=head></A><B><FONT face=SimSun color=#000099>head</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>head [-n number] [n名]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-n ：显示 number 行</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>head ~/.bashrc</FONT><FONT color=#ffffff>&nbsp;</FONT><FONT color=#ff9900> &lt;==预设情况下，显示头十行</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>head -n 20 ~/.bashrc</FONT><FONT color=#ff9900>&lt;==显示头二十行！</FONT></FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR><FONT color=#000000>head 的英文意思就是『头』啦，那么这个东西的用法自然就是显示出一个档案的前几行！没错！就是这样！若没有加上 -n 这个参数时，预设只显示十行，若只要一行呢？那就加入『 <FONT face=SimSun>head -n 1 filename</FONT> 』即可！</FONT> <BR><FONT color=#000000>　</FONT> <BR>
<HR width="100%">

<LI><A name=tail></A><B><FONT face=SimSun color=#000099>tail</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>tail [-n number] [n名]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-n ：显示 number 行</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>tail ~/.bashrc</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>tail -n 5 ~/.bashrc </FONT><FONT color=#ff9900>&lt;==只显示最后面五行！</FONT></FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR><FONT color=#000000>那么有 head 自然就有 tail ( 尾巴 ) ！没错！这个 tail 的用法跟 head 的用法差不多类似，只是显示的是后面几行就是了！预设也是显示十行，若要显示非十行，就加 -n number 的参数！</FONT> <BR><FONT color=#000000>　</FONT> 
<TABLE cols=1 width=500 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun>例题一：假如我想要显示 ~/.bashrc 的第 11 到第 20 行呢？</FONT> <BR><FONT face=SimSun>答：</FONT> 
<BLOCKQUOTE><FONT face=SimSun>这个应该不算难，想一想，在第 11 到第 20 行，那么我取前 20 行，再取后十行，所以结果就是：『 <B><FONT color=#000066>head Cn 20 ~/.bashrc | tail Cn 10 </FONT></B>』，这样就可以得到第 11 到第 20 行之间的内容了！但是里面涉及到管线命令，需要在第三篇的时候才讲的到！</FONT></BLOCKQUOTE></TD></TR></TBODY></TABLE><FONT color=#000000>　</FONT> <BR>
<HR width="100%">

<LI><A name=nl></A><B><FONT face=SimSun color=#000099>nl</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]#</FONT><FONT color=#ffff00> nl [n名]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]#</FONT><FONT color=#ffff00> nl ~/.bashrc</FONT></FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR><FONT color=#000000>那么 nl 又是什么？这也没什么，这个指令的用法跟 <A href="#cat">cat</A> -n 的用法类似，也就是『可以印出行号』的指令来查看档案啦！也是挺好用的！</FONT> <BR><FONT color=#000000>　</FONT> <BR>
<HR width="100%">

<LI><A name=od></A><B><FONT face=SimSun color=#000099>od</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>od [n名]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>od ~/.bashrc</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000000 020043 061056 071541 071150 005143 021412 052440 062563</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000020 020162 070163 061545 063151 061551 060440 064554 071541</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000040 071545 060440 062156 063040 067165 072143 067551 071556</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000060 050012 052101 036510 027442 064542 035156 071457 064542</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000100 035156 072457 071163 071457 064542 035156 072457 071163</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000120 061057 067151 027472 071565 027562 067554 060543 027554</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000140 061163 067151 027472 071565 027562 067554 060543 027554</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000160 064542 035156 050044 052101 021110 062412 070170 071157</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000200 020164 040520 044124 005012 066141 060551 020163 066562</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000220 023475 066562 026440 023551 060412 064554 071541 061440</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000240 036560 061447 020160 064455 005047 066141 060551 020163</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000260 073155 023475 073155 026440 023551 021412 060440 064554</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000300 071541 066040 036554 066047 020163 066055 026440 061455</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000320 066157 071157 067075 073145 071145 005047 066141 060551</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000340 020163 066154 023475 071554 026440 023554 060412 064554</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000360 071541 066040 036555 066047 020163 060455 076154 067555</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000400 062562 005047 066141 060551 020163 036550 064047 071551</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000420 067564 074562 005047 021412 051440 072557 061562 020145</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000440 066147 061157 066141 062040 063145 067151 072151 067551</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000460 071556 064412 020146 020133 063055 027440 072145 027543</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000500 060542 064163 061562 056440 020073 064164 067145 004412</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000520 020056 062457 061564 061057 071541 071150 005143 064546</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000540 000012</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0000541</FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR><FONT color=#000000>好了，那么如果有一个非 ASCII 的数据文件呢？例如那个 binary 的档案！使用 vi 根本就是看不着～这个时候看来只有使用将整个数据以数值方法读出来啦！那就是 od 这个指令来读出来呦！这个东西可以用来输出该数据为十进制、16进位等等的数据格式！不过这个东西对于工程师可能比较有用啦！因为印出来的东西都是数字或内存当中的数据～～</FONT></LI></BLOCKQUOTE></BLOCKQUOTE>
<HR width="100%">
<A name=linkfiles></A><FONT color=#000099 size=+1>连结档的介绍：</FONT> 
<BLOCKQUOTE><FONT color=#000000>在开始介绍介绍连结档 ( Link ) 之前，我们得先来了解一下什么是 inode 这个东西？说实在的，这个东西真的很重要，不了解他的时候，很容易搞错很多的咚咚！</FONT> 
<UL>
<HR width="100%">

<LI><A name=inodes></A><B><FONT color=#000099>什么是 inodes ？</FONT></B> <BR><FONT color=#000000>要提到 inode 之前，我们得先来了解一下硬盘的整体构造才行！硬盘里面有多个硬盘盘组合在一起，而一个硬盘盘可以如下图所示，硬盘盘为圆形的，其中，每一个硬盘盘上面都有个可以读写的磁头( Head )，而当这个磁头固定住，让硬盘盘转一圈，那么那一个圆形的就是磁道( Track )啦，而在硬盘内的几个硬盘盘同半径的那一圈的磁道总和称为磁柱( Cylinder )，而由圆心向外画出直线，可以得到如下图所示，那么那一颗一颗的咚咚，就是硬盘的最小储存物理量，我们称为扇区( setctor )，一个扇区的物理量大约是 512 bytes ( 约 0.5K )。</FONT> <BR><FONT color=#000000>　</FONT> 
<UL><FONT color=#000000>磁头 ( Head ) ：可擦写的金属磁盘；</FONT> <BR><FONT color=#000000>磁道 ( Track ) ：读写头转一圈 ( 同心圆的一圈 ) 的量；</FONT> <BR><FONT color=#000000>扇区 ( Sector ) ：最小的物理储存量。</FONT></UL><FONT color=#000000>　</FONT> 
<CENTER><IMG height=373 src="17_files/0220filemanager[1].htm" width=400 NOSAVE></CENTER><FONT color=#000000>　</FONT> <BR><FONT color=#000000>好了，知道了大体的硬盘构造之后，再来谈一谈怎么硬盘分割( partition )呢？我们在进行硬盘分割的时候，最小都是以磁柱为单位进行分割的，那么分割完成之后自然就是格式化( format )，在 Linux 里面我们在进行格式化的时候必须要考虑到 Block 与 inode 的信息，</FONT><B><FONT color=#000066>这个 block 还好理解，他是我们磁盘可以记录的最小单位，是由数个 sector 所组成的，所以他的大小通常为 n*512 bytes ，例如 4K </FONT></B><FONT color=#000000>。那么 inode 是什么？</FONT><FONT color=#000066> Block 是记录『档案内容数据』的地区</FONT><FONT color=#000000>，而</FONT><FONT color=#000066> inode 则是记录『该档案的属性、及该档案放置在哪一个 Block 之内』的信息！所以</FONT><FONT color=#000000>，每个档案都会占用到至少一个 inode 。而当我们 Linux 系统要找到这个档案时，他会先去搜寻 inode table 找到这个档案的属性及数据放置的地区，然后再到数据去找到数据存放的 Block 进而将数据取出利用。</FONT><FONT color=#000066>这个 inode 数目在一开始就会被设定好，他的设定方式通常是利用 ( 硬盘大小 / 一个容量 )</FONT><FONT color=#000000>，这个容量至少应该比 Block 要大一些较佳，例如刚刚的 Block 订为 4K ，那么 inode 可以订为 8K 左右。所以，一颗 1GB 的硬盘，如果以 8K 来规划他的 inode 数时，他的 inode 就会有 131072 个 inode 啦！而</FONT><FONT color=#000066>一个 inode 的大小为 128 bytes 这么大</FONT><FONT color=#000000>！这么一来的话，我们就可以清楚的知道了，那就是</FONT><FONT color=#000066>一个 partition 格式化为一个 filesystem 之后，基本上，他一定会有 inode table 与 data area 两个区块，一个用来记录档案的信息与该档案放置的 block 区块，一个用来记录档案的内容</FONT><FONT color=#000000>！</FONT> <BR><FONT color=#000000>　</FONT> <BR><FONT color=#000000>由于我们 Linux 在读取数据的时候，是先查询 inode table 以得到数据是放在那个 Block 里面，然后再去该 Block 里面读取真正的数据内容！然后，那个 block 是我们在格式化硬盘的时候规定出来的一个值，这个 block 是由 2 的 n 次方个 sector 所集结而成的！所以，他是 0.5K 的倍数喔！假设我们 block 规划为 4KBytes 好了，那么</FONT><B><FONT color=#000066>由于一个 inode 与一个 block 最多均只纪录一个档案</FONT></B><FONT color=#000000>，所以，哈哈！如果你的一个档案有 0.1 K bytes 这么大时，你要晓得的是，由于你的 block 为 4K bytes ，因此，你就会有 3.9 Kbytes 的空间『浪费掉』喔！所以，当你在格式化硬盘的时候，请千万注意到你的系统未来的使用方向喔！</FONT></LI></UL>
<UL>
<UL>
<LI><FONT color=#000000>当 block 越小 ( 最小为 0.5K ) 、inodes 越多，可利用空间越多，但是大档案写入效率较差：适合档案数量多但是档案容量小的系统，例如 BBS 或者新闻群组 news 这方面的服务之系统；</FONT> 
<LI><FONT color=#000000>当 block 越大 ( 最大可到 16 * 0.5K 以上 ) 、 inodes 数越少，大档案写入效率较佳，但浪费的空间较多：适合档案容量大的系统。</FONT> </LI></UL></UL>
<UL>
<HR width="100%">

<LI><A name=ln></A><B><FONT face=SimSun color=#000099>ln</FONT></B> <BR><FONT color=#000000>OK！知道了什么是 inode 与他的功能之后，接着下来就要来介绍 link 这个玩意儿了！说到 link 其实也没有什么大不了的，说穿了，就真的有点像是 Windows 的『快捷方式』一样，不过， link 的功能要好的多呦！ Link 又分为 hard link 与 symbolic link 两种方式，分别来谈一谈：</FONT> <BR><FONT color=#000000>　</FONT> 
<UL>
<LI><B><FONT color=#000066>Hard Links：</FONT></B> <BR><FONT color=#000000>刚刚说过，当系统要读取某一个档案的时候，就会先去读 inode table ，然后再根据 inode 的信息到 block area 去将数据取出来利用！而 hard link 就是直接再建立一个 inode 连结到档案放置的 block 区块。也就是说，进行 hard link 的时候，实际上，你的档案内容不会改变，只是你在查询的时候，利用原来的 inode 与后来的 inode 均可被指定到该档案放置的地点，因此两个档案的内容会是一样的！所以读取任何一个 inode 的结果都是存取在同一个档案的内容就是了。不过，这样一来就有个问题啦，因为 inode 是会连结到 block 区域去的，而『目录』本身仅消耗 inode 而已，那么一来的话， hard link 不就不能 link 目录啦？对的！没错！ Hard link 有两个最大的限制：</FONT> <BR><FONT color=#000000>　</FONT> 
<OL>
<LI><FONT color=#000066>不能跨 filesystem ，因为不同的 filesystem 有不同的 inode table 嘛！</FONT> 
<LI><FONT color=#000066>不能 link 目录！</FONT> </LI></OL></LI></UL><FONT color=#000000>　</FONT> 
<UL>
<LI><FONT color=#000066><B>Symbolic Links</B>：</FONT> <BR><FONT color=#000000>相对于 hard link ， Symbolic link 可就好理解多了，基本上，他就是在建立一个独立的档案，而这个档案会让数据读取指向他 link 的那个档案内容！由于只是利用档案来做为指向的动作，所以，当来源档被删除之后，symbolic link 的档案会『开不了』，会一直说『无法开启某档案！』</FONT></LI></UL><FONT color=#000000>　</FONT> <BR><FONT color=#000000>所以，看样子，似乎 hard link 比较安全，因为即使某一个 inode 被杀掉了，只要有任何一个 inode 存在，那么该档案就不会不见！不过，不幸的是，由于 Hard Link 的限制太多了，包括无法做『目录』的 link ，所以在用途上面是比较受限的！反而是 Symbolic Link 的使用方向较广喔！好了，说的天花乱坠，看您也差不多快要昏倒了！没关系，实作一下就知道怎么回事了！</FONT> <BR><FONT color=#000000>　</FONT> <BR><FONT color=#000000>特别留意，底下的案例中，我们是将系统的设定文件 copy 到 /root/test 底下进行测试用的，请不要在 /etc/ 底下做，未来我们的工作目录都会在 /root/test 底下进行，这有个好处，是可以让您清楚的知道，这是用来 test 用的啦！</FONT></LI></UL></BLOCKQUOTE>
<BLOCKQUOTE>
<BLOCKQUOTE><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=600 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>ln [-s] [来源档] [目的档]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-s&nbsp;&nbsp; :提供连结档的连结！如果直接以 ln 不加任何参数的话，那么就属于 hard link ！</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]#</FONT><FONT color=#ffff00> mkdir test</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>cd test</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /test]# </FONT><FONT color=#ffff00>cp /usr/bin/passwd .</FONT></FONT> 
<P><FONT face=SimSun color=#ffffcc size=-1>0. 原本的信息：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /test]# </FONT><FONT color=#ffff00>ll&nbsp;</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>-rw-r--r-- </FONT><FONT color=#ffff00>1</FONT><FONT color=#ffffff> root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13476 Jun 26 11:31 passwd</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /test]# </FONT><FONT color=#ffff00>du -k</FONT><FONT color=#ff9900> &lt;==查看该目录下的占用硬盘空间</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>20</FONT> 
<P><FONT face=SimSun color=#ffffcc size=-1>1. Hard Link 信息：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /test]# </FONT><FONT color=#ffff00>ln passwd passwd-hard</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /test]# </FONT><FONT color=#ffff00>ll</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>total 32</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>-rw-r--r-- </FONT><FONT color=#ffff00>2</FONT><FONT color=#ffffff> root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13476 Jun 26 11:31 passwd</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>-rw-r--r-- </FONT><FONT color=#ffff00>2</FONT><FONT color=#ffffff> root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13476 Jun 26 11:31 passwd-hard</FONT></FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>注意看，上面那个数字变成 2 ！这就是占用掉 inodes ！</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /test]# </FONT><FONT color=#ffff00>du -k</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>20&nbsp; </FONT><FONT color=#ff9900>&lt;==注意看，容量并没有变大！因为是 link 档案呀！</FONT></FONT> 
<P><FONT face=SimSun color=#ffffcc size=-1>2. Symbolic Link 信息：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /test]# </FONT><FONT color=#ffff00>ln -s passwd passwd-soft; ll</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-rw-r--r--&nbsp;&nbsp;&nbsp; 2 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13476 Jun 26 11:31 passwd</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-rw-r--r--&nbsp;&nbsp;&nbsp; 2 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13476 Jun 26 11:31 passwd-hard</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>lrwxrwxrwx&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6 Jun 26 11:37 passwd-sofe -&gt; passwd</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>注意！该 Symbolic Link 的档案是有容量的呦！</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>注意， passwd-soft 会指到另外一个档案去，而且，最前面属性显示 l ，</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>此外，他是一个独立的档案！先杀掉 passwd 后，我们分别 more 一下内容：</FONT> 
<P><FONT face=SimSun color=#ffffcc size=-1>3. 用 more 来试试看是怎样？！&nbsp;</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test test]# </FONT><FONT color=#ffff00>rm passwd</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>rm: remove regular file `passwd'? </FONT><FONT color=#ffff00>y</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test test]# </FONT><FONT color=#ffff00>more passwd-hard</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>………(正常显示)</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test test]# </FONT><FONT color=#ffff00>more passwd-soft</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>passwd-soft: No such file or directory</FONT></P></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>要注意！如果不加任何参数的话，那么就是 Hard Link ！如同上面的情况，增加了 hard link 之后，可以发现 link 那一栏属性增加了！而如果这个时候砍掉 passwd 会发生什么事情呢？呵呵！ passwd-hard 的内容还是会跟原来 passwd 相同，但是 passwd-soft 就会找不到该档案啦！就是这样！了解了吗？！还有，跟 cp 也不一样呦！因为虽然 Hard Link 的档案看起来是有容量的，但是基本上还是指向原来的档案，所以，整体容量是没有增大的啦！ <BR>　 <BR>而如果使用 -s 的参数时，就做成差不多是 Windows 底下的『快捷方式』的意思（Symbolic Link，较常用！）不过，需要特别注意的是， Linux 的 link 与 Windows 的快捷方式是不一样的东西！举个例子说，当你在 Windows 建立一个快捷方式时，你可以在这个快捷方式内修改任何数据，而你的原始数据并不会跟着变！不过，当你修改 Linux 下的 link 档案时，则更动的其实是『原始档』，呵呵，所以不论你的这个原始档被连结到哪里去，只要你修改了连结档，呵呵！原始档就跟着变！以上面为例，由于你使用 -s 的参数建立一个名为 passwd-soft 的档案，则你修改 passwd-soft 时，其内容与 passwd 完全相同，并且，当你按下储存之后，被改变的将是 passwd 这个档案！ <BR>　 <BR>此外，如果你做了底下这样的连结： 
<BLOCKQUOTE><FONT face=SimSun color=#000066>ln Cs /bin /root/bin</FONT></BLOCKQUOTE>那么如果你进入 /root/bin 这个目录下，『请注意呦！该目录其实是 /bin 这个目录，因为你做了连结档了！』所以，如果你进入 /root/bin 这个刚刚建立的连结目录，并且将其中的数据杀掉时，嗯！ /bin 里面的数据就通通不见了！这点请千万注意！并不是 /root 底下的资料都是 root 的！还需要注意一下该属性才行！ <BR>　 <BR>基本上， Symbolic link 的用途比较广，所以您要特别留意 symbolic link 的用法呢！未来一定还会常常用到的啦！</BLOCKQUOTE></BLOCKQUOTE>
<HR width="100%">
<A name=file_dir_own></A><FONT color=#000099 size=+1>档案与目录权限：</FONT> 
<BLOCKQUOTE><FONT color=#000000>由 <A href="http://linux-vbird.3322.org/linux_base/0170filepermission.php">Linux 档案属性</A> 的内容我们可以知道一个档案有若干个属性，包括 ( r, w, x ) 等基本属性，及是否为目录 (d) 与档案 (-) 或者是连结档 (l) 等等的属性！那么要修改属性的方法在前面也约略提过了，这里再加强补充一下！此外，由于 Linux 还可以设定其它的系统安全属性，使用 chattr 来设定，而以 lsattr 来查看，最重要的属性就是可以设定其不可修改的特性！让连档案的拥有者都不能进行修改！这个属性可是相当重要的，尤其是在安全机制上面（ security ）！</FONT> 
<BLOCKQUOTE><FONT face=SimSun color=#000000><B>chown</B> 改变档案的拥有人</FONT> <BR><FONT face=SimSun color=#000000><B>chgrp</B> 改变档案的所属群组</FONT> <BR><FONT face=SimSun color=#000000><B>chmod</B> 改变档案的可写、可读、可执行等属性</FONT> <BR><FONT face=SimSun color=#000000><B>umask</B> 改变预设的建立档案或目录时的属性</FONT> <BR><FONT face=SimSun color=#000000><B>chattr</B> 改变档案的特殊属性</FONT> <BR><FONT face=SimSun color=#000000><B>lsattr</B> 显示档案的特殊属性！</FONT></BLOCKQUOTE></BLOCKQUOTE>
<BLOCKQUOTE>
<UL>
<HR width="100%">

<LI><A name=chown></A><B><FONT face=SimSun color=#000099>chown</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=750 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>chown [-R] user:group [目录名称]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-R&nbsp;&nbsp;&nbsp; :循环的将该目录下的所有档案都改成 user 与 group 的名称！</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>mkdir /home/test/testing</FONT><FONT color=#ffffff>&nbsp;</FONT><FONT color=#ff9900> &lt;==在 /home/test 这个家目录中建立一个名为 testint 的子目录</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>cp * /home/test/testing</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>chown test /home/test/testing</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>chown -R test:test /home/test/testing</FONT><FONT color=#ff9900>&lt;==将该目录下的所有目录或档案均变为 test 拥有</FONT></FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>前一个章节才刚讲完，应该不会就这样忘记了吧？！由于 chown 的使用范围较广，所以这里再次的给他复习一下 chown 就好， <A href="http://linux-vbird.3322.org/linux_base/0170filepermission.php#chgrp">chgrp</A> 请回前一章内容观看呦！ <BR>　 <BR>记得档案有『<FONT color=#000066>拥有人</FONT>』及『<FONT color=#000066>拥有群组</FONT>』吧，这个 chown 就是在改变拥有者的指令。刚接触 Linux 的朋友最容易犯的一个错误在哪里呢？就是以 root 的身份 copy 一个档案（或路径）给一般使用者（假设为 test ）时，忘记将该档案的所有人改成 test 了！由于复制者是 root 所以该档案也会是 root 所有！那么 test 当然也就不能修改该档案了！ <BR>　 <BR>在上面的例子中，『 <FONT face=SimSun color=#000066>chown test /home/test/testing</FONT> 』这个指令只会将该目录变成 test 的，但是 group 仍然是 root 的呦！所以你可以使用『 chown test:test /home/test/testing 』，连使用者群组都给他改变一下！不过需要注意的是，这两个指令都只改变了『目录』的所有权而已！那么在这个目录下的东西也要改变的话，该如何？！呵呵，就使用 -R 这个参数即可！ <BR>　 <BR>
<HR width="100%">

<LI><A name=chmod></A><B><FONT face=SimSun color=#000099>chmod</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun color=#ffffff size=-1>[root @test /root ]# chmod [-R] [parameter] [目录名称]</FONT> <BR><FONT face=SimSun color=#ffff00 size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ffff00 size=-1>-R&nbsp;&nbsp; :循环的一直将该目录的档案均改变之！</FONT> <BR><FONT face=SimSun color=#ffff00 size=-1>范例：</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>[root @test /root]# chmod 777 .bashrc&nbsp;</FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>还记得在『<A href="http://linux-vbird.3322.org/linux_base/0170filepermission.php">档案属性与系统</A>』那一章吧！一个档案或目录至少有九个属性，三个三个一组，共分为三组！而可以使用数字来当作变换属性的参考依据！各属性如下： 
<BLOCKQUOTE><FONT face=SimSun color=#000099>r:4</FONT> <BR><FONT face=SimSun color=#000099>w:2</FONT> <BR><FONT face=SimSun color=#000099>x:1</FONT></BLOCKQUOTE>举个例子来说，当一个属性为『<FONT face=SimSun color=#000066>-rwxr-xr--</FONT>』时，那是几分呢？！我们可以将他看成如下『<FONT face=SimSun color=#000066>-[rwx][r-x][r--]</FONT>』三组，所以分数就变成了『<FONT face=SimSun color=#000066>[4+2+1][4+0+1][4+0+0]</FONT>』共有『754』分啦！这样会算吗？！OK！测试一下，底下的分数为几分： 
<BLOCKQUOTE><FONT face=SimSun color=#000099>-r-xr-xr-x</FONT> <BR><FONT face=SimSun color=#000099>-rwxrw----</FONT></BLOCKQUOTE>如果你可以算出『555』与『760』，呵呵！那么你就应该会算！所以，如果你要将 .bashrc 设定成所有人都可以读取的话，就下达『 <FONT face=SimSun color=#000099>chmod 777 .bashrc</FONT> 』吧！其中需要特别注意的是，通常我们都会允许个人网页的设定！那么由于个人网页预设是记录在<FONT face=SimSun color=#000066>/home/userID/public_html</FONT>底下，偏偏 /home/userID 的属性为『<FONT face=SimSun color=#000066>drwx------</FONT>』根本就不允许任何人进入！所以，你最少要将你的目录设定成『<FONT face=SimSun>drwx--x--x</FONT>』 才可以！当然也可以设定成『<FONT face=SimSun color=#000066>drwxr-xr-x</FONT>』！不过不建议设定成『777』呦！ <BR>　 <BR>
<HR width="100%">

<LI><A name=umask></A><B><FONT color=#000099>umask</FONT></B> <BR>OK！那么现在我们知道如何建立或者是改变一个目录或档案的属性了，不过，您知道当你建立一个新的档案或目录时，他的预设属性会是什么吗？呵呵！那就与 umask 有关了！那么 umask 是在搞什么呢？基本上， umask 就是指定『<B><FONT color=#000066>目前使用者在建立档案或目录时候的属性默认值</FONT></B>』，那么如何得知或设定 umask 呢？他的指定条件以底下的方式来指定： <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test root]# </FONT><FONT color=#ffff00>umask</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0022</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root@vbird test]# </FONT><FONT color=#ffff00>umask 002&nbsp;&nbsp;</FONT><FONT color=#ff9900> &lt;==后面接 3 个数字！</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root@vbird test]# </FONT><FONT color=#ffff00>umask</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0002</FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>查看 umask 数值为直接输入 umask 即可，而设定呢？没错！就是 umask 之后接三个数字！那么如何来指定呢？主要还是跟 Linux 的档案属性（那九个属性， r, w, x ）有关的，而且是以分数的那一个关系为例的，而有底下的规则为辅： <BR>　 
<UL>
<LI>若使用者建立为『档案』则预设『没有可执行 ( x ) 项目』，亦即只有 rw 这两个项目，也就是最大为 666 分 <BR><FONT face=SimSun color=#000066>--rw-rw-rw-</FONT> 
<LI>若使用者建立为『目录』，则由于 x 与是否可以进入此目录有关，因此预设为所有权限均开放，亦即为 777 分 <BR><FONT face=SimSun color=#000066>drwxrwxrwx</FONT></LI></UL>　 <BR>那么 umask 指定的是『<B><FONT color=#000066>该默认值需要减掉的权限</FONT></B>！』因为 r、w、x 分别是 4、2、1 分，所以！也就是说，当要拿掉能写的权限，就是输入 2 分，而如果要拿掉能读的权限，也就是 4 分，那么要拿掉读与写的权限，也就是 6 分，而要拿掉执行与写入的权限，也就是 3 分，这样了解吗？请问您， 5 分是什么？呵呵！就是读与执行的权限啦！如果以上面的例子来说明的话，因为 umask 为 002 ，所以 user, group 并没有被拿掉属性，不过 others 的属性被拿掉了 2 ( 也就是 w 这个属性 )，那么由于当使用者： <BR>　 
<UL>
<LI><FONT face=SimSun color=#000066>建立档案时：(-rw-rw-rw-) C (--------w-) ==&gt; -rw-rw-r--</FONT> 
<LI><FONT face=SimSun color=#000066>建立目录时：(drwxrwxrwx) C (--------w-) ==&gt; drwxrwxr-x</FONT> </LI></UL>　 <BR>不相信吗？你只要使用 touch test 然后看看这个 test 的档案属性，就可以知道了！那么如何看你这个使用者目前的 umask 呢？直接下达 umask 即可！实作看看先： <BR>　 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root@vbird test]# </FONT><FONT color=#ffff00>umask</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>0002</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root@vbird test]# </FONT><FONT color=#ffff00>touch test1</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root@vbird test]# </FONT><FONT color=#ffff00>mkdir test2</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root@vbird test]# </FONT><FONT color=#ffff00>ls -l</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-rw-rw-r--&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 Oct 22 00:00 test1</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>drwxrwxr-x&nbsp;&nbsp;&nbsp; 2 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096 Oct 22 00:00 test2/</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>发现了什么？呵呵！ Test1 的属性为 666-002 = 664 ！正确吗？是的！正确！</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>而 test2 这个目录呢？就是 777-002 = 775 ！也正确！</FONT> 
<P><FONT face=SimSun size=-1><FONT color=#ffffff>[root@vbird test]# </FONT><FONT color=#ffff00>umask 003</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root@vbird test]# </FONT><FONT color=#ffff00>touch test3</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root@vbird test]# </FONT><FONT color=#ffff00>mkdir test4</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root@vbird test]# </FONT><FONT color=#ffff00>ll</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-rw-rw-r--&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 Oct 22 00:03 test3</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>drwxrwxr--&nbsp;&nbsp;&nbsp; 2 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096 Oct 22 00:03 test4/</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ff9900>嘿！属性又跟刚刚的不一样！仔细推敲一下为什么呦！test3 666-003 =663，这是怎么一回事？！ 663 应该是 -rw-rw--wx 才对啊！怎么会是上面的属性！呵呵！这里就要特别的给他强调了！『</FONT><FONT color=#ffff00>尽量不要以数字相加减啦！</FONT><FONT color=#ff9900>』容易造成类似上面的问题！你应该要这样想</FONT><FONT color=#ffff00>(-rw-rw-rw-) - (--------wx)=-rw-rw-r--</FONT><FONT color=#ff9900>这样就对啦！了解了吗？不要用十进制的数字喔！够能力的话，用二进制来算，不晓得的话，用 rwx 来算喔！ ^_^</FONT></FONT></P></TD></TR></TBODY></TABLE><FONT color=#ff0000>　</FONT> <BR>由上面的例子您应该很轻易的就可以发现 umask 的用途！而这个 umask 可以在 /etc/bashrc 里面进行修改喔！预设的情况之下， root 的 umask 为 022 而一般使用者则为 002 ，因为可写的权限蛮严重的，因此预设都会拿掉这个权限！此外，因为 root 比较重要！所以为了安全的需求，其同群组的写入属性就被拿掉了！这东西对于安全性也有一定程度的贡献呦！ <BR>　 <BR>
<HR width="100%">

<LI><A name=chattr></A><B><FONT face=SimSun color=#000099>chattr</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=700 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>chattr [+-=][ASacdistu] [档案或目录名称]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>+-=　：分别为 [+ 增加] [- 减少] [= 设定] 属性的意思</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>A　　：当设定了 A 这个属性时，这个档案(或目录)的存取时间 atime (access) 将不可被修改，</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>　　　 可避免例如手提式计算机容易有磁盘 I/O 错误的情况发生！</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>S　　：这个功能有点类似 <A href="#sync">sync</A> 的功能！就是会将数据同步写入磁盘当中！可以有效的避免数据流失！</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>a　　：当设定 a 之后，这个档案将只能增加数据，而不能删除，只有 root 才能设定这个属性。</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>c　　：这个属性设定之后，将会自动的将此档案『压缩』，在读取的时候将会自动解压缩出来！</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>　　 　但是在储存的时候，将会先进行压缩之后再储存（看来对于大档案似乎蛮有用的！）</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>d　　：当 dump (备份)程序被执行的时候，设定 d 属性将可使该档案(或目录)具有 dump 功效！</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>i　　：这个 i 可就很厉害了！他可以让一个档案『不能被删除、改名、设定连结也无法写入或新增数据！』</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>　　　 对于系统安全性有相当大的帮助！</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>j　　：当使用 ext3 这个档案系统格式时，设定 j 属性将会使档案在写入时先记录在 journal 中！</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>　　 　但是当 filesystem 设定参数为 data=journalled 时，由于已经设定了日志了，所以这个属性无效！</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>s　　：当档案设定了 s 参数时，他将会被完全的移除出这个硬盘空间。</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>u　　：与 s 相反的，当使用 u 来设定档案时，则数据内容其实还存在磁盘中，可以使用来 undeletion.</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>chattr +i /etc/shadow</FONT><FONT color=#ff9900>&lt;==呵呵！如此则无法更动这个档案！</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>chattr -i /etc/shadow </FONT><FONT color=#ff9900>&lt;==解除该属性！</FONT></FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>这这个指令是重要的，尤其是在系统的安全性上面！由于这些属性是隐藏的性质，所以需要以 <A href="#lsattr">lsattr</A> 才能看到该属性呦！其中，个人认为最重要的当属 +i 这个属性了，因为他可以让一个档案无法被更动，对于需要强烈的系统安全的人来说，真是相当的重要的！里头还有相当多的属性是需要 root 才能设定的呢！此外，如果是 log file 这种的登录档，就更需要 +a 这个可以增加，但不会被杀掉的参数了！怎样？很棒吧！未来提到登录档的认知时，我们再来聊一聊如何设定他吧！ <BR>　 <BR>
<HR width="100%">

<LI><A name=lsattr></A><B><FONT face=SimSun color=#000099>lsattr</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>lsattr [-aR]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-a　：将隐藏文件的属性也秀出来；</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-R　：连同子目录的数据也一并列出来！</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>chattr +i .bash_logout</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>lsattr -a&nbsp;</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-------------- ./.</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-------------- ./..</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>---i---------- ./.bash_logout</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-------------- ./.bash_profile</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-------------- ./.bashrc</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-------------- ./.emacs</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-------------- ./.screenrc</FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>这两个指令在使用上必须要特别小心，例如：某天你心情好，突然将 /etc/shadow 这个重要的密码记录档案给他设定成为具有 i 的属性，那么过了若干天之后，你突然要新增使用者，却一直无法新增！别怀疑，赶快去将 i 的属性拿掉吧！</LI></UL></BLOCKQUOTE>
<HR width="100%">
<A name=Search></A><FONT color=#000099 size=+1>搜寻档案或目录：</FONT> 
<BLOCKQUOTE><FONT color=#000000>档案的搜寻可就厉害了！因为我们常常需要知道那个档案放在哪里，所以来谈一谈怎么搜寻吧！在 Linux 底下也有相当优异的搜寻系统呦！通常 find 不很常用的！因为速度慢之外，也很操硬盘！通常我们都是先使用 whereis 或者是 locate 来检查，如果真的找不到了，才以 find 来搜寻呦！为什么呢？因为 whereis 与 locate 是利用数据库来搜寻数据，所以相当的快速，而且并没有实际的搜寻硬盘，比较省时间啦！</FONT> 
<BLOCKQUOTE><FONT face=SimSun color=#000000><B>which&nbsp;&nbsp;</B> 查看可执行档案的位置</FONT> <BR><FONT face=SimSun color=#000000><B>whereis</B> 查看档案的位置</FONT> <BR><FONT face=SimSun color=#000000><B>locate&nbsp;</B> 配合数据库查看档案位置</FONT> <BR><FONT face=SimSun color=#000000><B>find</B>&nbsp;&nbsp;&nbsp; 实际搜寻硬盘去查询文件名称</FONT></BLOCKQUOTE>
<BLOCKQUOTE>
<HR width="100%">

<LI><A name=which></A><B><FONT face=SimSun color=#000099>which</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>which&nbsp; [文件名称]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>which passwd</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>/usr/bin/passwd</FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR><FONT color=#000000>which 的基本功能是『藉由 PATH 这个环境变量的内容，去该路径内寻找可执行文件』，所以基本的功能在于『</FONT><B><FONT color=#000066>寻找执行档</FONT></B><FONT color=#000000>』！</FONT> <BR><FONT color=#000000>　</FONT> <BR>
<HR width="100%">

<LI><A name=whereis></A><B><FONT face=SimSun color=#000099>whereis</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>whereis [-bmsu] [目录名称]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-b&nbsp;&nbsp;&nbsp; :只找 binary 的档案</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-m&nbsp;&nbsp;&nbsp; :只找在说明文件 manual 路径下的档案</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-s&nbsp;&nbsp;&nbsp; :只找 source 来源档案</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>-u&nbsp;&nbsp;&nbsp; :没有说明档的档案！</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>whereis passwd</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>passwd: /usr/bin/passwd /etc/passwd /usr/share/man/man1/passwd.1.bz2</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>将 passwd 相关字眼的档案或目录都列出来！</FONT> 
<P><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>whereis -b passwd</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>passwd: /usr/bin/passwd /etc/passwd</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>仅列出binary 档案！</FONT> 
<P><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>whereis -m passwd</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>passwd: /usr/share/man/man1/passwd.1.bz2</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>仅搜寻 man page 所在的目录！</FONT></P></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>如果使用 find 太麻烦，而且时间花用的很大！（因为如果你的硬盘比较老旧的话，嘿嘿！有的等的！）这个时候 whereis 就相当的好用了！另外， whereis 可以加入参数来找寻相关的资料，例如如果你是要找可执行档（ binary ）那么加上 -b 就可以啦！例如上面的范例针对 passwd 这支程序来说明！如果不加任何参数的话，那么就将所有的数据列出来！那么 whereis 到底是使用什么咚咚呢？为何搜寻的速度会比 find 快这么多？！其实那也没有什么！这是因为 Linux 系统会将系统内的所有档案都记录在一个数据库档案里面，而当使用 whereis 或者是底下要说的 locate 时，都会以此数据库档案的内容为准，因此，有的时后你还会发现使用这两个执行档时，会找到已经被杀掉的档案！这就是因为他是一个『数据库』档案呀！另外，基本上 Linux 每天会针对 Linux 主机进行 updatedb （就是那一个数据库档案！）的动作，你可以在 /etc/cron.weekly/slocate.cron 这个档案找到相关的机制呦！当然，也可以直接使用 /usr/bin/updatedb 来更新数据库档案呢！ <BR>　 <BR>
<HR width="100%">

<LI><A name=locate></A><B><FONT face=SimSun color=#000099>locate</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>locate [目录名称]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>locate root</FONT></FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>……一大堆跟 root 有关字眼的档案都出来了 @_@</FONT> 
<P><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>updatedb</FONT><FONT color=#ffffff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </FONT><FONT color=#ff9900>&lt;==立刻更新数据库</FONT></FONT></P></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>locate 的使用方式就更简单了！直接键入你要找的档名即可！但是，这个东西还是有使用上的限制呦！为什么呢？您会发现使用 locate 来寻找数据的时候特别的快，这是因为 locate 寻找的数据是由『已建立的数据库 /var/lib/slocate』里面的数据所搜寻到的，所以不用直接在去硬盘当中存取数据，呵呵！当然是很快速！那么有什么限制呢？就是因为他是经由数据库来搜寻的，而数据库的建立预设是在每个礼拜执行一次，所以当您新建立起来的档案，却还在数据库更新之前搜寻该档案，那么 locate 会告诉您『找不到！』呵呵！因为必须要更新数据库呀！ <BR>　 <BR>那么我到底要建立哪些数据库呢？是否全部都要建立？似乎不需要，这个时候，你可以自己选择需要建立档案数据库的目录呢！在 /etc/updatedb.conf 这个内即可设定了！ <BR>　 
<TABLE cols=1 width=550 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test root]# </FONT><FONT color=#ffff00>more /etc/updatedb.conf</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>## Linux-Mandrake configuration.</FONT> <BR><FONT face=SimSun color=#ffffff size=-1># 由何处开始查询数据，当然是由根目录啦！所以填入 / 即可</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>FROM="/"</FONT> 
<P><FONT face=SimSun color=#ffffff size=-1># 哪些目录不想要建立档案搜寻数据，呵呵！就是那些不要的数据嘛！</FONT> <BR><FONT face=SimSun color=#ffffff size=-1># 忘记的话，记得回上一章去看看内容，就知道为何如此设定了！</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>PRUNEPATHS="/proc,/tmp,/var/tmp,/usr/tmp,/net,/afs,/mnt"</FONT> 
<P><FONT face=SimSun color=#ffffff size=-1># 安全等级</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>#&nbsp;&nbsp; 0 代表关闭安全检验，速度上面较快速，但较不安全；</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>#&nbsp;&nbsp; 1 启动安全简易，这是系统的默认值；</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>SECURITY="1"</FONT> 
<P><FONT face=SimSun color=#ffffff size=-1># 查询的时候是否要由屏幕输出？当然不要，否则多麻烦?</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>VERBOSE="NO"</FONT> 
<P><FONT face=SimSun color=#ffffff size=-1># 数据库所在处！这是默认值，不要随意移动，否则会找不到！</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>DATABASE="/var/lib/slocate/slocate.db"</FONT> 
<P><FONT face=SimSun color=#ffffff size=-1># 哪些档案系统我们也不搜寻建立？就是光盘啦、非 Linux 的档案格式啦，</FONT> <BR><FONT face=SimSun color=#ffffff size=-1># 我们都不要进行搜寻信息的建立啦！</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>PRUNEFS="nfs,smbfs,ncpfs,proc,devpts,supermount,vfat,iso9660,udf,usbdevfs,devfs"</FONT></P></TD></TR></TBODY></TABLE><FONT color=#ff0000>　</FONT> <BR>
<HR width="100%">

<LI><A name=find></A><B><FONT face=SimSun color=#000099>find</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=750 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]#</FONT><FONT color=#ffff00> find [路径] [参数]</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>1. 时间：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>&nbsp;&nbsp; -atime n&nbsp;&nbsp;&nbsp; :在 n*24 小时内被 access 即存取过的档案列出来！</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>&nbsp;&nbsp; -ctime n&nbsp;&nbsp;&nbsp; :在 n*24 小时内被 changed 即改变、新增的档案或目录印出</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>&nbsp;&nbsp; -mtime n&nbsp;&nbsp;&nbsp; :在 n*24 小时内被 modified 即修改过的档案印出</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>&nbsp;&nbsp; -newer file :比 file 还要新的档案就列出来！</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>2. 使用名称：</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>&nbsp;&nbsp; -gid n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :寻找 群组 ID 为 n 的档案</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>&nbsp;&nbsp; -group name :寻找群组名称为 name 的档案</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>&nbsp;&nbsp; -uid n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :寻找拥有者 ID 为 n 的档案</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>&nbsp;&nbsp; -user name&nbsp; :寻找使用者名称为 name 的档案</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>&nbsp;&nbsp; -name file&nbsp; :寻找档名为 file 的文件名称（可以使用万用字符）</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>&nbsp;&nbsp; -type type&nbsp; :寻找档案属性为 type 的档案，type 包含了 b, c, d, p, l, s，</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这些与前一章的属性相同！例如 l 为 Link 而 d 为路径之意！</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>find / -name testing&nbsp;</FONT><FONT color=#ffffff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#ff9900>&nbsp;&nbsp;&nbsp;&nbsp; &lt;==寻找档名为 testing&nbsp;</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>find / -name 'test*'</FONT><FONT color=#ffffff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#ff9900>&nbsp; &lt;==寻找档名包含 test 的！</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>find . -ctime 1&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#ffffff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#ff9900>&nbsp;&nbsp; &lt;==寻找目前目录下一天内新增的目录或档案</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>find /home/test -newer .bashrc</FONT><FONT color=#ff9900>&nbsp; &lt;==寻找 /home/test 目录下比 .bashrc 还要新的档案</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>find /home -user test</FONT><FONT color=#ffffff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#ff9900> &lt;==寻找 /home 底下拥有者为 test 的档案</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>find /dev -type b&nbsp;</FONT><FONT color=#ffffff>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</FONT><FONT color=#ff9900>&nbsp;&nbsp; &lt;==寻找 /dev 这个目录下，档案属性为 b 的档案</FONT></FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR>如果你要寻找一个档案的话，那么使用 find 会是一个不错的主意！他可以根据不同的参数来给予档案的搜寻功能！例如你要寻找一个档名为 httpd.conf 的档案，你知道他应该是在 /etc 底下，那么就可以使用『<FONT face=SimSun color=#000099 size=-1> find /etc -name httpd.conf</FONT> 』噜！那如果你记得有一个档案档名包含了 httpd ，但是不知道全名怎办？！呵呵，就用万用字符 ＊ 吧，如上以：『 <FONT face=SimSun color=#000099 size=-1>find /etc -name '*httpd*' </FONT>』就可将档名含有 httpd 的档案都列出来！不过，由于 find 在寻找数据的时后相当的耗硬盘！所以没事情不要使用 find 啦！有更棒的指令可以取代呦！那就是 <A href="#whereis">whereis</A> 与 <A href="#locate">locate</A> ！！</LI></BLOCKQUOTE></BLOCKQUOTE>
<HR width="100%">
<A name=suid_sgid_sticky></A><FONT color=#000099 size=+1>SetUID, SetGID, Sticky bit 与 file 指令</FONT> 
<UL>
<LI><B><FONT color=#000099>SUID 与 SGID：</FONT></B> <BR><FONT color=#000000>其实，说到这里之前，应该先说明一下 UID (user ID)与 GID (Groupt ID)的！基本上， Linux 认得的账号只是一堆数字而已！而由于我们每个档案中同时含有『使用者』与『使用者群组』的属性，因此，就有所谓的 UID 与 GID ！ UID 代表我们的使用者『代号』而 GID 则是群组的『代号』。你可以使用『 more /etc/passwd 』这个指令来看一下你的系统当中的所有账号，然后你会注意到每行的第三、四个字段（以 : 分隔）为数字，那个就是 UID 与 GID 了，您更会注意到的是， root 的 UID 与 GID 都是 0 ！因此，当你建立了一个账号，而你将该账号的 UID 与 GID 都改为零，呵呵！那个账号的使用者就具有 root 的身份！</FONT> <BR><FONT color=#000000>　</FONT> <BR><FONT color=#000000>那么什么是 SUID 与 SGID 呢？！在说明之前我们先来以一般身份使用者 ( 还记得安装的时候曾经增加一个 test 账号的一般身份使用者吗？对啦！用他！然后呢？直接在键盘上按下 [Alt] + [Ctrl] + [F2] 到第二个终端机呀！) test 的身份登入，再来看一个档案的内容：</FONT> <BR><FONT color=#000000>　</FONT> 
<TABLE cols=1 width=550 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[test@test test]$ </FONT><FONT color=#ffff00>ls -l /usr/bin/passwd&nbsp;</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-r-s--x--x&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13476 Aug&nbsp; 7&nbsp; 2001 /usr/bin/passwd&nbsp;</FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>　</FONT> <BR><FONT color=#000000>看到了 /usr/bin/passwd 档案的前面属性了吗？怎么会有 s 的属性在原本的 x 呀！？那个就是所谓的 SUID 了！如果是『 -r-xr-s--x 』时，那么 s 就成为所谓的 SGID 了！</FONT> <BR><FONT color=#000000>　</FONT> 
<UL><FONT color=#000000>『</FONT><B><FONT color=#000066>当一个档案具有 SUID 的时候，同时 other 的群组具有可执行的权限，那么当 others 群组执行该程序的时候， other 将拥有该档案的 owner 的权限！</FONT></B><FONT color=#000000>』。</FONT></UL><FONT color=#000000>　　</FONT> 
<TABLE cols=1 width=550 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[test@test test]$ </FONT><FONT color=#ffff00>ls -l /usr/bin/passwd /etc/shadow&nbsp;</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-r-s--x--x&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13476 Aug&nbsp; 7&nbsp; 2001 /usr/bin/passwd&nbsp;</FONT> <BR><FONT face=SimSun color=#ffffff size=-1>-rw-------&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2423 Jun 25 14:29 /etc/shadow&nbsp;</FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>　</FONT> <BR><FONT color=#000000>我们以账号的密码文件来说明好了！注意上面的范例！可以看到的是， /etc/shadow 的权限是『</FONT><B><FONT color=#000066>只有 root 才能存取</FONT></B><FONT color=#000000>』呦！那么你会不会觉得很奇怪？明明我的一般使用者可以自己修改密码呀！对不对？那么修改密码一定跟 /etc/shadow 这个档案有关，那么怎么回事呀！？使用者是如何修改 /etc/shadow 这个档案的呢？嗯！没错！就是使用 SUID 的功能啦！上面的例子说明了， /usr/bin/passwd 这个档案具有 SUID 的属性，那么当使用者使用 /usr/bin/passwd 这个执行档时，在执行 pass word 修改的期间就具有 /usr/bin/passwd 这个档案的拥有者 root 的所属权限！所以，所以当一般使用者执行 passwd 的时候，将具有 root 的权限，所以他们也可以更改 /etc/shadow 的内容！那么由此也可以知道，由于这个 Set UID ( SUID ) 的主要功能是在『</FONT><FONT color=#000066>某个档案执行的期间具有档案拥有者的权限</FONT><FONT color=#000000>』，因此， s 就是替代上面提到的 x 这个可执行的位置！那万一该档案并没有 x 的属性呢？哈哈！问的好！那么该档案的属性就会将小写的 s 变成大写的 S 啦！ ( 这里即使暂时不了解也没有关系，等到过一阵子再回来看一看，你就会了解啦！ )</FONT> <BR><FONT color=#000000>　</FONT> <BR><FONT color=#000000>不过，由此也知道 SUID 与 SGID 的问题所在，没错！</FONT><B><FONT color=#000066>就是太不安全了</FONT></B><FONT color=#000000>！如果你有一个档案具有 root 的权限，那么当开启了 SUID 的时候，嘿嘿！够你瞧的了！！因此上，在变更一个档案成为具有 SUID 或 SGID 的情况时，必须要特别小心呢！知道乎！？</FONT> <BR><FONT color=#000000>　</FONT> 
<LI><B><FONT color=#000099>Sticky bit：</FONT></B> <BR><FONT color=#000000>OK！接着下来，我们要来看一下，既然有 SUID 与 SGID ，那么为什么没有在最末位出现 s 取代 x 呢？呵呵！这当然没有必要啦！因为那是属于 others 的权限，你的档案如果是任何人皆可执行的话，那么本来他们就具有权限啦！干嘛还要设定 s 的属性！？不过，这里却真的有另一个属性出现了，那就是 Sticky bit 的属性 ( t ) ！这个属性的最大用处在于『</FONT><B><FONT color=#000066>具有 sticky bit 属性的该”目录”下的档案，其档案或目录只有档案拥有者及 root 才有权力删除！</FONT></B><FONT color=#000000>』这样是否可以了解了呢？嘿嘿！没错！在我们系统里面本来就预设有一个啦！那就是 /tmp 这个目录！</FONT> <BR><FONT color=#000000>　　</FONT> 
<TABLE cols=1 width=550 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[test@test test]$</FONT><FONT color=#ffff00> ls -l /&nbsp;</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>drwxrwxrwt&nbsp;&nbsp;&nbsp; 2 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4096 Jul 18 13:08 tmp&nbsp;</FONT></TD></TR></TBODY></TABLE><FONT color=#ff0000>　</FONT> <BR><FONT color=#000000>如何，发现了吧！虽然该目录具有所有人皆可擦写的权限，但是确有一个 t 出现了，那就是所谓的 sticky bit ！在该目录里面虽然你可以建立与修改任何档案，但是却仅能删除自己建立的档案呢！除非你是 root ！你可以这样试试看：</FONT> <BR><FONT color=#000000>　</FONT> 
<UL><FONT color=#000000>1. 以 root 登入系统，并且进入 /tmp 当中；</FONT> <BR><FONT color=#000000>2. touch test，并且更改 test 权限成为 777 ；</FONT> <BR><FONT color=#000000>3. 以一般使用者登入，并进入 /tmp；</FONT> <BR><FONT color=#000000>4. 尝试删除 test 这个档案！</FONT></UL><FONT color=#000000>　</FONT> <BR><FONT color=#000000>如何！？发现了吧！！</FONT> <BR>　 
<LI><B><FONT color=#000099>SUID, SGID, Sticky bit 的设定方法：</FONT></B> <BR>前面介绍过 SUID 与 SGID 的功能，那么如何开启档案使成为具有 SUID 与 SGID 的权限呢？！这就需要刚刚的数字更改权限的方法了！现在你应该已经知道数字型态个更改权限方式为『三个数字』的组合，那么如果在这三个数字之前再加上一个数字的话，那最前的面数字就代表这几个属性了！ ( <B><FONT color=#000066>注：通常我们使用 <FONT face=SimSun>chmod xyz filename</FONT> 的方式来设定 filename 的属性时，则是假设没有 SUID, SGID 及 Sticky bit 啦！</FONT></B> ) <BR>　 
<UL>
<LI><FONT face=SimSun color=#000066>4 为 SUID</FONT> 
<LI><FONT face=SimSun color=#000066>2 为 SGID</FONT> 
<LI><FONT face=SimSun color=#000066>1 为 Sticky bit</FONT> </LI></UL>　 <BR>假设要将一个档案属性改为『<FONT face=SimSun color=#000066>-rwsr-xr-x</FONT>』时，由于 s 在使用者权限中，所以是 SUID ，因此，在原先的 755 之前还要加上 4 ，也就是：『<FONT face=SimSun color=#000066> chmod 4755 filename</FONT> 』来设定！此外，还有大 S 与大 T 的产生喔！参考底下的范例啦！ <BR>　 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root@test tmp]# </FONT><FONT color=#ffff00>touch test</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root@test tmp]# </FONT><FONT color=#ffff00>ll</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>total 0</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffff00>-rw-r--r--</FONT><FONT color=#ffffff>&nbsp;&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 Feb&nbsp; 6 23:08 test</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root@test tmp]# </FONT><FONT color=#ffff00>chmod 4755 test</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root@vbird tmp]# </FONT><FONT color=#ffff00>ll</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>total 0</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffff00>-rwsr-xr-x&nbsp;</FONT><FONT color=#ffffff>&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 Feb&nbsp; 6 23:08 test*</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root@test tmp]# </FONT><FONT color=#ffff00>chmod 6755 test</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root@test tmp]# </FONT><FONT color=#ffff00>ll</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>total 0</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffff00>-rwsr-sr-x&nbsp;</FONT><FONT color=#ffffff>&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 Feb&nbsp; 6 23:08 test*</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root@test tmp]# </FONT><FONT color=#ffff00>chmod 1755 test</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root@test tmp]# </FONT><FONT color=#ffff00>ll</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>total 0</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffff00>-rwxr-xr-t&nbsp;</FONT><FONT color=#ffffff>&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 Feb&nbsp; 6 23:08 test*</FONT></FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>上面的三个例子应该都很好说明啊！就是直接将 x 以 s 或者是 t 来取代就是了！也就是分别为 SUID, SGID 及 sticky bit 的设定方法啦！</FONT> 
<P><FONT face=SimSun size=-1><FONT color=#ffffff>[root@test tmp]# </FONT><FONT color=#ffff00>chmod 7666 test</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root@test tmp]# </FONT><FONT color=#ffff00>ll</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>total 0</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffff00>-rwSrwSrwT&nbsp;</FONT><FONT color=#ffffff>&nbsp;&nbsp; 1 root&nbsp;&nbsp;&nbsp;&nbsp; root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0 Feb&nbsp; 6 23:08 test</FONT></FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>这个例子就要特别小心啦！怎么会出现大写的 S 与 T 呢？不都是小写的吗？因为 s 与 t 都是取代 x 这个参数的，但是你有没有发现阿，我们是下达 7666 喔！也就是说， user, group 以及 others 都没有 x 这个可执行的标志 ( 因为 666 嘛！ )，所以，这个 S, T 代表的就是『空的』啦！怎么说？ SUID 是表示『该档案在执行的时候，具有档案拥有者的权限』，但是档案拥有者都无法执行了，哪里来的权限给其它人使用？当然就是空的啦！ ^_^</FONT></P></TD></TR></TBODY></TABLE>　 
<LI><B><FONT color=#000099>file</FONT></B> <BR><FONT color=#ff0000>语法</FONT>： 
<TABLE cols=1 width=500 bgColor=#000000 border=1>
<TBODY>
<TR>
<TD><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root ]# </FONT><FONT color=#ffff00>file [n名]&nbsp;</FONT></FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>参数说明：&nbsp;</FONT> <BR><FONT face=SimSun color=#ffffcc size=-1>范例：&nbsp;</FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>file ~/.bashrc&nbsp;</FONT></FONT> <BR><FONT face=SimSun size=-1><FONT color=#ffffff>/root/.bashrc: ASCII text&nbsp;</FONT><FONT color=#ff9900> &lt;==表示这个档案是 ASCII 纯文字文件&nbsp;</FONT></FONT> 
<P><FONT face=SimSun size=-1><FONT color=#ffffff>[root @test /root]# </FONT><FONT color=#ffff00>file /usr/bin/passwd</FONT></FONT> <BR><FONT face=SimSun color=#ffffff size=-1>/usr/bin/passwd: setuid ELF 32-bit LSB executable, Intel 80386, version 1, dynamically linked (uses shared libs), stripped</FONT> <BR><FONT face=SimSun color=#ff9900 size=-1>嘿！还可以看到是否具有 SUID 的权限呢！</FONT></P></TD></TR></TBODY></TABLE><FONT color=#ff0000>说明</FONT><FONT color=#000000>：</FONT> <BR><FONT color=#000000>file 这个指令也蛮好用的，可以用来查看这个档案的类型，例如 ASCII 格式档，或者是 binary 的档案等等，还可以用来观看档案是否被加入 SUID 等等的信息！并且，也同时提供了是否有使用动态函式库的信息！相当的好用！</FONT></LI></UL>
<HR width="100%">
<A name=FAQ></A><FONT color=#000099 size=+1>本章习题练习 ( 要看答案请将鼠标移动到『答：』底下的空白处，按下左键圈选空白处即可察看 )</FONT> 
<UL>
<LI><FONT color=#000000>什么是绝对路径与相对路径</FONT> <BR><FONT color=#000000>答：</FONT> 
<UL><FONT color=#ffffff>绝对路径的写法为由 / 开始写，至于相对路径则不由 / 开始写！</FONT></UL></LI></UL>
<UL>
<LI><FONT color=#000000>如何更改一个目录的名称？例如由 /home/test 变为 /home/test2</FONT> <BR><FONT color=#000000>答：</FONT> 
<UL><FONT color=#ffffff>mv /home/test /home/test2</FONT></UL></LI></UL>
<UL>
<LI><FONT color=#000000>PATH 这个环境变量的意义？</FONT> <BR><FONT color=#000000>答：</FONT> 
<UL><FONT color=#ffffff>这个是用来指定执行档执行的时候，档案搜寻的目录路径。</FONT></UL></LI></UL>
<UL>
<LI><FONT color=#000000>umask 有什么用处与优点？</FONT> <BR><FONT color=#000000>答：</FONT> 
<UL><FONT color=#ffffff>umask 可以拿掉一些属性，因此，适当的定义 umask 有助于系统的安全，因为他可以用来建立预设的目录或档案的权限。</FONT></UL></LI></UL>
<UL>
<LI><FONT color=#000000>当一个使用者的 umask 分别为 033 与 044 他所建立的档案与目录的权限为何？</FONT> <BR><FONT color=#000000>答：</FONT> 
<UL><FONT color=#ffffff>在 umask 为 033 时，则预设是拿掉 group 与 other 的 w(2)x(1) 权限，因此权限就成为『档案 Crw-r--r-- ， 目录 drwxr--r-- 』而当 umask 044 时，则拿掉 r 的属性，因此就成为『档案 -rw--w--w-，目录 drwx-wx-wx』</FONT></UL></LI></UL>
<UL>
<LI><FONT color=#000000>什么是 SUID ？</FONT> <BR><FONT color=#000000>答：</FONT> 
<UL><FONT color=#ffffff>当一个指令具有 SUID 的功能时，则当其它人使用这个指令时，该程序将具有指令拥有者的权限。</FONT></UL></LI></UL>
<UL>
<LI><FONT color=#000000>当我要查询 /usr/bin/passwd 这个档案的一些属性时，可以使用什么指令来查询？</FONT> <BR><FONT color=#000000>答：</FONT> 
<UL><FONT color=#ffffff>ls Cal, file, lsattr</FONT></UL></LI></UL>
<UL>
<LI><FONT color=#000000>尝试用 find 找出目前 linux 系统中，所有具有 SUID 的档案有哪些？</FONT> <BR><FONT color=#000000>答：</FONT> 
<UL><FONT color=#ffffff>find / -type f Cperm C04000 -print</FONT></UL></LI></UL>
<HR width="100%">
<FONT face=SimSun color=#000066 size=-1>2002/06/26：第一次完成</FONT> <BR><FONT face=SimSun color=#000066 size=-1>2003/02/06：重新编排与加入 FAQ</FONT> <BR><FONT face=SimSun color=#000066 size=-1>2003/02/07：加入 <A href="#basename">basename</A> 与 <A href="#dirname">dirname</A> 的说明</FONT> <BR>
<HR width="100%">
<FONT face=SimSun color=#3333ff size=-1>2002/ 03/13以来统计人数</FONT> <BR>
<HR width="100%">

<CENTER><A href="http://linux.vbird.org/" target=_top><IMG height=25 src="61_files/VBirdTitle2[10].jpg" width=90 border=0 NOSAVE></A> <A href="http://linux.vbird.org/linux_basic"><IMG height=25 src="39_files/icon_system[3].gif" width=90 border=0 NOSAVE></A> <A href="http://linux.vbird.org/linux_server"><IMG height=25 src="55_files/icon_server[13].gif" width=90 border=0 NOSAVE></A> <A href="http://linux.vbird.org/linux_security"><IMG height=25 src="71_files/icon_security[10].jpg" width=90 border=0 NOSAVE></A> <A href="http://phorum.vbird.org/" target=_blank><IMG height=25 src="60_files/icon_forums[10].gif" width=90 border=0 NOSAVE></A> <A href="http://linux.vbird.org/adsl"><IMG height=25 src="50_files/icon_adsl[13].gif" width=90 border=0 NOSAVE></A> <BR><FONT color=#000066 size=-1>Designed by <A href="mailto:vbird@tsai.adsldns.org">VBird</A> during 2001-2003.&nbsp; Aerosol Lab.</FONT></CENTER></BODY>