
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>bytes - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>

<div id="topbar"><div class="container wide">

</div></div>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package bytes</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "bytes"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
				<dd><a href="#examples">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package bytes implements functions for the manipulation of byte slices.
It is analogous to the facilities of the strings package.
</p>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
				<dd><a href="#constants">Constants</a></dd>
			
			
				<dd><a href="#variables">Variables</a></dd>
			
			
				
				<dd><a href="#Compare">func Compare(a, b []byte) int</a></dd>
			
				
				<dd><a href="#Contains">func Contains(b, subslice []byte) bool</a></dd>
			
				
				<dd><a href="#Count">func Count(s, sep []byte) int</a></dd>
			
				
				<dd><a href="#Equal">func Equal(a, b []byte) bool</a></dd>
			
				
				<dd><a href="#EqualFold">func EqualFold(s, t []byte) bool</a></dd>
			
				
				<dd><a href="#Fields">func Fields(s []byte) [][]byte</a></dd>
			
				
				<dd><a href="#FieldsFunc">func FieldsFunc(s []byte, f func(rune) bool) [][]byte</a></dd>
			
				
				<dd><a href="#HasPrefix">func HasPrefix(s, prefix []byte) bool</a></dd>
			
				
				<dd><a href="#HasSuffix">func HasSuffix(s, suffix []byte) bool</a></dd>
			
				
				<dd><a href="#Index">func Index(s, sep []byte) int</a></dd>
			
				
				<dd><a href="#IndexAny">func IndexAny(s []byte, chars string) int</a></dd>
			
				
				<dd><a href="#IndexByte">func IndexByte(s []byte, c byte) int</a></dd>
			
				
				<dd><a href="#IndexFunc">func IndexFunc(s []byte, f func(r rune) bool) int</a></dd>
			
				
				<dd><a href="#IndexRune">func IndexRune(s []byte, r rune) int</a></dd>
			
				
				<dd><a href="#Join">func Join(a [][]byte, sep []byte) []byte</a></dd>
			
				
				<dd><a href="#LastIndex">func LastIndex(s, sep []byte) int</a></dd>
			
				
				<dd><a href="#LastIndexAny">func LastIndexAny(s []byte, chars string) int</a></dd>
			
				
				<dd><a href="#LastIndexFunc">func LastIndexFunc(s []byte, f func(r rune) bool) int</a></dd>
			
				
				<dd><a href="#Map">func Map(mapping func(r rune) rune, s []byte) []byte</a></dd>
			
				
				<dd><a href="#Repeat">func Repeat(b []byte, count int) []byte</a></dd>
			
				
				<dd><a href="#Replace">func Replace(s, old, new []byte, n int) []byte</a></dd>
			
				
				<dd><a href="#Runes">func Runes(s []byte) []rune</a></dd>
			
				
				<dd><a href="#Split">func Split(s, sep []byte) [][]byte</a></dd>
			
				
				<dd><a href="#SplitAfter">func SplitAfter(s, sep []byte) [][]byte</a></dd>
			
				
				<dd><a href="#SplitAfterN">func SplitAfterN(s, sep []byte, n int) [][]byte</a></dd>
			
				
				<dd><a href="#SplitN">func SplitN(s, sep []byte, n int) [][]byte</a></dd>
			
				
				<dd><a href="#Title">func Title(s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToLower">func ToLower(s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToLowerSpecial">func ToLowerSpecial(_case unicode.SpecialCase, s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToTitle">func ToTitle(s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToTitleSpecial">func ToTitleSpecial(_case unicode.SpecialCase, s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToUpper">func ToUpper(s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToUpperSpecial">func ToUpperSpecial(_case unicode.SpecialCase, s []byte) []byte</a></dd>
			
				
				<dd><a href="#Trim">func Trim(s []byte, cutset string) []byte</a></dd>
			
				
				<dd><a href="#TrimFunc">func TrimFunc(s []byte, f func(r rune) bool) []byte</a></dd>
			
				
				<dd><a href="#TrimLeft">func TrimLeft(s []byte, cutset string) []byte</a></dd>
			
				
				<dd><a href="#TrimLeftFunc">func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</a></dd>
			
				
				<dd><a href="#TrimRight">func TrimRight(s []byte, cutset string) []byte</a></dd>
			
				
				<dd><a href="#TrimRightFunc">func TrimRightFunc(s []byte, f func(r rune) bool) []byte</a></dd>
			
				
				<dd><a href="#TrimSpace">func TrimSpace(s []byte) []byte</a></dd>
			
			
				
				<dd><a href="#Buffer">type Buffer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewBuffer">func NewBuffer(buf []byte) *Buffer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewBufferString">func NewBufferString(s string) *Buffer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Bytes">func (b *Buffer) Bytes() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Len">func (b *Buffer) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Next">func (b *Buffer) Next(n int) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Read">func (b *Buffer) Read(p []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.ReadByte">func (b *Buffer) ReadByte() (c byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.ReadBytes">func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.ReadFrom">func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.ReadRune">func (b *Buffer) ReadRune() (r rune, size int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.ReadString">func (b *Buffer) ReadString(delim byte) (line string, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Reset">func (b *Buffer) Reset()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.String">func (b *Buffer) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Truncate">func (b *Buffer) Truncate(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.UnreadByte">func (b *Buffer) UnreadByte() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.UnreadRune">func (b *Buffer) UnreadRune() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Write">func (b *Buffer) Write(p []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.WriteByte">func (b *Buffer) WriteByte(c byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.WriteRune">func (b *Buffer) WriteRune(r rune) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.WriteString">func (b *Buffer) WriteString(s string) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.WriteTo">func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</a></dd>
				
			
				
				<dd><a href="#Reader">type Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReader">func NewReader(b []byte) *Reader</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Len">func (r *Reader) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Read">func (r *Reader) Read(b []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadAt">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadByte">func (r *Reader) ReadByte() (b byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadRune">func (r *Reader) ReadRune() (ch rune, size int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Seek">func (r *Reader) Seek(offset int64, whence int) (int64, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.UnreadByte">func (r *Reader) UnreadByte() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.UnreadRune">func (r *Reader) UnreadRune() error</a></dd>
				
			
			
				<dd><a href="#bugs">Bugs</a></dd>
			
		</dl>

		
			<h4 id="examples">Examples</h4>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Buffer">Buffer</a></dd>
			
			<dd><a class="exampleLink" href="#example_Buffer_reader">Buffer (Reader)</a></dd>
			
			</dl>
		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/bytes/buffer.htm">buffer.go</a>
			
				<a href="src/pkg/bytes/bytes.htm">bytes.go</a>
			
				<a href="src/pkg/bytes/bytes_decl.htm">bytes_decl.go</a>
			
				<a href="src/pkg/bytes/reader.htm">reader.go</a>
			
			</span>
			</p>
		
	
		
			<h2 id="constants">Constants</h2>
			
				<pre>const MinRead = 512</pre>
				<p>
MinRead is the minimum slice size passed to a Read call by
Buffer.ReadFrom.  As long as the Buffer has at least MinRead bytes beyond
what is required to hold the contents of r, ReadFrom will not grow the
underlying buffer.
</p>

			
		
		
			<h2 id="variables">Variables</h2>
			
				<pre>var ErrTooLarge = errors.New(&#34;bytes.Buffer: too large&#34;)</pre>
				<p>
ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer.
</p>

			
		
		
			
			
			<h2 id="Compare">func <a href="src/pkg/bytes/bytes.htm#L7">Compare</a></h2>
			<pre>func Compare(a, b []byte) int</pre>
			<p>
Compare returns an integer comparing the two byte arrays lexicographically.
The result will be 0 if a==b, -1 if a &lt; b, and +1 if a &gt; b
A nil argument is equivalent to an empty slice.
</p>

			
		
			
			
			<h2 id="Contains">func <a href="src/pkg/bytes/bytes.htm#L101">Contains</a></h2>
			<pre>func Contains(b, subslice []byte) bool</pre>
			<p>
Contains returns whether subslice is within b.
</p>

			
		
			
			
			<h2 id="Count">func <a href="src/pkg/bytes/bytes.htm#L70">Count</a></h2>
			<pre>func Count(s, sep []byte) int</pre>
			<p>
Count counts the number of non-overlapping instances of sep in s.
</p>

			
		
			
			
			<h2 id="Equal">func <a href="src/pkg/bytes/bytes.htm#L32">Equal</a></h2>
			<pre>func Equal(a, b []byte) bool</pre>
			<p>
Equal returns a boolean reporting whether a == b.
A nil argument is equivalent to an empty slice.
</p>

			
		
			
			
			<h2 id="EqualFold">func <a href="src/pkg/bytes/bytes.htm#L645">EqualFold</a></h2>
			<pre>func EqualFold(s, t []byte) bool</pre>
			<p>
EqualFold reports whether s and t, interpreted as UTF-8 strings,
are equal under Unicode case-folding.
</p>

			
		
			
			
			<h2 id="Fields">func <a href="src/pkg/bytes/bytes.htm#L282">Fields</a></h2>
			<pre>func Fields(s []byte) [][]byte</pre>
			<p>
Fields splits the array s around each instance of one or more consecutive white space
characters, returning a slice of subarrays of s or an empty list if s contains only white space.
</p>

			
		
			
			
			<h2 id="FieldsFunc">func <a href="src/pkg/bytes/bytes.htm#L290">FieldsFunc</a></h2>
			<pre>func FieldsFunc(s []byte, f func(rune) bool) [][]byte</pre>
			<p>
FieldsFunc interprets s as a sequence of UTF-8-encoded Unicode code points.
It splits the array s at each run of code points c satisfying f(c) and
returns a slice of subarrays of s.  If no code points in s satisfy f(c), an
empty slice is returned.
</p>

			
		
			
			
			<h2 id="HasPrefix">func <a href="src/pkg/bytes/bytes.htm#L350">HasPrefix</a></h2>
			<pre>func HasPrefix(s, prefix []byte) bool</pre>
			<p>
HasPrefix tests whether the byte array s begins with prefix.
</p>

			
		
			
			
			<h2 id="HasSuffix">func <a href="src/pkg/bytes/bytes.htm#L355">HasSuffix</a></h2>
			<pre>func HasSuffix(s, suffix []byte) bool</pre>
			<p>
HasSuffix tests whether the byte array s ends with suffix.
</p>

			
		
			
			
			<h2 id="Index">func <a href="src/pkg/bytes/bytes.htm#L106">Index</a></h2>
			<pre>func Index(s, sep []byte) int</pre>
			<p>
Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.
</p>

			
		
			
			
			<h2 id="IndexAny">func <a href="src/pkg/bytes/bytes.htm#L178">IndexAny</a></h2>
			<pre>func IndexAny(s []byte, chars string) int</pre>
			<p>
IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.
It returns the byte index of the first occurrence in s of any of the Unicode
code points in chars.  It returns -1 if chars is empty or if there is no code
point in common.
</p>

			
		
			
			
			<h2 id="IndexByte">func <a href="src/pkg/bytes/bytes_decl.htm#L1">IndexByte</a></h2>
			<pre>func IndexByte(s []byte, c byte) int</pre>
			<p>
IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.
</p>

			
		
			
			
			<h2 id="IndexFunc">func <a href="src/pkg/bytes/bytes.htm#L510">IndexFunc</a></h2>
			<pre>func IndexFunc(s []byte, f func(r rune) bool) int</pre>
			<p>
IndexFunc interprets s as a sequence of UTF-8-encoded Unicode code points.
It returns the byte index in s of the first Unicode
code point satisfying f(c), or -1 if none do.
</p>

			
		
			
			
			<h2 id="IndexRune">func <a href="src/pkg/bytes/bytes.htm#L163">IndexRune</a></h2>
			<pre>func IndexRune(s []byte, r rune) int</pre>
			<p>
IndexRune interprets s as a sequence of UTF-8-encoded Unicode code points.
It returns the byte index of the first occurrence in s of the given rune.
It returns -1 if rune is not present in s.
</p>

			
		
			
			
			<h2 id="Join">func <a href="src/pkg/bytes/bytes.htm#L328">Join</a></h2>
			<pre>func Join(a [][]byte, sep []byte) []byte</pre>
			<p>
Join concatenates the elements of a to create a single byte array.   The separator
sep is placed between elements in the resulting array.
</p>

			
		
			
			
			<h2 id="LastIndex">func <a href="src/pkg/bytes/bytes.htm#L146">LastIndex</a></h2>
			<pre>func LastIndex(s, sep []byte) int</pre>
			<p>
LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.
</p>

			
		
			
			
			<h2 id="LastIndexAny">func <a href="src/pkg/bytes/bytes.htm#L203">LastIndexAny</a></h2>
			<pre>func LastIndexAny(s []byte, chars string) int</pre>
			<p>
LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code
points.  It returns the byte index of the last occurrence in s of any of
the Unicode code points in chars.  It returns -1 if chars is empty or if
there is no code point in common.
</p>

			
		
			
			
			<h2 id="LastIndexFunc">func <a href="src/pkg/bytes/bytes.htm#L517">LastIndexFunc</a></h2>
			<pre>func LastIndexFunc(s []byte, f func(r rune) bool) int</pre>
			<p>
LastIndexFunc interprets s as a sequence of UTF-8-encoded Unicode code points.
It returns the byte index in s of the last Unicode
code point satisfying f(c), or -1 if none do.
</p>

			
		
			
			
			<h2 id="Map">func <a href="src/pkg/bytes/bytes.htm#L363">Map</a></h2>
			<pre>func Map(mapping func(r rune) rune, s []byte) []byte</pre>
			<p>
Map returns a copy of the byte array s with all its characters modified
according to the mapping function. If mapping returns a negative value, the character is
dropped from the string with no replacement.  The characters in s and the
output are interpreted as UTF-8-encoded Unicode code points.
</p>

			
		
			
			
			<h2 id="Repeat">func <a href="src/pkg/bytes/bytes.htm#L393">Repeat</a></h2>
			<pre>func Repeat(b []byte, count int) []byte</pre>
			<p>
Repeat returns a new byte slice consisting of count copies of b.
</p>

			
		
			
			
			<h2 id="Replace">func <a href="src/pkg/bytes/bytes.htm#L605">Replace</a></h2>
			<pre>func Replace(s, old, new []byte, n int) []byte</pre>
			<p>
Replace returns a copy of the slice s with the first n
non-overlapping instances of old replaced by new.
If n &lt; 0, there is no limit on the number of replacements.
</p>

			
		
			
			
			<h2 id="Runes">func <a href="src/pkg/bytes/bytes.htm#L590">Runes</a></h2>
			<pre>func Runes(s []byte) []rune</pre>
			<p>
Runes returns a slice of runes (Unicode code points) equivalent to s.
</p>

			
		
			
			
			<h2 id="Split">func <a href="src/pkg/bytes/bytes.htm#L270">Split</a></h2>
			<pre>func Split(s, sep []byte) [][]byte</pre>
			<p>
Split slices s into all subslices separated by sep and returns a slice of
the subslices between those separators.
If sep is empty, Split splits after each UTF-8 sequence.
It is equivalent to SplitN with a count of -1.
</p>

			
		
			
			
			<h2 id="SplitAfter">func <a href="src/pkg/bytes/bytes.htm#L276">SplitAfter</a></h2>
			<pre>func SplitAfter(s, sep []byte) [][]byte</pre>
			<p>
SplitAfter slices s into all subslices after each instance of sep and
returns a slice of those subslices.
If sep is empty, SplitAfter splits after each UTF-8 sequence.
It is equivalent to SplitAfterN with a count of -1.
</p>

			
		
			
			
			<h2 id="SplitAfterN">func <a href="src/pkg/bytes/bytes.htm#L262">SplitAfterN</a></h2>
			<pre>func SplitAfterN(s, sep []byte, n int) [][]byte</pre>
			<p>
SplitAfterN slices s into subslices after each instance of sep and
returns a slice of those subslices.
If sep is empty, SplitAfterN splits after each UTF-8 sequence.
The count determines the number of subslices to return:
</p>
<pre>n &gt; 0: at most n subslices; the last subslice will be the unsplit remainder.
n == 0: the result is nil (zero subslices)
n &lt; 0: all subslices
</pre>

			
		
			
			
			<h2 id="SplitN">func <a href="src/pkg/bytes/bytes.htm#L253">SplitN</a></h2>
			<pre>func SplitN(s, sep []byte, n int) [][]byte</pre>
			<p>
SplitN slices s into subslices separated by sep and returns a slice of
the subslices between those separators.
If sep is empty, SplitN splits after each UTF-8 sequence.
The count determines the number of subslices to return:
</p>
<pre>n &gt; 0: at most n subslices; the last subslice will be the unsplit remainder.
n == 0: the result is nil (zero subslices)
n &lt; 0: all subslices
</pre>

			
		
			
			
			<h2 id="Title">func <a href="src/pkg/bytes/bytes.htm#L461">Title</a></h2>
			<pre>func Title(s []byte) []byte</pre>
			<p>
Title returns a copy of s with all Unicode letters that begin words
mapped to their title case.
</p>

			
		
			
			
			<h2 id="ToLower">func <a href="src/pkg/bytes/bytes.htm#L409">ToLower</a></h2>
			<pre>func ToLower(s []byte) []byte</pre>
			<p>
ToUpper returns a copy of the byte array s with all Unicode letters mapped to their lower case.
</p>

			
		
			
			
			<h2 id="ToLowerSpecial">func <a href="src/pkg/bytes/bytes.htm#L422">ToLowerSpecial</a></h2>
			<pre>func ToLowerSpecial(_case unicode.SpecialCase, s []byte) []byte</pre>
			<p>
ToLowerSpecial returns a copy of the byte array s with all Unicode letters mapped to their
lower case, giving priority to the special casing rules.
</p>

			
		
			
			
			<h2 id="ToTitle">func <a href="src/pkg/bytes/bytes.htm#L412">ToTitle</a></h2>
			<pre>func ToTitle(s []byte) []byte</pre>
			<p>
ToTitle returns a copy of the byte array s with all Unicode letters mapped to their title case.
</p>

			
		
			
			
			<h2 id="ToTitleSpecial">func <a href="src/pkg/bytes/bytes.htm#L428">ToTitleSpecial</a></h2>
			<pre>func ToTitleSpecial(_case unicode.SpecialCase, s []byte) []byte</pre>
			<p>
ToTitleSpecial returns a copy of the byte array s with all Unicode letters mapped to their
title case, giving priority to the special casing rules.
</p>

			
		
			
			
			<h2 id="ToUpper">func <a href="src/pkg/bytes/bytes.htm#L406">ToUpper</a></h2>
			<pre>func ToUpper(s []byte) []byte</pre>
			<p>
ToUpper returns a copy of the byte array s with all Unicode letters mapped to their upper case.
</p>

			
		
			
			
			<h2 id="ToUpperSpecial">func <a href="src/pkg/bytes/bytes.htm#L416">ToUpperSpecial</a></h2>
			<pre>func ToUpperSpecial(_case unicode.SpecialCase, s []byte) []byte</pre>
			<p>
ToUpperSpecial returns a copy of the byte array s with all Unicode letters mapped to their
upper case, giving priority to the special casing rules.
</p>

			
		
			
			
			<h2 id="Trim">func <a href="src/pkg/bytes/bytes.htm#L567">Trim</a></h2>
			<pre>func Trim(s []byte, cutset string) []byte</pre>
			<p>
Trim returns a subslice of s by slicing off all leading and
trailing UTF-8-encoded Unicode code points contained in cutset.
</p>

			
		
			
			
			<h2 id="TrimFunc">func <a href="src/pkg/bytes/bytes.htm#L503">TrimFunc</a></h2>
			<pre>func TrimFunc(s []byte, f func(r rune) bool) []byte</pre>
			<p>
TrimFunc returns a subslice of s by slicing off all leading and trailing
UTF-8-encoded Unicode code points c that satisfy f(c).
</p>

			
		
			
			
			<h2 id="TrimLeft">func <a href="src/pkg/bytes/bytes.htm#L573">TrimLeft</a></h2>
			<pre>func TrimLeft(s []byte, cutset string) []byte</pre>
			<p>
TrimLeft returns a subslice of s by slicing off all leading
UTF-8-encoded Unicode code points contained in cutset.
</p>

			
		
			
			
			<h2 id="TrimLeftFunc">func <a href="src/pkg/bytes/bytes.htm#L480">TrimLeftFunc</a></h2>
			<pre>func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</pre>
			<p>
TrimLeftFunc returns a subslice of s by slicing off all leading UTF-8-encoded
Unicode code points c that satisfy f(c).
</p>

			
		
			
			
			<h2 id="TrimRight">func <a href="src/pkg/bytes/bytes.htm#L579">TrimRight</a></h2>
			<pre>func TrimRight(s []byte, cutset string) []byte</pre>
			<p>
TrimRight returns a subslice of s by slicing off all trailing
UTF-8-encoded Unicode code points that are contained in cutset.
</p>

			
		
			
			
			<h2 id="TrimRightFunc">func <a href="src/pkg/bytes/bytes.htm#L490">TrimRightFunc</a></h2>
			<pre>func TrimRightFunc(s []byte, f func(r rune) bool) []byte</pre>
			<p>
TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8
encoded Unicode code points c that satisfy f(c).
</p>

			
		
			
			
			<h2 id="TrimSpace">func <a href="src/pkg/bytes/bytes.htm#L585">TrimSpace</a></h2>
			<pre>func TrimSpace(s []byte) []byte</pre>
			<p>
TrimSpace returns a subslice of s by slicing off all leading and
trailing white space, as defined by Unicode.
</p>

			
		
		
			
			
			<h2 id="Buffer">type <a href="src/pkg/bytes/buffer.htm#L7">Buffer</a></h2>
			<pre>type Buffer struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Buffer is a variable-sized buffer of bytes with Read and Write methods.
The zero value for Buffer is an empty buffer ready to use.
</p>


			

			

			<div id="example_Buffer" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">var b Buffer <span class="comment">// A Buffer needs no initialization.</span>
b.Write([]byte(&#34;Hello &#34;))
b.Write([]byte(&#34;world!&#34;))
b.WriteTo(os.Stdout)
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">Hello world!</pre>
		
	</div>
</div>
<div id="example_Buffer_reader" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example (Reader)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example (Reader)</span></p>
		
		<p>Code:</p>
		<pre class="code"><span class="comment">// A Buffer can turn a string or a []byte into an io.Reader.</span>
buf := NewBufferString(&#34;R29waGVycyBydWxlIQ==&#34;)
dec := base64.NewDecoder(base64.StdEncoding, buf)
io.Copy(os.Stdout, dec)
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">Gophers rule!</pre>
		
	</div>
</div>


			
				
				<h3 id="NewBuffer">func <a href="src/pkg/bytes/buffer.htm#L370">NewBuffer</a></h3>
				<pre>func NewBuffer(buf []byte) *Buffer</pre>
				<p>
NewBuffer creates and initializes a new Buffer using buf as its initial
contents.  It is intended to prepare a Buffer to read existing data.  It
can also be used to size the internal buffer for writing. To do that,
buf should have the desired capacity but a length of zero.
</p>
<p>
In most cases, new(Buffer) (or just declaring a Buffer variable) is
sufficient to initialize a Buffer.
</p>

				
			
				
				<h3 id="NewBufferString">func <a href="src/pkg/bytes/buffer.htm#L378">NewBufferString</a></h3>
				<pre>func NewBufferString(s string) *Buffer</pre>
				<p>
NewBufferString creates and initializes a new Buffer using string s as its
initial contents. It is intended to prepare a buffer to read an existing
string.
</p>
<p>
In most cases, new(Buffer) (or just declaring a Buffer variable) is
sufficient to initialize a Buffer.
</p>

				
			

			
				
				<h3 id="Buffer.Bytes">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L33">Bytes</a></h3>
				<pre>func (b *Buffer) Bytes() []byte</pre>
				<p>
Bytes returns a slice of the contents of the unread portion of the buffer;
len(b.Bytes()) == b.Len().  If the caller changes the contents of the
returned slice, the contents of the buffer will change provided there
are no intervening method calls on the Buffer.
</p>

				
				
			
				
				<h3 id="Buffer.Len">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L47">Len</a></h3>
				<pre>func (b *Buffer) Len() int</pre>
				<p>
Len returns the number of bytes of the unread portion of the buffer;
b.Len() == len(b.Bytes()).
</p>

				
				
			
				
				<h3 id="Buffer.Next">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L250">Next</a></h3>
				<pre>func (b *Buffer) Next(n int) []byte</pre>
				<p>
Next returns a slice containing the next n bytes from the buffer,
advancing the buffer as if the bytes had been returned by Read.
If there are fewer than n bytes in the buffer, Next returns the entire buffer.
The slice is only valid until the next call to a read or write method.
</p>

				
				
			
				
				<h3 id="Buffer.Read">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L228">Read</a></h3>
				<pre>func (b *Buffer) Read(p []byte) (n int, err error)</pre>
				<p>
Read reads the next len(p) bytes from the buffer or until the buffer
is drained.  The return value n is the number of bytes read.  If the
buffer has no data to return, err is io.EOF (unless len(p) is zero);
otherwise it is nil.
</p>

				
				
			
				
				<h3 id="Buffer.ReadByte">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L266">ReadByte</a></h3>
				<pre>func (b *Buffer) ReadByte() (c byte, err error)</pre>
				<p>
ReadByte reads and returns the next byte from the buffer.
If no byte is available, it returns error io.EOF.
</p>

				
				
			
				
				<h3 id="Buffer.ReadBytes">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L339">ReadBytes</a></h3>
				<pre>func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</pre>
				<p>
ReadBytes reads until the first occurrence of delim in the input,
returning a slice containing the data up to and including the delimiter.
If ReadBytes encounters an error before finding a delimiter,
it returns the data read before the error and the error itself (often io.EOF).
ReadBytes returns err != nil if and only if the returned data does not end in
delim.
</p>

				
				
			
				
				<h3 id="Buffer.ReadFrom">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L124">ReadFrom</a></h3>
				<pre>func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</pre>
				<p>
ReadFrom reads data from r until EOF and appends it to the buffer.
The return value n is the number of bytes read.
Any error except io.EOF encountered during the read
is also returned.
If the buffer becomes too large, ReadFrom will panic with
ErrTooLarge.
</p>

				
				
			
				
				<h3 id="Buffer.ReadRune">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L284">ReadRune</a></h3>
				<pre>func (b *Buffer) ReadRune() (r rune, size int, err error)</pre>
				<p>
ReadRune reads and returns the next UTF-8-encoded
Unicode code point from the buffer.
If no bytes are available, the error returned is io.EOF.
If the bytes are an erroneous UTF-8 encoding, it
consumes one byte and returns U+FFFD, 1.
</p>

				
				
			
				
				<h3 id="Buffer.ReadString">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L358">ReadString</a></h3>
				<pre>func (b *Buffer) ReadString(delim byte) (line string, err error)</pre>
				<p>
ReadString reads until the first occurrence of delim in the input,
returning a string containing the data up to and including the delimiter.
If ReadString encounters an error before finding a delimiter,
it returns the data read before the error and the error itself (often io.EOF).
ReadString returns err != nil if and only if the returned data does not end
in delim.
</p>

				
				
			
				
				<h3 id="Buffer.Reset">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L65">Reset</a></h3>
				<pre>func (b *Buffer) Reset()</pre>
				<p>
Reset resets the buffer so it has no content.
b.Reset() is the same as b.Truncate(0).
</p>

				
				
			
				
				<h3 id="Buffer.String">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L37">String</a></h3>
				<pre>func (b *Buffer) String() string</pre>
				<p>
String returns the contents of the unread portion of the buffer
as a string.  If the Buffer is a nil pointer, it returns &#34;&lt;nil&gt;&#34;.
</p>

				
				
			
				
				<h3 id="Buffer.Truncate">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L51">Truncate</a></h3>
				<pre>func (b *Buffer) Truncate(n int)</pre>
				<p>
Truncate discards all but the first n unread bytes from the buffer.
It panics if n is negative or greater than the length of the buffer.
</p>

				
				
			
				
				<h3 id="Buffer.UnreadByte">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L322">UnreadByte</a></h3>
				<pre>func (b *Buffer) UnreadByte() error</pre>
				<p>
UnreadByte unreads the last byte returned by the most recent
read operation.  If write has happened since the last read, UnreadByte
returns an error.
</p>

				
				
			
				
				<h3 id="Buffer.UnreadRune">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L307">UnreadRune</a></h3>
				<pre>func (b *Buffer) UnreadRune() error</pre>
				<p>
UnreadRune unreads the last rune returned by ReadRune.
If the most recent read or write operation on the buffer was
not a ReadRune, UnreadRune returns an error.  (In this regard
it is stricter than UnreadByte, which will unread the last byte
from any read operation.)
</p>

				
				
			
				
				<h3 id="Buffer.Write">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L96">Write</a></h3>
				<pre>func (b *Buffer) Write(p []byte) (n int, err error)</pre>
				<p>
Write appends the contents of p to the buffer.  The return
value n is the length of p; err is always nil.
If the buffer becomes too large, Write will panic with
ErrTooLarge.
</p>

				
				
			
				
				<h3 id="Buffer.WriteByte">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L201">WriteByte</a></h3>
				<pre>func (b *Buffer) WriteByte(c byte) error</pre>
				<p>
WriteByte appends the byte c to the buffer.
The returned error is always nil, but is included
to match bufio.Writer&#39;s WriteByte.
If the buffer becomes too large, WriteByte will panic with
ErrTooLarge.
</p>

				
				
			
				
				<h3 id="Buffer.WriteRune">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L214">WriteRune</a></h3>
				<pre>func (b *Buffer) WriteRune(r rune) (n int, err error)</pre>
				<p>
WriteRune appends the UTF-8 encoding of Unicode
code point r to the buffer, returning its length and
an error, which is always nil but is included
to match bufio.Writer&#39;s WriteRune.
If the buffer becomes too large, WriteRune will panic with
ErrTooLarge.
</p>

				
				
			
				
				<h3 id="Buffer.WriteString">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L106">WriteString</a></h3>
				<pre>func (b *Buffer) WriteString(s string) (n int, err error)</pre>
				<p>
WriteString appends the contents of s to the buffer.  The return
value n is the length of s; err is always nil.
If the buffer becomes too large, WriteString will panic with
ErrTooLarge.
</p>

				
				
			
				
				<h3 id="Buffer.WriteTo">func (*Buffer) <a href="src/pkg/bytes/buffer.htm#L172">WriteTo</a></h3>
				<pre>func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</pre>
				<p>
WriteTo writes data to w until the buffer is drained or an error
occurs. The return value n is the number of bytes written; it always
fits into an int, but it is int64 to match the io.WriterTo interface.
Any error encountered during the write is also returned.
</p>

				
				
			
		
			
			
			<h2 id="Reader">type <a href="src/pkg/bytes/reader.htm#L7">Reader</a></h2>
			<pre>type Reader struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Reader implements the io.Reader, io.ReaderAt, io.Seeker,
io.ByteScanner, and io.RuneScanner interfaces by reading from
a byte slice.
Unlike a Buffer, a Reader is read-only and supports seeking.
</p>


			

			

			

			
				
				<h3 id="NewReader">func <a href="src/pkg/bytes/reader.htm#L115">NewReader</a></h3>
				<pre>func NewReader(b []byte) *Reader</pre>
				<p>
NewReader returns a new Reader reading from b.
</p>

				
			

			
				
				<h3 id="Reader.Len">func (*Reader) <a href="src/pkg/bytes/reader.htm#L15">Len</a></h3>
				<pre>func (r *Reader) Len() int</pre>
				<p>
Len returns the number of bytes of the unread portion of the
slice.
</p>

				
				
			
				
				<h3 id="Reader.Read">func (*Reader) <a href="src/pkg/bytes/reader.htm#L22">Read</a></h3>
				<pre>func (r *Reader) Read(b []byte) (n int, err error)</pre>
				
				
				
			
				
				<h3 id="Reader.ReadAt">func (*Reader) <a href="src/pkg/bytes/reader.htm#L35">ReadAt</a></h3>
				<pre>func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</pre>
				
				
				
			
				
				<h3 id="Reader.ReadByte">func (*Reader) <a href="src/pkg/bytes/reader.htm#L49">ReadByte</a></h3>
				<pre>func (r *Reader) ReadByte() (b byte, err error)</pre>
				
				
				
			
				
				<h3 id="Reader.ReadRune">func (*Reader) <a href="src/pkg/bytes/reader.htm#L68">ReadRune</a></h3>
				<pre>func (r *Reader) ReadRune() (ch rune, size int, err error)</pre>
				
				
				
			
				
				<h3 id="Reader.Seek">func (*Reader) <a href="src/pkg/bytes/reader.htm#L92">Seek</a></h3>
				<pre>func (r *Reader) Seek(offset int64, whence int) (int64, error)</pre>
				<p>
Seek implements the io.Seeker interface.
</p>

				
				
			
				
				<h3 id="Reader.UnreadByte">func (*Reader) <a href="src/pkg/bytes/reader.htm#L59">UnreadByte</a></h3>
				<pre>func (r *Reader) UnreadByte() error</pre>
				
				
				
			
				
				<h3 id="Reader.UnreadRune">func (*Reader) <a href="src/pkg/bytes/reader.htm#L82">UnreadRune</a></h3>
				<pre>func (r *Reader) UnreadRune() error</pre>
				
				
				
			
		
		</div>
	

	
		<h2 id="bugs">Bugs</h2>
		
		<p>
The rule Title uses for word boundaries does not handle Unicode punctuation properly.
</p>

		
	









</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
