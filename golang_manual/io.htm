
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>io - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package io</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "io"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
			
				<dd><a href="#subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package io provides basic interfaces to I/O primitives.
Its primary job is to wrap existing implementations of such primitives,
such as those in package os, into shared public interfaces that
abstract the functionality, plus some other related primitives.
</p>
<p>
Because these interfaces and primitives wrap lower-level operations with
various implementations, unless otherwise informed clients should not
assume they are safe for parallel execution.
</p>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
				<dd><a href="#variables">Variables</a></dd>
			
			
				
				<dd><a href="#Copy">func Copy(dst Writer, src Reader) (written int64, err error)</a></dd>
			
				
				<dd><a href="#CopyN">func CopyN(dst Writer, src Reader, n int64) (written int64, err error)</a></dd>
			
				
				<dd><a href="#ReadAtLeast">func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)</a></dd>
			
				
				<dd><a href="#ReadFull">func ReadFull(r Reader, buf []byte) (n int, err error)</a></dd>
			
				
				<dd><a href="#WriteString">func WriteString(w Writer, s string) (n int, err error)</a></dd>
			
			
				
				<dd><a href="#ByteReader">type ByteReader</a></dd>
				
				
			
				
				<dd><a href="#ByteScanner">type ByteScanner</a></dd>
				
				
			
				
				<dd><a href="#Closer">type Closer</a></dd>
				
				
			
				
				<dd><a href="#LimitedReader">type LimitedReader</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LimitedReader.Read">func (l *LimitedReader) Read(p []byte) (n int, err error)</a></dd>
				
			
				
				<dd><a href="#PipeReader">type PipeReader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Pipe">func Pipe() (*PipeReader, *PipeWriter)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PipeReader.Close">func (r *PipeReader) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PipeReader.CloseWithError">func (r *PipeReader) CloseWithError(err error) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PipeReader.Read">func (r *PipeReader) Read(data []byte) (n int, err error)</a></dd>
				
			
				
				<dd><a href="#PipeWriter">type PipeWriter</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PipeWriter.Close">func (w *PipeWriter) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PipeWriter.CloseWithError">func (w *PipeWriter) CloseWithError(err error) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PipeWriter.Write">func (w *PipeWriter) Write(data []byte) (n int, err error)</a></dd>
				
			
				
				<dd><a href="#ReadCloser">type ReadCloser</a></dd>
				
				
			
				
				<dd><a href="#ReadSeeker">type ReadSeeker</a></dd>
				
				
			
				
				<dd><a href="#ReadWriteCloser">type ReadWriteCloser</a></dd>
				
				
			
				
				<dd><a href="#ReadWriteSeeker">type ReadWriteSeeker</a></dd>
				
				
			
				
				<dd><a href="#ReadWriter">type ReadWriter</a></dd>
				
				
			
				
				<dd><a href="#Reader">type Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LimitReader">func LimitReader(r Reader, n int64) Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MultiReader">func MultiReader(readers ...Reader) Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TeeReader">func TeeReader(r Reader, w Writer) Reader</a></dd>
				
				
			
				
				<dd><a href="#ReaderAt">type ReaderAt</a></dd>
				
				
			
				
				<dd><a href="#ReaderFrom">type ReaderFrom</a></dd>
				
				
			
				
				<dd><a href="#RuneReader">type RuneReader</a></dd>
				
				
			
				
				<dd><a href="#RuneScanner">type RuneScanner</a></dd>
				
				
			
				
				<dd><a href="#SectionReader">type SectionReader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSectionReader">func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SectionReader.Read">func (s *SectionReader) Read(p []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SectionReader.ReadAt">func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SectionReader.Seek">func (s *SectionReader) Seek(offset int64, whence int) (ret int64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SectionReader.Size">func (s *SectionReader) Size() int64</a></dd>
				
			
				
				<dd><a href="#Seeker">type Seeker</a></dd>
				
				
			
				
				<dd><a href="#WriteCloser">type WriteCloser</a></dd>
				
				
			
				
				<dd><a href="#WriteSeeker">type WriteSeeker</a></dd>
				
				
			
				
				<dd><a href="#Writer">type Writer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MultiWriter">func MultiWriter(writers ...Writer) Writer</a></dd>
				
				
			
				
				<dd><a href="#WriterAt">type WriterAt</a></dd>
				
				
			
				
				<dd><a href="#WriterTo">type WriterTo</a></dd>
				
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/io/io.htm">io.go</a>
			
				<a href="src/pkg/io/multi.htm">multi.go</a>
			
				<a href="src/pkg/io/pipe.htm">pipe.go</a>
			
			</span>
			</p>
		
	
		
		
			<h2 id="variables">Variables</h2>
			
				<pre>var EOF = errors.New(&#34;EOF&#34;)</pre>
				<p>
EOF is the error returned by Read when no more input is available.
Functions should return EOF only to signal a graceful end of input.
If the EOF occurs unexpectedly in a structured data stream,
the appropriate error is either ErrUnexpectedEOF or some other error
giving more detail.
</p>

			
				<pre>var ErrClosedPipe = errors.New(&#34;io: read/write on closed pipe&#34;)</pre>
				<p>
ErrClosedPipe is the error used for read or write operations on a closed pipe.
</p>

			
				<pre>var ErrShortBuffer = errors.New(&#34;short buffer&#34;)</pre>
				<p>
ErrShortBuffer means that a read required a longer buffer than was provided.
</p>

			
				<pre>var ErrShortWrite = errors.New(&#34;short write&#34;)</pre>
				<p>
ErrShortWrite means that a write accepted fewer bytes than requested
but failed to return an explicit error.
</p>

			
				<pre>var ErrUnexpectedEOF = errors.New(&#34;unexpected EOF&#34;)</pre>
				<p>
ErrUnexpectedEOF means that EOF was encountered in the
middle of reading a fixed-size block or data structure.
</p>

			
		
		
			
			
			<h2 id="Copy">func <a href="src/pkg/io/io.htm#L326">Copy</a></h2>
			<pre>func Copy(dst Writer, src Reader) (written int64, err error)</pre>
			<p>
Copy copies from src to dst until either EOF is reached
on src or an error occurs.  It returns the number of bytes
copied and the first error encountered while copying, if any.
</p>
<p>
A successful Copy returns err == nil, not err == EOF.
Because Copy is defined to read from src until EOF, it does
not treat an EOF from Read as an error to be reported.
</p>
<p>
If dst implements the ReaderFrom interface,
the copy is implemented by calling dst.ReadFrom(src).
Otherwise, if src implements the WriterTo interface,
the copy is implemented by calling src.WriteTo(dst).
</p>

			
		
			
			
			<h2 id="CopyN">func <a href="src/pkg/io/io.htm#L274">CopyN</a></h2>
			<pre>func CopyN(dst Writer, src Reader, n int64) (written int64, err error)</pre>
			<p>
CopyN copies n bytes (or until an error) from src to dst.
It returns the number of bytes copied and the earliest
error encountered while copying.  Because Read can
return the full amount requested as well as an error
(including EOF), so can CopyN.
</p>
<p>
If dst implements the ReaderFrom interface,
the copy is implemented using it.
</p>

			
		
			
			
			<h2 id="ReadAtLeast">func <a href="src/pkg/io/io.htm#L238">ReadAtLeast</a></h2>
			<pre>func ReadAtLeast(r Reader, buf []byte, min int) (n int, err error)</pre>
			<p>
ReadAtLeast reads from r into buf until it has read at least min bytes.
It returns the number of bytes copied and an error if fewer bytes were read.
The error is EOF only if no bytes were read.
If an EOF happens after reading fewer than min bytes,
ReadAtLeast returns ErrUnexpectedEOF.
If min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer.
</p>

			
		
			
			
			<h2 id="ReadFull">func <a href="src/pkg/io/io.htm#L262">ReadFull</a></h2>
			<pre>func ReadFull(r Reader, buf []byte) (n int, err error)</pre>
			<p>
ReadFull reads exactly len(buf) bytes from r into buf.
It returns the number of bytes copied and an error if fewer bytes were read.
The error is EOF only if no bytes were read.
If an EOF happens after reading some but not all the bytes,
ReadFull returns ErrUnexpectedEOF.
</p>

			
		
			
			
			<h2 id="WriteString">func <a href="src/pkg/io/io.htm#L225">WriteString</a></h2>
			<pre>func WriteString(w Writer, s string) (n int, err error)</pre>
			<p>
WriteString writes the contents of the string s to w, which accepts an array of bytes.
If w already implements a WriteString method, it is invoked directly.
</p>

			
		
		
			
			
			<h2 id="ByteReader">type <a href="src/pkg/io/io.htm#L181">ByteReader</a></h2>
			<pre>type ByteReader interface {
    ReadByte() (c byte, err error)
}</pre>
			<p>
ByteReader is the interface that wraps the ReadByte method.
</p>
<p>
ReadByte reads and returns the next byte from the input.
If no byte is available, err will be set.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ByteScanner">type <a href="src/pkg/io/io.htm#L192">ByteScanner</a></h2>
			<pre>type ByteScanner interface {
    ByteReader
    UnreadByte() error
}</pre>
			<p>
ByteScanner is the interface that adds the UnreadByte method to the
basic ReadByte method.
</p>
<p>
UnreadByte causes the next call to ReadByte to return the same byte
as the previous call to ReadByte.
It may be an error to call UnreadByte twice without an intervening
call to ReadByte.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Closer">type <a href="src/pkg/io/io.htm#L63">Closer</a></h2>
			<pre>type Closer interface {
    Close() error
}</pre>
			<p>
Closer is the interface that wraps the basic Close method.
</p>


			

			

			

			

			
		
			
			
			<h2 id="LimitedReader">type <a href="src/pkg/io/io.htm#L372">LimitedReader</a></h2>
			<pre>type LimitedReader struct {
    R Reader <span class="comment">// underlying reader</span>
    N int64  <span class="comment">// max bytes remaining</span>
}</pre>
			<p>
A LimitedReader reads from R but limits the amount of
data returned to just N bytes. Each call to Read
updates N to reflect the new amount remaining.
</p>


			

			

			

			

			
				
				<h3 id="LimitedReader.Read">func (*LimitedReader) <a href="src/pkg/io/io.htm#L377">Read</a></h3>
				<pre>func (l *LimitedReader) Read(p []byte) (n int, err error)</pre>
				
				
				
			
		
			
			
			<h2 id="PipeReader">type <a href="src/pkg/io/pipe.htm#L110">PipeReader</a></h2>
			<pre>type PipeReader struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A PipeReader is the read half of a pipe.
</p>


			

			

			

			
				
				<h3 id="Pipe">func <a href="src/pkg/io/pipe.htm#L172">Pipe</a></h3>
				<pre>func Pipe() (*PipeReader, *PipeWriter)</pre>
				<p>
Pipe creates a synchronous in-memory pipe.
It can be used to connect code expecting an io.Reader
with code expecting an io.Writer.
Reads on one end are matched with writes on the other,
copying data directly between the two; there is no internal buffering.
It is safe to call Read and Write in parallel with each other or with
Close. Close will complete once pending I/O is done. Parallel calls to
Read, and parallel calls to Write, are also safe:
the individual calls will be gated sequentially.
</p>

				
			

			
				
				<h3 id="PipeReader.Close">func (*PipeReader) <a href="src/pkg/io/pipe.htm#L125">Close</a></h3>
				<pre>func (r *PipeReader) Close() error</pre>
				<p>
Close closes the reader; subsequent writes to the
write half of the pipe will return the error ErrClosedPipe.
</p>

				
				
			
				
				<h3 id="PipeReader.CloseWithError">func (*PipeReader) <a href="src/pkg/io/pipe.htm#L131">CloseWithError</a></h3>
				<pre>func (r *PipeReader) CloseWithError(err error) error</pre>
				<p>
CloseWithError closes the reader; subsequent writes
to the write half of the pipe will return the error err.
</p>

				
				
			
				
				<h3 id="PipeReader.Read">func (*PipeReader) <a href="src/pkg/io/pipe.htm#L119">Read</a></h3>
				<pre>func (r *PipeReader) Read(data []byte) (n int, err error)</pre>
				<p>
Read implements the standard Read interface:
it reads data from the pipe, blocking until a writer
arrives or the write end is closed.
If the write end is closed with an error, that error is
returned as err; otherwise err is EOF.
</p>

				
				
			
		
			
			
			<h2 id="PipeWriter">type <a href="src/pkg/io/pipe.htm#L137">PipeWriter</a></h2>
			<pre>type PipeWriter struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A PipeWriter is the write half of a pipe.
</p>


			

			

			

			

			
				
				<h3 id="PipeWriter.Close">func (*PipeWriter) <a href="src/pkg/io/pipe.htm#L152">Close</a></h3>
				<pre>func (w *PipeWriter) Close() error</pre>
				<p>
Close closes the writer; subsequent reads from the
read half of the pipe will return no bytes and EOF.
</p>

				
				
			
				
				<h3 id="PipeWriter.CloseWithError">func (*PipeWriter) <a href="src/pkg/io/pipe.htm#L158">CloseWithError</a></h3>
				<pre>func (w *PipeWriter) CloseWithError(err error) error</pre>
				<p>
CloseWithError closes the writer; subsequent reads from the
read half of the pipe will return no bytes and the error err.
</p>

				
				
			
				
				<h3 id="PipeWriter.Write">func (*PipeWriter) <a href="src/pkg/io/pipe.htm#L146">Write</a></h3>
				<pre>func (w *PipeWriter) Write(data []byte) (n int, err error)</pre>
				<p>
Write implements the standard Write interface:
it writes data to the pipe, blocking until readers
have consumed all the data or the read end is closed.
If the read end is closed with an error, that err is
returned as err; otherwise err is ErrClosedPipe.
</p>

				
				
			
		
			
			
			<h2 id="ReadCloser">type <a href="src/pkg/io/io.htm#L85">ReadCloser</a></h2>
			<pre>type ReadCloser interface {
    Reader
    Closer
}</pre>
			<p>
ReadCloser is the interface that groups the basic Read and Close methods.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ReadSeeker">type <a href="src/pkg/io/io.htm#L104">ReadSeeker</a></h2>
			<pre>type ReadSeeker interface {
    Reader
    Seeker
}</pre>
			<p>
ReadSeeker is the interface that groups the basic Read and Seek methods.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ReadWriteCloser">type <a href="src/pkg/io/io.htm#L97">ReadWriteCloser</a></h2>
			<pre>type ReadWriteCloser interface {
    Reader
    Writer
    Closer
}</pre>
			<p>
ReadWriteCloser is the interface that groups the basic Read, Write and Close methods.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ReadWriteSeeker">type <a href="src/pkg/io/io.htm#L116">ReadWriteSeeker</a></h2>
			<pre>type ReadWriteSeeker interface {
    Reader
    Writer
    Seeker
}</pre>
			<p>
ReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ReadWriter">type <a href="src/pkg/io/io.htm#L79">ReadWriter</a></h2>
			<pre>type ReadWriter interface {
    Reader
    Writer
}</pre>
			<p>
ReadWriter is the interface that groups the basic Read and Write methods.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Reader">type <a href="src/pkg/io/io.htm#L48">Reader</a></h2>
			<pre>type Reader interface {
    Read(p []byte) (n int, err error)
}</pre>
			<p>
Reader is the interface that wraps the basic Read method.
</p>
<p>
Read reads up to len(p) bytes into p.  It returns the number of bytes
read (0 &lt;= n &lt;= len(p)) and any error encountered.  Even if Read
returns n &lt; len(p), it may use all of p as scratch space during the call.
If some data is available but not len(p) bytes, Read conventionally
returns what is available instead of waiting for more.
</p>
<p>
When Read encounters an error or end-of-file condition after
successfully reading n &gt; 0 bytes, it returns the number of
bytes read.  It may return the (non-nil) error from the same call
or return the error (and n == 0) from a subsequent call.
An instance of this general case is that a Reader returning
a non-zero number of bytes at the end of the input stream may
return either err == EOF or err == nil.  The next Read should
return 0, EOF regardless.
</p>
<p>
Callers should always process the n &gt; 0 bytes returned before
considering the error err.  Doing so correctly handles I/O errors
that happen after reading some bytes and also both of the
allowed EOF behaviors.
</p>


			

			

			

			
				
				<h3 id="LimitReader">func <a href="src/pkg/io/io.htm#L367">LimitReader</a></h3>
				<pre>func LimitReader(r Reader, n int64) Reader</pre>
				<p>
LimitReader returns a Reader that reads from r
but stops with EOF after n bytes.
The underlying implementation is a *LimitedReader.
</p>

				
			
				
				<h3 id="MultiReader">func <a href="src/pkg/io/multi.htm#L20">MultiReader</a></h3>
				<pre>func MultiReader(readers ...Reader) Reader</pre>
				<p>
MultiReader returns a Reader that&#39;s the logical concatenation of
the provided input readers.  They&#39;re read sequentially.  Once all
inputs are drained, Read will return EOF.
</p>

				
			
				
				<h3 id="TeeReader">func <a href="src/pkg/io/io.htm#L456">TeeReader</a></h3>
				<pre>func TeeReader(r Reader, w Writer) Reader</pre>
				<p>
TeeReader returns a Reader that writes to w what it reads from r.
All reads from r performed through it are matched with
corresponding writes to w.  There is no internal buffering -
the write must complete before the read completes.
Any error encountered while writing is reported as a read error.
</p>

				
			

			
		
			
			
			<h2 id="ReaderAt">type <a href="src/pkg/io/io.htm#L156">ReaderAt</a></h2>
			<pre>type ReaderAt interface {
    ReadAt(p []byte, off int64) (n int, err error)
}</pre>
			<p>
ReaderAt is the interface that wraps the basic ReadAt method.
</p>
<p>
ReadAt reads len(p) bytes into p starting at offset off in the
underlying input source.  It returns the number of bytes
read (0 &lt;= n &lt;= len(p)) and any error encountered.
</p>
<p>
When ReadAt returns n &lt; len(p), it returns a non-nil error
explaining why more bytes were not returned.  In this respect,
ReadAt is stricter than Read.
</p>
<p>
Even if ReadAt returns n &lt; len(p), it may use all of p as scratch
space during the call.  If some data is available but not len(p) bytes,
ReadAt blocks until either all the data is available or an error occurs.
In this respect ReadAt is different from Read.
</p>
<p>
If the n = len(p) bytes returned by ReadAt are at the end of the
input source, ReadAt may return either err == EOF or err == nil.
</p>
<p>
If ReadAt is reading from an input source with a seek offset,
ReadAt should not affect nor be affected by the underlying
seek offset.
</p>
<p>
Clients of ReadAt can execute parallel ReadAt calls on the
same input source.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ReaderFrom">type <a href="src/pkg/io/io.htm#L123">ReaderFrom</a></h2>
			<pre>type ReaderFrom interface {
    ReadFrom(r Reader) (n int64, err error)
}</pre>
			<p>
ReaderFrom is the interface that wraps the ReadFrom method.
</p>


			

			

			

			

			
		
			
			
			<h2 id="RuneReader">type <a href="src/pkg/io/io.htm#L202">RuneReader</a></h2>
			<pre>type RuneReader interface {
    ReadRune() (r rune, size int, err error)
}</pre>
			<p>
RuneReader is the interface that wraps the ReadRune method.
</p>
<p>
ReadRune reads a single UTF-8 encoded Unicode character
and returns the rune and its size in bytes. If no character is
available, err will be set.
</p>


			

			

			

			

			
		
			
			
			<h2 id="RuneScanner">type <a href="src/pkg/io/io.htm#L213">RuneScanner</a></h2>
			<pre>type RuneScanner interface {
    RuneReader
    UnreadRune() error
}</pre>
			<p>
RuneScanner is the interface that adds the UnreadRune method to the
basic ReadRune method.
</p>
<p>
UnreadRune causes the next call to ReadRune to return the same rune
as the previous call to ReadRune.
It may be an error to call UnreadRune twice without an intervening
call to ReadRune.
</p>


			

			

			

			

			
		
			
			
			<h2 id="SectionReader">type <a href="src/pkg/io/io.htm#L397">SectionReader</a></h2>
			<pre>type SectionReader struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
SectionReader implements Read, Seek, and ReadAt on a section
of an underlying ReaderAt.
</p>


			

			

			

			
				
				<h3 id="NewSectionReader">func <a href="src/pkg/io/io.htm#L391">NewSectionReader</a></h3>
				<pre>func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader</pre>
				<p>
NewSectionReader returns a SectionReader that reads from r
starting at offset off and stops with EOF after n bytes.
</p>

				
			

			
				
				<h3 id="SectionReader.Read">func (*SectionReader) <a href="src/pkg/io/io.htm#L404">Read</a></h3>
				<pre>func (s *SectionReader) Read(p []byte) (n int, err error)</pre>
				
				
				
			
				
				<h3 id="SectionReader.ReadAt">func (*SectionReader) <a href="src/pkg/io/io.htm#L437">ReadAt</a></h3>
				<pre>func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err error)</pre>
				
				
				
			
				
				<h3 id="SectionReader.Seek">func (*SectionReader) <a href="src/pkg/io/io.htm#L419">Seek</a></h3>
				<pre>func (s *SectionReader) Seek(offset int64, whence int) (ret int64, err error)</pre>
				
				
				
			
				
				<h3 id="SectionReader.Size">func (*SectionReader) <a href="src/pkg/io/io.htm#L449">Size</a></h3>
				<pre>func (s *SectionReader) Size() int64</pre>
				<p>
Size returns the size of the section in bytes.
</p>

				
				
			
		
			
			
			<h2 id="Seeker">type <a href="src/pkg/io/io.htm#L74">Seeker</a></h2>
			<pre>type Seeker interface {
    Seek(offset int64, whence int) (ret int64, err error)
}</pre>
			<p>
Seeker is the interface that wraps the basic Seek method.
</p>
<p>
Seek sets the offset for the next Read or Write to offset,
interpreted according to whence: 0 means relative to the origin of
the file, 1 means relative to the current offset, and 2 means
relative to the end.  Seek returns the new offset and an Error, if
any.
</p>


			

			

			

			

			
		
			
			
			<h2 id="WriteCloser">type <a href="src/pkg/io/io.htm#L91">WriteCloser</a></h2>
			<pre>type WriteCloser interface {
    Writer
    Closer
}</pre>
			<p>
WriteCloser is the interface that groups the basic Write and Close methods.
</p>


			

			

			

			

			
		
			
			
			<h2 id="WriteSeeker">type <a href="src/pkg/io/io.htm#L110">WriteSeeker</a></h2>
			<pre>type WriteSeeker interface {
    Writer
    Seeker
}</pre>
			<p>
WriteSeeker is the interface that groups the basic Write and Seek methods.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Writer">type <a href="src/pkg/io/io.htm#L58">Writer</a></h2>
			<pre>type Writer interface {
    Write(p []byte) (n int, err error)
}</pre>
			<p>
Writer is the interface that wraps the basic Write method.
</p>
<p>
Write writes len(p) bytes from p to the underlying data stream.
It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))
and any error encountered that caused the write to stop early.
Write must return a non-nil error if it returns n &lt; len(p).
</p>


			

			

			

			
				
				<h3 id="MultiWriter">func <a href="src/pkg/io/multi.htm#L44">MultiWriter</a></h3>
				<pre>func MultiWriter(writers ...Writer) Writer</pre>
				<p>
MultiWriter creates a writer that duplicates its writes to all the
provided writers, similar to the Unix tee(1) command.
</p>

				
			

			
		
			
			
			<h2 id="WriterAt">type <a href="src/pkg/io/io.htm#L173">WriterAt</a></h2>
			<pre>type WriterAt interface {
    WriteAt(p []byte, off int64) (n int, err error)
}</pre>
			<p>
WriterAt is the interface that wraps the basic WriteAt method.
</p>
<p>
WriteAt writes len(p) bytes from p to the underlying data stream
at offset off.  It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))
and any error encountered that caused the write to stop early.
WriteAt must return a non-nil error if it returns n &lt; len(p).
</p>
<p>
If WriteAt is writing to a destination with a seek offset,
WriteAt should not affect nor be affected by the underlying
seek offset.
</p>
<p>
Clients of WriteAt can execute parallel WriteAt calls on the same
destination if the ranges do not overlap.
</p>


			

			

			

			

			
		
			
			
			<h2 id="WriterTo">type <a href="src/pkg/io/io.htm#L128">WriterTo</a></h2>
			<pre>type WriterTo interface {
    WriteTo(w Writer) (n int64, err error)
}</pre>
			<p>
WriterTo is the interface that wraps the WriteTo method.
</p>


			

			

			

			

			
		
		</div>
	

	







	
	
		<h2 id="subdirectories">Subdirectories</h2>
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
			<tr>
			<td class="name"><a href="io_ioutil.htm">ioutil</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package ioutil implements some I/O utility functions.</td>
			</tr>
		
	
	</table>
	



</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
