
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>builtin - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>

<div id="topbar"><div class="container wide">

</div></div>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package builtin</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "builtin"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package builtin provides documentation for Go&#39;s predeclared identifiers.
The items documented here are not actually in package builtin
but their descriptions here allow godoc to present documentation
for the language&#39;s special identifiers.
</p>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#append">func append(slice []Type, elems ...Type) []Type</a></dd>
			
				
				<dd><a href="#close">func close(c chan&lt;- Type)</a></dd>
			
				
				<dd><a href="#delete">func delete(m map[Type]Type1, key Type)</a></dd>
			
				
				<dd><a href="#panic">func panic(v interface{})</a></dd>
			
				
				<dd><a href="#recover">func recover() interface{}</a></dd>
			
			
				
				<dd><a href="#ComplexType">type ComplexType</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#complex">func complex(r, i FloatType) ComplexType</a></dd>
				
				
			
				
				<dd><a href="#FloatType">type FloatType</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#imag">func imag(c ComplexType) FloatType</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#real">func real(c ComplexType) FloatType</a></dd>
				
				
			
				
				<dd><a href="#IntegerType">type IntegerType</a></dd>
				
				
			
				
				<dd><a href="#Type">type Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#make">func make(Type, size IntegerType) Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#new">func new(Type) *Type</a></dd>
				
				
			
				
				<dd><a href="#Type1">type Type1</a></dd>
				
				
			
				
				<dd><a href="#bool">type bool</a></dd>
				
				
			
				
				<dd><a href="#byte">type byte</a></dd>
				
				
			
				
				<dd><a href="#complex128">type complex128</a></dd>
				
				
			
				
				<dd><a href="#complex64">type complex64</a></dd>
				
				
			
				
				<dd><a href="#error">type error</a></dd>
				
				
			
				
				<dd><a href="#float32">type float32</a></dd>
				
				
			
				
				<dd><a href="#float64">type float64</a></dd>
				
				
			
				
				<dd><a href="#int">type int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#cap">func cap(v Type) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#copy">func copy(dst, src []Type) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#len">func len(v Type) int</a></dd>
				
				
			
				
				<dd><a href="#int16">type int16</a></dd>
				
				
			
				
				<dd><a href="#int32">type int32</a></dd>
				
				
			
				
				<dd><a href="#int64">type int64</a></dd>
				
				
			
				
				<dd><a href="#int8">type int8</a></dd>
				
				
			
				
				<dd><a href="#rune">type rune</a></dd>
				
				
			
				
				<dd><a href="#string">type string</a></dd>
				
				
			
				
				<dd><a href="#uint">type uint</a></dd>
				
				
			
				
				<dd><a href="#uint16">type uint16</a></dd>
				
				
			
				
				<dd><a href="#uint32">type uint32</a></dd>
				
				
			
				
				<dd><a href="#uint64">type uint64</a></dd>
				
				
			
				
				<dd><a href="#uint8">type uint8</a></dd>
				
				
			
				
				<dd><a href="#uintptr">type uintptr</a></dd>
				
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/builtin/builtin.htm">builtin.go</a>
			
			</span>
			</p>
		
	
		
		
		
			
			
			<h2 id="append">func <a href="src/pkg/builtin/builtin.htm#L108">append</a></h2>
			<pre>func append(slice []Type, elems ...Type) []Type</pre>
			<p>
The append built-in function appends elements to the end of a slice. If
it has sufficient capacity, the destination is resliced to accommodate the
new elements. If it does not, a new underlying array will be allocated.
Append returns the updated slice. It is therefore necessary to store the
result of append, often in the variable holding the slice itself:
</p>
<pre>slice = append(slice, elem1, elem2)
slice = append(slice, anotherSlice...)
</pre>

			
		
			
			
			<h2 id="close">func <a href="src/pkg/builtin/builtin.htm#L187">close</a></h2>
			<pre>func close(c chan&lt;- Type)</pre>
			<p>
The close built-in function closes a channel, which must be either
bidirectional or send-only. It should be executed only by the sender,
never the receiver, and has the effect of shutting down the channel after
the last sent value is received. After the last value has been received
from a closed channel c, any receive from c will succeed without
blocking, returning the zero value for the channel element. The form
</p>
<pre>x, ok := &lt;-c
</pre>
<p>
will also set ok to false for a closed channel.
</p>

			
		
			
			
			<h2 id="delete">func <a href="src/pkg/builtin/builtin.htm#L120">delete</a></h2>
			<pre>func delete(m map[Type]Type1, key Type)</pre>
			<p>
The delete built-in function deletes the element with the specified key
(m[key]) from the map. If there is no such element, delete is a no-op.
If m is nil, delete panics.
</p>

			
		
			
			
			<h2 id="panic">func <a href="src/pkg/builtin/builtin.htm#L200">panic</a></h2>
			<pre>func panic(v interface{})</pre>
			<p>
The panic built-in function stops normal execution of the current
goroutine. When a function F calls panic, normal execution of F stops
immediately. Any functions whose execution was deferred by F are run in
the usual way, and then F returns to its caller. To the caller G, the
invocation of F then behaves like a call to panic, terminating G&#39;s
execution and running any deferred functions. This continues until all
functions in the executing goroutine have stopped, in reverse order. At
that point, the program is terminated and the error condition is reported,
including the value of the argument to panic. This termination sequence
is called panicking and can be controlled by the built-in function
recover.
</p>

			
		
			
			
			<h2 id="recover">func <a href="src/pkg/builtin/builtin.htm#L211">recover</a></h2>
			<pre>func recover() interface{}</pre>
			<p>
The recover built-in function allows a program to manage behavior of a
panicking goroutine. Executing a call to recover inside a deferred
function (but not any function called by it) stops the panicking sequence
by restoring normal execution and retrieves the error value passed to the
call of panic. If recover is called outside the deferred function it will
not stop a panicking sequence. In this case, or when the goroutine is not
panicking, or if the argument supplied to panic was nil, recover returns
nil. Thus the return value from recover reports whether the goroutine is
panicking.
</p>

			
		
		
			
			
			<h2 id="ComplexType">type <a href="src/pkg/builtin/builtin.htm#L99">ComplexType</a></h2>
			<pre>type ComplexType complex64</pre>
			<p>
ComplexType is here for the purposes of documentation only. It is a
stand-in for either complex type: complex64 or complex128.
</p>


			

			

			

			
				
				<h3 id="complex">func <a href="src/pkg/builtin/builtin.htm#L168">complex</a></h3>
				<pre>func complex(r, i FloatType) ComplexType</pre>
				<p>
The complex built-in function constructs a complex value from two
floating-point values. The real and imaginary parts must be of the same
size, either float32 or float64 (or assignable to them), and the return
value will be the corresponding complex type (complex64 for float32,
complex128 for float64).
</p>

				
			

			
		
			
			
			<h2 id="FloatType">type <a href="src/pkg/builtin/builtin.htm#L95">FloatType</a></h2>
			<pre>type FloatType float32</pre>
			<p>
FloatType is here for the purposes of documentation only. It is a stand-in
for either float type: float32 or float64.
</p>


			

			

			

			
				
				<h3 id="imag">func <a href="src/pkg/builtin/builtin.htm#L177">imag</a></h3>
				<pre>func imag(c ComplexType) FloatType</pre>
				<p>
The imag built-in function returns the imaginary part of the complex
number c. The return value will be floating point type corresponding to
the type of c.
</p>

				
			
				
				<h3 id="real">func <a href="src/pkg/builtin/builtin.htm#L172">real</a></h3>
				<pre>func real(c ComplexType) FloatType</pre>
				<p>
The real built-in function returns the real part of the complex number c.
The return value will be floating point type corresponding to the type of c.
</p>

				
			

			
		
			
			
			<h2 id="IntegerType">type <a href="src/pkg/builtin/builtin.htm#L91">IntegerType</a></h2>
			<pre>type IntegerType int</pre>
			<p>
IntegerType is here for the purposes of documentation only. It is a stand-in
for any integer type: int, uint, int8 etc.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Type">type <a href="src/pkg/builtin/builtin.htm#L82">Type</a></h2>
			<pre>type Type int</pre>
			<p>
Type is here for the purposes of documentation only. It is a stand-in
for any Go type, but represents the same type for any given function
invocation.
</p>


			

			

			

			
				
				<h3 id="make">func <a href="src/pkg/builtin/builtin.htm#L156">make</a></h3>
				<pre>func make(Type, size IntegerType) Type</pre>
				<p>
The make built-in function allocates and initializes an object of type
slice, map, or chan (only). Like new, the first argument is a type, not a
value. Unlike new, make&#39;s return type is the same as the type of its
argument, not a pointer to it. The specification of the result depends on
the type:
</p>
<pre>Slice: The size specifies the length. The capacity of the slice is
equal to its length. A second integer argument may be provided to
specify a different capacity; it must be no smaller than the
length, so make([]int, 0, 10) allocates a slice of length 0 and
capacity 10.
Map: An initial allocation is made according to the size but the
resulting map has length 0. The size may be omitted, in which case
a small starting size is allocated.
Channel: The channel&#39;s buffer is initialized with the specified
buffer capacity. If zero, or the size is omitted, the channel is
unbuffered.
</pre>

				
			
				
				<h3 id="new">func <a href="src/pkg/builtin/builtin.htm#L161">new</a></h3>
				<pre>func new(Type) *Type</pre>
				<p>
The new built-in function allocates memory. The first argument is a type,
not a value, and the value returned is a pointer to a newly
allocated zero value of that type.
</p>

				
			

			
		
			
			
			<h2 id="Type1">type <a href="src/pkg/builtin/builtin.htm#L87">Type1</a></h2>
			<pre>type Type1 int</pre>
			<p>
Type1 is here for the purposes of documentation only. It is a stand-in
for any Go type, but represents the same type for any given function
invocation.
</p>


			

			

			

			

			
		
			
			
			<h2 id="bool">type <a href="src/pkg/builtin/builtin.htm#L4">bool</a></h2>
			<pre>type bool bool</pre>
			<p>
bool is the set of boolean values, true and false.
</p>


			

			

			

			

			
		
			
			
			<h2 id="byte">type <a href="src/pkg/builtin/builtin.htm#L72">byte</a></h2>
			<pre>type byte byte</pre>
			<p>
byte is an alias for uint8 and is equivalent to uint8 in all ways. It is
used, by convention, to distinguish byte values from 8-bit unsigned
integer values.
</p>


			

			

			

			

			
		
			
			
			<h2 id="complex128">type <a href="src/pkg/builtin/builtin.htm#L50">complex128</a></h2>
			<pre>type complex128 complex128</pre>
			<p>
complex128 is the set of all complex numbers with float64 real and
imaginary parts.
</p>


			

			

			

			

			
		
			
			
			<h2 id="complex64">type <a href="src/pkg/builtin/builtin.htm#L46">complex64</a></h2>
			<pre>type complex64 complex64</pre>
			<p>
complex64 is the set of all complex numbers with float32 real and
imaginary parts.
</p>


			

			

			

			

			
		
			
			
			<h2 id="error">type <a href="src/pkg/builtin/builtin.htm#L215">error</a></h2>
			<pre>type error interface {
    Error() string
}</pre>
			<p>
The error built-in interface type is the conventional interface for
representing an error condition, with the nil value representing no error.
</p>


			

			

			

			

			
		
			
			
			<h2 id="float32">type <a href="src/pkg/builtin/builtin.htm#L39">float32</a></h2>
			<pre>type float32 float32</pre>
			<p>
float32 is the set of all IEEE-754 32-bit floating-point numbers.
</p>


			

			

			

			

			
		
			
			
			<h2 id="float64">type <a href="src/pkg/builtin/builtin.htm#L42">float64</a></h2>
			<pre>type float64 float64</pre>
			<p>
float64 is the set of all IEEE-754 64-bit floating-point numbers.
</p>


			

			

			

			

			
		
			
			
			<h2 id="int">type <a href="src/pkg/builtin/builtin.htm#L59">int</a></h2>
			<pre>type int int</pre>
			<p>
int is a signed integer type that is at least 32 bits in size. It is a
distinct type, however, and not an alias for, say, int32.
</p>


			

			

			

			
				
				<h3 id="cap">func <a href="src/pkg/builtin/builtin.htm#L138">cap</a></h3>
				<pre>func cap(v Type) int</pre>
				<p>
The cap built-in function returns the capacity of v, according to its type:
</p>
<pre>Array: the number of elements in v (same as len(v)).
Pointer to array: the number of elements in *v (same as len(v)).
Slice: the maximum length the slice can reach when resliced;
if v is nil, cap(v) is zero.
Channel: the channel buffer capacity, in units of elements;
if v is nil, cap(v) is zero.
</pre>

				
			
				
				<h3 id="copy">func <a href="src/pkg/builtin/builtin.htm#L115">copy</a></h3>
				<pre>func copy(dst, src []Type) int</pre>
				<p>
The copy built-in function copies elements from a source slice into a
destination slice. (As a special case, it also will copy bytes from a
string to a slice of bytes.) The source and destination may overlap. Copy
returns the number of elements copied, which will be the minimum of
len(src) and len(dst).
</p>

				
			
				
				<h3 id="len">func <a href="src/pkg/builtin/builtin.htm#L129">len</a></h3>
				<pre>func len(v Type) int</pre>
				<p>
The len built-in function returns the length of v, according to its type:
</p>
<pre>Array: the number of elements in v.
Pointer to array: the number of elements in *v (even if v is nil).
Slice, or map: the number of elements in v; if v is nil, len(v) is zero.
String: the number of bytes in v.
Channel: the number of elements queued (unread) in the channel buffer;
if v is nil, len(v) is zero.
</pre>

				
			

			
		
			
			
			<h2 id="int16">type <a href="src/pkg/builtin/builtin.htm#L28">int16</a></h2>
			<pre>type int16 int16</pre>
			<p>
int16 is the set of all signed 16-bit integers.
Range: -32768 through 32767.
</p>


			

			

			

			

			
		
			
			
			<h2 id="int32">type <a href="src/pkg/builtin/builtin.htm#L32">int32</a></h2>
			<pre>type int32 int32</pre>
			<p>
int32 is the set of all signed 32-bit integers.
Range: -2147483648 through 2147483647.
</p>


			

			

			

			

			
		
			
			
			<h2 id="int64">type <a href="src/pkg/builtin/builtin.htm#L36">int64</a></h2>
			<pre>type int64 int64</pre>
			<p>
int64 is the set of all signed 64-bit integers.
Range: -9223372036854775808 through 9223372036854775807.
</p>


			

			

			

			

			
		
			
			
			<h2 id="int8">type <a href="src/pkg/builtin/builtin.htm#L24">int8</a></h2>
			<pre>type int8 int8</pre>
			<p>
int8 is the set of all signed 8-bit integers.
Range: -128 through 127.
</p>


			

			

			

			

			
		
			
			
			<h2 id="rune">type <a href="src/pkg/builtin/builtin.htm#L77">rune</a></h2>
			<pre>type rune rune</pre>
			<p>
rune is an alias for int and is equivalent to int in all ways. It is
used, by convention, to distinguish character values from integer values.
In a future version of Go, it will change to an alias of int32.
</p>


			

			

			

			

			
		
			
			
			<h2 id="string">type <a href="src/pkg/builtin/builtin.htm#L55">string</a></h2>
			<pre>type string string</pre>
			<p>
string is the set of all strings of 8-bit bytes, conventionally but not
necessarily representing UTF-8-encoded text. A string may be empty, but
not nil. Values of string type are immutable.
</p>


			

			

			

			

			
		
			
			
			<h2 id="uint">type <a href="src/pkg/builtin/builtin.htm#L63">uint</a></h2>
			<pre>type uint uint</pre>
			<p>
uint is an unsigned integer type that is at least 32 bits in size. It is a
distinct type, however, and not an alias for, say, uint32.
</p>


			

			

			

			

			
		
			
			
			<h2 id="uint16">type <a href="src/pkg/builtin/builtin.htm#L12">uint16</a></h2>
			<pre>type uint16 uint16</pre>
			<p>
uint16 is the set of all unsigned 16-bit integers.
Range: 0 through 65535.
</p>


			

			

			

			

			
		
			
			
			<h2 id="uint32">type <a href="src/pkg/builtin/builtin.htm#L16">uint32</a></h2>
			<pre>type uint32 uint32</pre>
			<p>
uint32 is the set of all unsigned 32-bit integers.
Range: 0 through 4294967295.
</p>


			

			

			

			

			
		
			
			
			<h2 id="uint64">type <a href="src/pkg/builtin/builtin.htm#L20">uint64</a></h2>
			<pre>type uint64 uint64</pre>
			<p>
uint64 is the set of all unsigned 64-bit integers.
Range: 0 through 18446744073709551615.
</p>


			

			

			

			

			
		
			
			
			<h2 id="uint8">type <a href="src/pkg/builtin/builtin.htm#L8">uint8</a></h2>
			<pre>type uint8 uint8</pre>
			<p>
uint8 is the set of all unsigned 8-bit integers.
Range: 0 through 255.
</p>


			

			

			

			

			
		
			
			
			<h2 id="uintptr">type <a href="src/pkg/builtin/builtin.htm#L67">uintptr</a></h2>
			<pre>type uintptr uintptr</pre>
			<p>
uintptr is an integer type that is large enough to hold the bit pattern of
any pointer.
</p>


			

			

			

			

			
		
		</div>
	

	









</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
