
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>syntax - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package syntax</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "regexp/syntax"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package syntax parses regular expressions into parse trees and compiles
parse trees into programs. Most clients of regular expressions will use
the facilities of package regexp (such as Compile and Match) instead of
this package.
</p>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#IsWordChar">func IsWordChar(r rune) bool</a></dd>
			
			
				
				<dd><a href="#EmptyOp">type EmptyOp</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EmptyOpContext">func EmptyOpContext(r1, r2 rune) EmptyOp</a></dd>
				
				
			
				
				<dd><a href="#Error">type Error</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Error.Error">func (e *Error) Error() string</a></dd>
				
			
				
				<dd><a href="#ErrorCode">type ErrorCode</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ErrorCode.String">func (e ErrorCode) String() string</a></dd>
				
			
				
				<dd><a href="#Flags">type Flags</a></dd>
				
				
			
				
				<dd><a href="#Inst">type Inst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Inst.MatchEmptyWidth">func (i *Inst) MatchEmptyWidth(before rune, after rune) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Inst.MatchRune">func (i *Inst) MatchRune(r rune) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Inst.String">func (i *Inst) String() string</a></dd>
				
			
				
				<dd><a href="#InstOp">type InstOp</a></dd>
				
				
			
				
				<dd><a href="#Op">type Op</a></dd>
				
				
			
				
				<dd><a href="#Prog">type Prog</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Compile">func Compile(re *Regexp) (*Prog, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Prog.Prefix">func (p *Prog) Prefix() (prefix string, complete bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Prog.StartCond">func (p *Prog) StartCond() EmptyOp</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Prog.String">func (p *Prog) String() string</a></dd>
				
			
				
				<dd><a href="#Regexp">type Regexp</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Parse">func Parse(s string, flags Flags) (*Regexp, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Regexp.CapNames">func (re *Regexp) CapNames() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Regexp.Equal">func (x *Regexp) Equal(y *Regexp) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Regexp.MaxCap">func (re *Regexp) MaxCap() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Regexp.Simplify">func (re *Regexp) Simplify() *Regexp</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Regexp.String">func (re *Regexp) String() string</a></dd>
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/regexp/syntax/compile.htm">compile.go</a>
			
				<a href="src/pkg/regexp/syntax/parse.htm">parse.go</a>
			
				<a href="src/pkg/regexp/syntax/perl_groups.htm">perl_groups.go</a>
			
				<a href="src/pkg/regexp/syntax/prog.htm">prog.go</a>
			
				<a href="src/pkg/regexp/syntax/regexp.htm">regexp.go</a>
			
				<a href="src/pkg/regexp/syntax/simplify.htm">simplify.go</a>
			
			</span>
			</p>
		
	
		
		
		
			
			
			<h2 id="IsWordChar">func <a href="src/pkg/regexp/syntax/prog.htm#L73">IsWordChar</a></h2>
			<pre>func IsWordChar(r rune) bool</pre>
			<p>
IsWordChar reports whether r is consider a &ldquo;word character&rdquo;
during the evaluation of the \b and \B zero-width assertions.
These assertions are ASCII-only: the word characters are [A-Za-z0-9_].
</p>

			
		
		
			
			
			<h2 id="EmptyOp">type <a href="src/pkg/regexp/syntax/prog.htm#L31">EmptyOp</a></h2>
			<pre>type EmptyOp uint8</pre>
			<p>
An EmptyOp specifies a kind or mixture of zero-width assertions.
</p>


			
				<pre>const (
    EmptyBeginLine EmptyOp = 1 &lt;&lt; iota
    EmptyEndLine
    EmptyBeginText
    EmptyEndText
    EmptyWordBoundary
    EmptyNoWordBoundary
)</pre>
				
			

			

			

			
				
				<h3 id="EmptyOpContext">func <a href="src/pkg/regexp/syntax/prog.htm#L48">EmptyOpContext</a></h3>
				<pre>func EmptyOpContext(r1, r2 rune) EmptyOp</pre>
				<p>
EmptyOpContext returns the zero-width assertions
satisfied at the position between the runes r1 and r2.
Passing r1 == -1 indicates that the position is
at the beginning of the text.
Passing r2 == -1 indicates that the position is
at the end of the text.
</p>

				
			

			
		
			
			
			<h2 id="Error">type <a href="src/pkg/regexp/syntax/parse.htm#L10">Error</a></h2>
			<pre>type Error struct {
    Code ErrorCode
    Expr string
}</pre>
			<p>
An Error describes a failure to parse a regular expression
and gives the offending expression.
</p>


			

			

			

			

			
				
				<h3 id="Error.Error">func (*Error) <a href="src/pkg/regexp/syntax/parse.htm#L15">Error</a></h3>
				<pre>func (e *Error) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="ErrorCode">type <a href="src/pkg/regexp/syntax/parse.htm#L20">ErrorCode</a></h2>
			<pre>type ErrorCode string</pre>
			<p>
An ErrorCode describes a failure to parse a regular expression.
</p>


			
				<pre>const (
    <span class="comment">// Unexpected error</span>
    ErrInternalError ErrorCode = &#34;regexp/syntax: internal error&#34;

    <span class="comment">// Parse errors</span>
    ErrInvalidCharClass      ErrorCode = &#34;invalid character class&#34;
    ErrInvalidCharRange      ErrorCode = &#34;invalid character class range&#34;
    ErrInvalidEscape         ErrorCode = &#34;invalid escape sequence&#34;
    ErrInvalidNamedCapture   ErrorCode = &#34;invalid named capture&#34;
    ErrInvalidPerlOp         ErrorCode = &#34;invalid or unsupported Perl syntax&#34;
    ErrInvalidRepeatOp       ErrorCode = &#34;invalid nested repetition operator&#34;
    ErrInvalidRepeatSize     ErrorCode = &#34;invalid repeat count&#34;
    ErrInvalidUTF8           ErrorCode = &#34;invalid UTF-8&#34;
    ErrMissingBracket        ErrorCode = &#34;missing closing ]&#34;
    ErrMissingParen          ErrorCode = &#34;missing closing )&#34;
    ErrMissingRepeatArgument ErrorCode = &#34;missing argument to repetition operator&#34;
    ErrTrailingBackslash     ErrorCode = &#34;trailing backslash at end of expression&#34;
)</pre>
				
			

			

			

			

			
				
				<h3 id="ErrorCode.String">func (ErrorCode) <a href="src/pkg/regexp/syntax/parse.htm#L41">String</a></h3>
				<pre>func (e ErrorCode) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Flags">type <a href="src/pkg/regexp/syntax/parse.htm#L46">Flags</a></h2>
			<pre>type Flags uint16</pre>
			<p>
Flags control the behavior of the parser and record information about regexp context.
</p>


			
				<pre>const (
    FoldCase      Flags = 1 &lt;&lt; iota <span class="comment">// case-insensitive match</span>
    Literal                         <span class="comment">// treat pattern as literal string</span>
    ClassNL                         <span class="comment">// allow character classes like [^a-z] and [[:space:]] to match newline</span>
    DotNL                           <span class="comment">// allow . to match newline</span>
    OneLine                         <span class="comment">// treat ^ and $ as only matching at beginning and end of text</span>
    NonGreedy                       <span class="comment">// make repetition operators default to non-greedy</span>
    PerlX                           <span class="comment">// allow Perl extensions</span>
    UnicodeGroups                   <span class="comment">// allow \p{Han}, \P{Han} for Unicode group and negation</span>
    WasDollar                       <span class="comment">// regexp OpEndText was $, not \z</span>
    Simple                          <span class="comment">// regexp contains no counted repetition</span>

    MatchNL = ClassNL | DotNL

    Perl        = ClassNL | OneLine | PerlX | UnicodeGroups <span class="comment">// as close to Perl as possible</span>
    POSIX Flags = 0                                         <span class="comment">// POSIX syntax</span>
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="Inst">type <a href="src/pkg/regexp/syntax/prog.htm#L78">Inst</a></h2>
			<pre>type Inst struct {
    Op   InstOp
    Out  uint32 <span class="comment">// all but InstMatch, InstFail</span>
    Arg  uint32 <span class="comment">// InstAlt, InstAltMatch, InstCapture, InstEmptyWidth</span>
    Rune []rune
}</pre>
			<p>
An Inst is a single instruction in a regular expression program.
</p>


			

			

			

			

			
				
				<h3 id="Inst.MatchEmptyWidth">func (*Inst) <a href="src/pkg/regexp/syntax/prog.htm#L217">MatchEmptyWidth</a></h3>
				<pre>func (i *Inst) MatchEmptyWidth(before rune, after rune) bool</pre>
				<p>
MatchEmptyWidth returns true if the instruction matches
an empty string between the runes before and after.
It should only be called when i.Op == InstEmptyWidth.
</p>

				
				
			
				
				<h3 id="Inst.MatchRune">func (*Inst) <a href="src/pkg/regexp/syntax/prog.htm#L158">MatchRune</a></h3>
				<pre>func (i *Inst) MatchRune(r rune) bool</pre>
				<p>
MatchRune returns true if the instruction matches (and consumes) r.
It should only be called when i.Op == InstRune.
</p>

				
				
			
				
				<h3 id="Inst.String">func (*Inst) <a href="src/pkg/regexp/syntax/prog.htm#L235">String</a></h3>
				<pre>func (i *Inst) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="InstOp">type <a href="src/pkg/regexp/syntax/prog.htm#L14">InstOp</a></h2>
			<pre>type InstOp uint8</pre>
			<p>
An InstOp is an instruction opcode.
</p>


			
				<pre>const (
    InstAlt InstOp = iota
    InstAltMatch
    InstCapture
    InstEmptyWidth
    InstMatch
    InstFail
    InstNop
    InstRune
    InstRune1
    InstRuneAny
    InstRuneAnyNotNL
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="Op">type <a href="src/pkg/regexp/syntax/regexp.htm#L21">Op</a></h2>
			<pre>type Op uint8</pre>
			<p>
An Op is a single regular expression operator.
</p>


			
				<pre>const (
    OpNoMatch        Op = 1 + iota <span class="comment">// matches no strings</span>
    OpEmptyMatch                   <span class="comment">// matches empty string</span>
    OpLiteral                      <span class="comment">// matches Runes sequence</span>
    OpCharClass                    <span class="comment">// matches Runes interpreted as range pair list</span>
    OpAnyCharNotNL                 <span class="comment">// matches any character</span>
    OpAnyChar                      <span class="comment">// matches any character</span>
    OpBeginLine                    <span class="comment">// matches empty string at beginning of line</span>
    OpEndLine                      <span class="comment">// matches empty string at end of line</span>
    OpBeginText                    <span class="comment">// matches empty string at beginning of text</span>
    OpEndText                      <span class="comment">// matches empty string at end of text</span>
    OpWordBoundary                 <span class="comment">// matches word boundary `\b`</span>
    OpNoWordBoundary               <span class="comment">// matches word non-boundary `\B`</span>
    OpCapture                      <span class="comment">// capturing subexpression with index Cap, optional name Name</span>
    OpStar                         <span class="comment">// matches Sub[0] zero or more times</span>
    OpPlus                         <span class="comment">// matches Sub[0] one or more times</span>
    OpQuest                        <span class="comment">// matches Sub[0] zero or one times</span>
    OpRepeat                       <span class="comment">// matches Sub[0] at least Min times, at most Max (Max == -1 is no limit)</span>
    OpConcat                       <span class="comment">// matches concatenation of Subs</span>
    OpAlternate                    <span class="comment">// matches alternation of Subs</span>
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="Prog">type <a href="src/pkg/regexp/syntax/prog.htm#L7">Prog</a></h2>
			<pre>type Prog struct {
    Inst   []Inst
    Start  int <span class="comment">// index of start instruction</span>
    NumCap int <span class="comment">// number of InstCapture insts in re</span>
}</pre>
			<p>
A Prog is a compiled regular expression program.
</p>


			

			

			

			
				
				<h3 id="Compile">func <a href="src/pkg/regexp/syntax/compile.htm#L70">Compile</a></h3>
				<pre>func Compile(re *Regexp) (*Prog, error)</pre>
				<p>
Compile compiles the regexp into a program to be executed.
The regexp should have been simplified already (returned from re.Simplify).
</p>

				
			

			
				
				<h3 id="Prog.Prefix">func (*Prog) <a href="src/pkg/regexp/syntax/prog.htm#L115">Prefix</a></h3>
				<pre>func (p *Prog) Prefix() (prefix string, complete bool)</pre>
				<p>
Prefix returns a literal string that all matches for the
regexp must start with.  Complete is true if the prefix
is the entire match.
</p>

				
				
			
				
				<h3 id="Prog.StartCond">func (*Prog) <a href="src/pkg/regexp/syntax/prog.htm#L134">StartCond</a></h3>
				<pre>func (p *Prog) StartCond() EmptyOp</pre>
				<p>
StartCond returns the leading empty-width conditions that must
be true in any match.  It returns ^EmptyOp(0) if no matches are possible.
</p>

				
				
			
				
				<h3 id="Prog.String">func (*Prog) <a href="src/pkg/regexp/syntax/prog.htm#L85">String</a></h3>
				<pre>func (p *Prog) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Regexp">type <a href="src/pkg/regexp/syntax/regexp.htm#L8">Regexp</a></h2>
			<pre>type Regexp struct {
    Op       Op <span class="comment">// operator</span>
    Flags    Flags
    Sub      []*Regexp  <span class="comment">// subexpressions, if any</span>
    Sub0     [1]*Regexp <span class="comment">// storage for short Sub</span>
    Rune     []rune     <span class="comment">// matched runes, for OpLiteral, OpCharClass</span>
    Rune0    [2]rune    <span class="comment">// storage for short Rune</span>
    Min, Max int        <span class="comment">// min, max for OpRepeat</span>
    Cap      int        <span class="comment">// capturing index, for OpCapture</span>
    Name     string     <span class="comment">// capturing name, for OpCapture</span>
}</pre>
			<p>
A Regexp is a node in a regular expression syntax tree.
</p>


			

			

			

			
				
				<h3 id="Parse">func <a href="src/pkg/regexp/syntax/parse.htm#L648">Parse</a></h3>
				<pre>func Parse(s string, flags Flags) (*Regexp, error)</pre>
				<p>
Parse parses a regular expression string s, controlled by the specified
Flags, and returns a regular expression parse tree. The syntax is
described in the top-level comment for package regexp.
</p>

				
			

			
				
				<h3 id="Regexp.CapNames">func (*Regexp) <a href="src/pkg/regexp/syntax/regexp.htm#L296">CapNames</a></h3>
				<pre>func (re *Regexp) CapNames() []string</pre>
				<p>
CapNames walks the regexp to find the names of capturing groups.
</p>

				
				
			
				
				<h3 id="Regexp.Equal">func (*Regexp) <a href="src/pkg/regexp/syntax/regexp.htm#L52">Equal</a></h3>
				<pre>func (x *Regexp) Equal(y *Regexp) bool</pre>
				<p>
Equal returns true if x and y have identical structure.
</p>

				
				
			
				
				<h3 id="Regexp.MaxCap">func (*Regexp) <a href="src/pkg/regexp/syntax/regexp.htm#L282">MaxCap</a></h3>
				<pre>func (re *Regexp) MaxCap() int</pre>
				<p>
MaxCap walks the regexp to find the maximum capture index.
</p>

				
				
			
				
				<h3 id="Regexp.Simplify">func (*Regexp) <a href="src/pkg/regexp/syntax/simplify.htm#L4">Simplify</a></h3>
				<pre>func (re *Regexp) Simplify() *Regexp</pre>
				<p>
Simplify returns a regexp equivalent to re but without counted repetitions
and with various other simplifications, such as rewriting /(?:a+)+/ to /a+/.
The resulting regexp will execute correctly but its string representation
will not produce the same parse tree, because capturing parentheses
may have been duplicated or removed.  For example, the simplified form
for /(x){1,2}/ is /(x)(x)?/ but both parentheses capture as $1.
The returned regexp may share structure with or be the original.
</p>

				
				
			
				
				<h3 id="Regexp.String">func (*Regexp) <a href="src/pkg/regexp/syntax/regexp.htm#L235">String</a></h3>
				<pre>func (re *Regexp) String() string</pre>
				
				
				
			
		
		</div>
	

	









</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
