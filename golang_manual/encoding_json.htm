
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>json - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package json</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "encoding/json"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
				<dd><a href="#examples">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package json implements encoding and decoding of JSON objects as defined in
RFC 4627.
</p>
<p>
See &#34;JSON and Go&#34; for an introduction to this package:
<a href="http://golang.org/doc/articles/json_and_go.html">http://golang.org/doc/articles/json_and_go.html</a>
</p>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#Compact">func Compact(dst *bytes.Buffer, src []byte) error</a></dd>
			
				
				<dd><a href="#HTMLEscape">func HTMLEscape(dst *bytes.Buffer, src []byte)</a></dd>
			
				
				<dd><a href="#Indent">func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error</a></dd>
			
				
				<dd><a href="#Marshal">func Marshal(v interface{}) ([]byte, error)</a></dd>
			
				
				<dd><a href="#MarshalIndent">func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)</a></dd>
			
				
				<dd><a href="#Unmarshal">func Unmarshal(data []byte, v interface{}) error</a></dd>
			
			
				
				<dd><a href="#Decoder">type Decoder</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewDecoder">func NewDecoder(r io.Reader) *Decoder</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Decoder.Decode">func (dec *Decoder) Decode(v interface{}) error</a></dd>
				
			
				
				<dd><a href="#Encoder">type Encoder</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewEncoder">func NewEncoder(w io.Writer) *Encoder</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Encoder.Encode">func (enc *Encoder) Encode(v interface{}) error</a></dd>
				
			
				
				<dd><a href="#InvalidUTF8Error">type InvalidUTF8Error</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#InvalidUTF8Error.Error">func (e *InvalidUTF8Error) Error() string</a></dd>
				
			
				
				<dd><a href="#InvalidUnmarshalError">type InvalidUnmarshalError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#InvalidUnmarshalError.Error">func (e *InvalidUnmarshalError) Error() string</a></dd>
				
			
				
				<dd><a href="#Marshaler">type Marshaler</a></dd>
				
				
			
				
				<dd><a href="#MarshalerError">type MarshalerError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MarshalerError.Error">func (e *MarshalerError) Error() string</a></dd>
				
			
				
				<dd><a href="#RawMessage">type RawMessage</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RawMessage.MarshalJSON">func (m *RawMessage) MarshalJSON() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RawMessage.UnmarshalJSON">func (m *RawMessage) UnmarshalJSON(data []byte) error</a></dd>
				
			
				
				<dd><a href="#SyntaxError">type SyntaxError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SyntaxError.Error">func (e *SyntaxError) Error() string</a></dd>
				
			
				
				<dd><a href="#UnmarshalFieldError">type UnmarshalFieldError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnmarshalFieldError.Error">func (e *UnmarshalFieldError) Error() string</a></dd>
				
			
				
				<dd><a href="#UnmarshalTypeError">type UnmarshalTypeError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnmarshalTypeError.Error">func (e *UnmarshalTypeError) Error() string</a></dd>
				
			
				
				<dd><a href="#Unmarshaler">type Unmarshaler</a></dd>
				
				
			
				
				<dd><a href="#UnsupportedTypeError">type UnsupportedTypeError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnsupportedTypeError.Error">func (e *UnsupportedTypeError) Error() string</a></dd>
				
			
				
				<dd><a href="#UnsupportedValueError">type UnsupportedValueError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnsupportedValueError.Error">func (e *UnsupportedValueError) Error() string</a></dd>
				
			
			
				<dd><a href="#bugs">Bugs</a></dd>
			
		</dl>

		
			<h4 id="examples">Examples</h4>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Decoder">Decoder</a></dd>
			
			<dd><a class="exampleLink" href="#example_Marshal">Marshal</a></dd>
			
			<dd><a class="exampleLink" href="#example_Unmarshal">Unmarshal</a></dd>
			
			</dl>
		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/encoding/json/decode.htm">decode.go</a>
			
				<a href="src/pkg/encoding/json/encode.htm">encode.go</a>
			
				<a href="src/pkg/encoding/json/indent.htm">indent.go</a>
			
				<a href="src/pkg/encoding/json/scanner.htm">scanner.go</a>
			
				<a href="src/pkg/encoding/json/stream.htm">stream.go</a>
			
				<a href="src/pkg/encoding/json/tags.htm">tags.go</a>
			
			</span>
			</p>
		
	
		
		
		
			
			
			<h2 id="Compact">func <a href="src/pkg/encoding/json/indent.htm#L1">Compact</a></h2>
			<pre>func Compact(dst *bytes.Buffer, src []byte) error</pre>
			<p>
Compact appends to dst the JSON-encoded src with
insignificant space characters elided.
</p>

			
		
			
			
			<h2 id="HTMLEscape">func <a href="src/pkg/encoding/json/encode.htm#L124">HTMLEscape</a></h2>
			<pre>func HTMLEscape(dst *bytes.Buffer, src []byte)</pre>
			<p>
HTMLEscape appends to dst the JSON-encoded src with &lt;, &gt;, and &amp;
characters inside string literals changed to \u003c, \u003e, \u0026
so that the JSON will be safe to embed inside HTML &lt;script&gt; tags.
For historical reasons, web browsers don&#39;t honor standard HTML
escaping within &lt;script&gt; tags, so an alternative JSON encoding must
be used.
</p>

			
		
			
			
			<h2 id="Indent">func <a href="src/pkg/encoding/json/indent.htm#L55">Indent</a></h2>
			<pre>func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error</pre>
			<p>
Indent appends to dst an indented form of the JSON-encoded src.
Each element in a JSON object or array begins on a new,
indented line beginning with prefix followed by one or more
copies of indent according to the indentation nesting.
The data appended to dst has no trailing newline, to make it easier
to embed inside other formatted JSON data.
</p>

			
		
			
			
			<h2 id="Marshal">func <a href="src/pkg/encoding/json/encode.htm#L95">Marshal</a></h2>
			<pre>func Marshal(v interface{}) ([]byte, error)</pre>
			<p>
Marshal returns the JSON encoding of v.
</p>
<p>
Marshal traverses the value v recursively.
If an encountered value implements the Marshaler interface
and is not a nil pointer, Marshal calls its MarshalJSON method
to produce JSON.  The nil pointer exception is not strictly necessary
but mimics a similar, necessary exception in the behavior of
UnmarshalJSON.
</p>
<p>
Otherwise, Marshal uses the following type-dependent default encodings:
</p>
<p>
Boolean values encode as JSON booleans.
</p>
<p>
Floating point and integer values encode as JSON numbers.
</p>
<p>
String values encode as JSON strings, with each invalid UTF-8 sequence
replaced by the encoding of the Unicode replacement character U+FFFD.
The angle brackets &#34;&lt;&#34; and &#34;&gt;&#34; are escaped to &#34;\u003c&#34; and &#34;\u003e&#34;
to keep some browsers from misinterpreting JSON output as HTML.
</p>
<p>
Array and slice values encode as JSON arrays, except that
[]byte encodes as a base64-encoded string, and a nil slice
encodes as the null JSON object.
</p>
<p>
Struct values encode as JSON objects. Each exported struct field
becomes a member of the object unless
</p>
<pre>- the field&#39;s tag is &#34;-&#34;, or
- the field is empty and its tag specifies the &#34;omitempty&#34; option.
</pre>
<p>
The empty values are false, 0, any
nil pointer or interface value, and any array, slice, map, or string of
length zero. The object&#39;s default key string is the struct field name
but can be specified in the struct field&#39;s tag value. The &#34;json&#34; key in
struct field&#39;s tag value is the key name, followed by an optional comma
and options. Examples:
</p>
<pre>// Field is ignored by this package.
Field int `json:&#34;-&#34;`

// Field appears in JSON as key &#34;myName&#34;.
Field int `json:&#34;myName&#34;`

// Field appears in JSON as key &#34;myName&#34; and
// the field is omitted from the object if its value is empty,
// as defined above.
Field int `json:&#34;myName,omitempty&#34;`

// Field appears in JSON as key &#34;Field&#34; (the default), but
// the field is skipped if empty.
// Note the leading comma.
Field int `json:&#34;,omitempty&#34;`
</pre>
<p>
The &#34;string&#34; option signals that a field is stored as JSON inside a
JSON-encoded string.  This extra level of encoding is sometimes
used when communicating with JavaScript programs:
</p>
<pre>Int64String int64 `json:&#34;,string&#34;`
</pre>
<p>
The key name will be used if it&#39;s a non-empty string consisting of
only Unicode letters, digits, dollar signs, percent signs, hyphens,
underscores and slashes.
</p>
<p>
Map values encode as JSON objects.
The map&#39;s key type must be string; the object keys are used directly
as map keys.
</p>
<p>
Pointer values encode as the value pointed to.
A nil pointer encodes as the null JSON object.
</p>
<p>
Interface values encode as the value contained in the interface.
A nil interface value encodes as the null JSON object.
</p>
<p>
Channel, complex, and function values cannot be encoded in JSON.
Attempting to encode such a value causes Marshal to return
an InvalidTypeError.
</p>
<p>
JSON cannot represent cyclic data structures and Marshal does not
handle them.  Passing cyclic structures to Marshal will result in
an infinite recursion.
</p>

			<div id="example_Marshal" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">type ColorGroup struct {
    ID     int
    Name   string
    Colors []string
}
group := ColorGroup{
    ID:     1,
    Name:   &#34;Reds&#34;,
    Colors: []string{&#34;Crimson&#34;, &#34;Red&#34;, &#34;Ruby&#34;, &#34;Maroon&#34;},
}
b, err := json.Marshal(group)
if err != nil {
    fmt.Println(&#34;error:&#34;, err)
}
os.Stdout.Write(b)
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">{&#34;ID&#34;:1,&#34;Name&#34;:&#34;Reds&#34;,&#34;Colors&#34;:[&#34;Crimson&#34;,&#34;Red&#34;,&#34;Ruby&#34;,&#34;Maroon&#34;]}</pre>
		
	</div>
</div>

		
			
			
			<h2 id="MarshalIndent">func <a href="src/pkg/encoding/json/encode.htm#L105">MarshalIndent</a></h2>
			<pre>func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error)</pre>
			<p>
MarshalIndent is like Marshal but applies Indent to format the output.
</p>

			
		
			
			
			<h2 id="Unmarshal">func <a href="src/pkg/encoding/json/decode.htm#L44">Unmarshal</a></h2>
			<pre>func Unmarshal(data []byte, v interface{}) error</pre>
			<p>
Unmarshal parses the JSON-encoded data and stores the result
in the value pointed to by v.
</p>
<p>
Unmarshal uses the inverse of the encodings that
Marshal uses, allocating maps, slices, and pointers as necessary,
with the following additional rules:
</p>
<p>
To unmarshal JSON into a pointer, Unmarshal first handles the case of
the JSON being the JSON literal null.  In that case, Unmarshal sets
the pointer to nil.  Otherwise, Unmarshal unmarshals the JSON into
the value pointed at by the pointer.  If the pointer is nil, Unmarshal
allocates a new value for it to point to.
</p>
<p>
To unmarshal JSON into an interface value, Unmarshal unmarshals
the JSON into the concrete value contained in the interface value.
If the interface value is nil, that is, has no concrete value stored in it,
Unmarshal stores one of these in the interface value:
</p>
<pre>bool, for JSON booleans
float64, for JSON numbers
string, for JSON strings
[]interface{}, for JSON arrays
map[string]interface{}, for JSON objects
nil for JSON null
</pre>
<p>
If a JSON value is not appropriate for a given target type,
or if a JSON number overflows the target type, Unmarshal
skips that field and completes the unmarshalling as best it can.
If no more serious errors are encountered, Unmarshal returns
an UnmarshalTypeError describing the earliest such error.
</p>

			<div id="example_Unmarshal" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">var jsonBlob = []byte(`[
    {&#34;Name&#34;: &#34;Platypus&#34;, &#34;Order&#34;: &#34;Monotremata&#34;},
    {&#34;Name&#34;: &#34;Quoll&#34;,    &#34;Order&#34;: &#34;Dasyuromorphia&#34;}
]`)
type Animal struct {
    Name  string
    Order string
}
var animals []Animal
err := json.Unmarshal(jsonBlob, &amp;animals)
if err != nil {
    fmt.Println(&#34;error:&#34;, err)
}
fmt.Printf(&#34;%+v&#34;, animals)
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">[{Name:Platypus Order:Monotremata} {Name:Quoll Order:Dasyuromorphia}]</pre>
		
	</div>
</div>

		
		
			
			
			<h2 id="Decoder">type <a href="src/pkg/encoding/json/stream.htm#L3">Decoder</a></h2>
			<pre>type Decoder struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Decoder reads and decodes JSON objects from an input stream.
</p>


			

			

			<div id="example_Decoder" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		<p>This example uses a Decoder to decode a stream of distinct JSON values.
</p>
		<p>Code:</p>
		<pre class="code">const jsonStream = `
    {&#34;Name&#34;: &#34;Ed&#34;, &#34;Text&#34;: &#34;Knock knock.&#34;}
    {&#34;Name&#34;: &#34;Sam&#34;, &#34;Text&#34;: &#34;Who&#39;s there?&#34;}
    {&#34;Name&#34;: &#34;Ed&#34;, &#34;Text&#34;: &#34;Go fmt.&#34;}
    {&#34;Name&#34;: &#34;Sam&#34;, &#34;Text&#34;: &#34;Go fmt who?&#34;}
    {&#34;Name&#34;: &#34;Ed&#34;, &#34;Text&#34;: &#34;Go fmt yourself!&#34;}
`
type Message struct {
    Name, Text string
}
dec := json.NewDecoder(strings.NewReader(jsonStream))
for {
    var m Message
    if err := dec.Decode(&amp;m); err == io.EOF {
        break
    } else if err != nil {
        log.Fatal(err)
    }
    fmt.Printf(&#34;%s: %s\n&#34;, m.Name, m.Text)
}
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">Ed: Knock knock.
Sam: Who&#39;s there?
Ed: Go fmt.
Sam: Go fmt who?
Ed: Go fmt yourself!</pre>
		
	</div>
</div>


			
				
				<h3 id="NewDecoder">func <a href="src/pkg/encoding/json/stream.htm#L15">NewDecoder</a></h3>
				<pre>func NewDecoder(r io.Reader) *Decoder</pre>
				<p>
NewDecoder returns a new decoder that reads from r.
</p>
<p>
The decoder introduces its own buffering and may
read data from r beyond the JSON values requested.
</p>

				
			

			
				
				<h3 id="Decoder.Decode">func (*Decoder) <a href="src/pkg/encoding/json/stream.htm#L24">Decode</a></h3>
				<pre>func (dec *Decoder) Decode(v interface{}) error</pre>
				<p>
Decode reads the next JSON-encoded value from its
input and stores it in the value pointed to by v.
</p>
<p>
See the documentation for Unmarshal for details about
the conversion of JSON into a Go value.
</p>

				
				
			
		
			
			
			<h2 id="Encoder">type <a href="src/pkg/encoding/json/stream.htm#L119">Encoder</a></h2>
			<pre>type Encoder struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
An Encoder writes JSON objects to an output stream.
</p>


			

			

			

			
				
				<h3 id="NewEncoder">func <a href="src/pkg/encoding/json/stream.htm#L126">NewEncoder</a></h3>
				<pre>func NewEncoder(w io.Writer) *Encoder</pre>
				<p>
NewEncoder returns a new encoder that writes to w.
</p>

				
			

			
				
				<h3 id="Encoder.Encode">func (*Encoder) <a href="src/pkg/encoding/json/stream.htm#L134">Encode</a></h3>
				<pre>func (enc *Encoder) Encode(v interface{}) error</pre>
				<p>
Encode writes the JSON encoding of v to the connection.
</p>
<p>
See the documentation for Marshal for details about the
conversion of Go values to JSON.
</p>

				
				
			
		
			
			
			<h2 id="InvalidUTF8Error">type <a href="src/pkg/encoding/json/encode.htm#L167">InvalidUTF8Error</a></h2>
			<pre>type InvalidUTF8Error struct {
    S string
}</pre>
			

			

			

			

			

			
				
				<h3 id="InvalidUTF8Error.Error">func (*InvalidUTF8Error) <a href="src/pkg/encoding/json/encode.htm#L171">Error</a></h3>
				<pre>func (e *InvalidUTF8Error) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="InvalidUnmarshalError">type <a href="src/pkg/encoding/json/decode.htm#L92">InvalidUnmarshalError</a></h2>
			<pre>type InvalidUnmarshalError struct {
    Type reflect.Type
}</pre>
			<p>
An InvalidUnmarshalError describes an invalid argument passed to Unmarshal.
(The argument to Unmarshal must be a non-nil pointer.)
</p>


			

			

			

			

			
				
				<h3 id="InvalidUnmarshalError.Error">func (*InvalidUnmarshalError) <a href="src/pkg/encoding/json/decode.htm#L96">Error</a></h3>
				<pre>func (e *InvalidUnmarshalError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="Marshaler">type <a href="src/pkg/encoding/json/encode.htm#L146">Marshaler</a></h2>
			<pre>type Marshaler interface {
    MarshalJSON() ([]byte, error)
}</pre>
			<p>
Marshaler is the interface implemented by objects that
can marshal themselves into valid JSON.
</p>


			

			

			

			

			
		
			
			
			<h2 id="MarshalerError">type <a href="src/pkg/encoding/json/encode.htm#L175">MarshalerError</a></h2>
			<pre>type MarshalerError struct {
    Type reflect.Type
    Err  error
}</pre>
			

			

			

			

			

			
				
				<h3 id="MarshalerError.Error">func (*MarshalerError) <a href="src/pkg/encoding/json/encode.htm#L180">Error</a></h3>
				<pre>func (e *MarshalerError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="RawMessage">type <a href="src/pkg/encoding/json/stream.htm#L161">RawMessage</a></h2>
			<pre>type RawMessage []byte</pre>
			<p>
RawMessage is a raw encoded JSON object.
It implements Marshaler and Unmarshaler and can
be used to delay JSON decoding or precompute a JSON encoding.
</p>


			

			

			

			

			
				
				<h3 id="RawMessage.MarshalJSON">func (*RawMessage) <a href="src/pkg/encoding/json/stream.htm#L164">MarshalJSON</a></h3>
				<pre>func (m *RawMessage) MarshalJSON() ([]byte, error)</pre>
				<p>
MarshalJSON returns *m as the JSON encoding of m.
</p>

				
				
			
				
				<h3 id="RawMessage.UnmarshalJSON">func (*RawMessage) <a href="src/pkg/encoding/json/stream.htm#L169">UnmarshalJSON</a></h3>
				<pre>func (m *RawMessage) UnmarshalJSON(data []byte) error</pre>
				<p>
UnmarshalJSON sets *m to a copy of data.
</p>

				
				
			
		
			
			
			<h2 id="SyntaxError">type <a href="src/pkg/encoding/json/scanner.htm#L47">SyntaxError</a></h2>
			<pre>type SyntaxError struct {
    Offset int64 <span class="comment">// error occurred after reading Offset bytes</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A SyntaxError is a description of a JSON syntax error.
</p>


			

			

			

			

			
				
				<h3 id="SyntaxError.Error">func (*SyntaxError) <a href="src/pkg/encoding/json/scanner.htm#L52">Error</a></h3>
				<pre>func (e *SyntaxError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="UnmarshalFieldError">type <a href="src/pkg/encoding/json/decode.htm#L80">UnmarshalFieldError</a></h2>
			<pre>type UnmarshalFieldError struct {
    Key   string
    Type  reflect.Type
    Field reflect.StructField
}</pre>
			<p>
An UnmarshalFieldError describes a JSON object key that
led to an unexported (and therefore unwritable) struct field.
</p>


			

			

			

			

			
				
				<h3 id="UnmarshalFieldError.Error">func (*UnmarshalFieldError) <a href="src/pkg/encoding/json/decode.htm#L86">Error</a></h3>
				<pre>func (e *UnmarshalFieldError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="UnmarshalTypeError">type <a href="src/pkg/encoding/json/decode.htm#L69">UnmarshalTypeError</a></h2>
			<pre>type UnmarshalTypeError struct {
    Value string       <span class="comment">// description of JSON value - &#34;bool&#34;, &#34;array&#34;, &#34;number -5&#34;</span>
    Type  reflect.Type <span class="comment">// type of Go value it could not be assigned to</span>
}</pre>
			<p>
An UnmarshalTypeError describes a JSON value that was
not appropriate for a value of a specific Go type.
</p>


			

			

			

			

			
				
				<h3 id="UnmarshalTypeError.Error">func (*UnmarshalTypeError) <a href="src/pkg/encoding/json/decode.htm#L74">Error</a></h3>
				<pre>func (e *UnmarshalTypeError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="Unmarshaler">type <a href="src/pkg/encoding/json/decode.htm#L63">Unmarshaler</a></h2>
			<pre>type Unmarshaler interface {
    UnmarshalJSON([]byte) error
}</pre>
			<p>
Unmarshaler is the interface implemented by objects
that can unmarshal a JSON description of themselves.
The input can be assumed to be a valid JSON object
encoding.  UnmarshalJSON must copy the JSON data
if it wishes to retain the data after returning.
</p>


			

			

			

			

			
		
			
			
			<h2 id="UnsupportedTypeError">type <a href="src/pkg/encoding/json/encode.htm#L150">UnsupportedTypeError</a></h2>
			<pre>type UnsupportedTypeError struct {
    Type reflect.Type
}</pre>
			

			

			

			

			

			
				
				<h3 id="UnsupportedTypeError.Error">func (*UnsupportedTypeError) <a href="src/pkg/encoding/json/encode.htm#L154">Error</a></h3>
				<pre>func (e *UnsupportedTypeError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="UnsupportedValueError">type <a href="src/pkg/encoding/json/encode.htm#L158">UnsupportedValueError</a></h2>
			<pre>type UnsupportedValueError struct {
    Value reflect.Value
    Str   string
}</pre>
			

			

			

			

			

			
				
				<h3 id="UnsupportedValueError.Error">func (*UnsupportedValueError) <a href="src/pkg/encoding/json/encode.htm#L163">Error</a></h3>
				<pre>func (e *UnsupportedValueError) Error() string</pre>
				
				
				
			
		
		</div>
	

	
		<h2 id="bugs">Bugs</h2>
		
		<p>
This package ignores anonymous (embedded) struct fields
during encoding and decoding.  A future version may assign meaning
to them.  To force an anonymous field to be ignored in all future
versions of this package, use an explicit `json:&#34;-&#34;` tag in the struct
definition.
</p>

		
	









</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
