
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>template - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package template</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "text/template"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
				<dd><a href="#examples">Examples</a></dd>
			
			
				<dd><a href="#subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package template implements data-driven templates for generating textual output.
</p>
<p>
To generate HTML output, see package html/template, which has the same interface
as this package but automatically secures HTML output against certain attacks.
</p>
<p>
Templates are executed by applying them to a data structure. Annotations in the
template refer to elements of the data structure (typically a field of a struct
or a key in a map) to control execution and derive values to be displayed.
Execution of the template walks the structure and sets the cursor, represented
by a period &#39;.&#39; and called &#34;dot&#34;, to the value at the current location in the
structure as execution proceeds.
</p>
<p>
The input text for a template is UTF-8-encoded text in any format.
&#34;Actions&#34;--data evaluations or control structures--are delimited by
&#34;{{&#34; and &#34;}}&#34;; all text outside actions is copied to the output unchanged.
Actions may not span newlines, although comments can.
</p>
<p>
Once constructed, a template may be executed safely in parallel.
</p>
<p>
Here is a trivial example that prints &#34;17 items are made of wool&#34;.
</p>
<pre>type Inventory struct {
	Material string
	Count    uint
}
sweaters := Inventory{&#34;wool&#34;, 17}
tmpl, err := template.New(&#34;test&#34;).Parse(&#34;{{.Count}} items are made of {{.Material}}&#34;)
if err != nil { panic(err) }
err = tmpl.Execute(os.Stdout, sweaters)
if err != nil { panic(err) }
</pre>
<p>
More intricate examples appear below.
</p>
<h3 id="Actions">Actions</h3>
<p>
Here is the list of actions. &#34;Arguments&#34; and &#34;pipelines&#34; are evaluations of
data, defined in detail below.
</p>
<pre>{{/* a comment */}}
	A comment; discarded. May contain newlines.
	Comments do not nest.

{{pipeline}}
	The default textual representation of the value of the pipeline
	is copied to the output.

{{if pipeline}} T1 {{end}}
	If the value of the pipeline is empty, no output is generated;
	otherwise, T1 is executed.  The empty values are false, 0, any
	nil pointer or interface value, and any array, slice, map, or
	string of length zero.
	Dot is unaffected.

{{if pipeline}} T1 {{else}} T0 {{end}}
	If the value of the pipeline is empty, T0 is executed;
	otherwise, T1 is executed.  Dot is unaffected.

{{range pipeline}} T1 {{end}}
	The value of the pipeline must be an array, slice, or map. If
	the value of the pipeline has length zero, nothing is output;
	otherwise, dot is set to the successive elements of the array,
	slice, or map and T1 is executed. If the value is a map and the
	keys are of basic type with a defined order (&#34;comparable&#34;), the
	elements will be visited in sorted key order.

{{range pipeline}} T1 {{else}} T0 {{end}}
	The value of the pipeline must be an array, slice, or map. If
	the value of the pipeline has length zero, dot is unaffected and
	T0 is executed; otherwise, dot is set to the successive elements
	of the array, slice, or map and T1 is executed.

{{template &#34;name&#34;}}
	The template with the specified name is executed with nil data.

{{template &#34;name&#34; pipeline}}
	The template with the specified name is executed with dot set
	to the value of the pipeline.

{{with pipeline}} T1 {{end}}
	If the value of the pipeline is empty, no output is generated;
	otherwise, dot is set to the value of the pipeline and T1 is
	executed.

{{with pipeline}} T1 {{else}} T0 {{end}}
	If the value of the pipeline is empty, dot is unaffected and T0
	is executed; otherwise, dot is set to the value of the pipeline
	and T1 is executed.
</pre>
<h3 id="Arguments">Arguments</h3>
<p>
An argument is a simple value, denoted by one of the following.
</p>
<pre>- A boolean, string, character, integer, floating-point, imaginary
  or complex constant in Go syntax. These behave like Go&#39;s untyped
  constants, although raw strings may not span newlines.
- The character &#39;.&#39; (period):
	.
  The result is the value of dot.
- A variable name, which is a (possibly empty) alphanumeric string
  preceded by a dollar sign, such as
	$piOver2
  or
	$
  The result is the value of the variable.
  Variables are described below.
- The name of a field of the data, which must be a struct, preceded
  by a period, such as
	.Field
  The result is the value of the field. Field invocations may be
  chained:
    .Field1.Field2
  Fields can also be evaluated on variables, including chaining:
    $x.Field1.Field2
- The name of a key of the data, which must be a map, preceded
  by a period, such as
	.Key
  The result is the map element value indexed by the key.
  Key invocations may be chained and combined with fields to any
  depth:
    .Field1.Key1.Field2.Key2
  Although the key must be an alphanumeric identifier, unlike with
  field names they do not need to start with an upper case letter.
  Keys can also be evaluated on variables, including chaining:
    $x.key1.key2
- The name of a niladic method of the data, preceded by a period,
  such as
	.Method
  The result is the value of invoking the method with dot as the
  receiver, dot.Method(). Such a method must have one return value (of
  any type) or two return values, the second of which is an error.
  If it has two and the returned error is non-nil, execution terminates
  and an error is returned to the caller as the value of Execute.
  Method invocations may be chained and combined with fields and keys
  to any depth:
    .Field1.Key1.Method1.Field2.Key2.Method2
  Methods can also be evaluated on variables, including chaining:
    $x.Method1.Field
- The name of a niladic function, such as
	fun
  The result is the value of invoking the function, fun(). The return
  types and values behave as in methods. Functions and function
  names are described below.
</pre>
<p>
Arguments may evaluate to any type; if they are pointers the implementation
automatically indirects to the base type when required.
If an evaluation yields a function value, such as a function-valued
field of a struct, the function is not invoked automatically, but it
can be used as a truth value for an if action and the like. To invoke
it, use the call function, defined below.
</p>
<p>
A pipeline is a possibly chained sequence of &#34;commands&#34;. A command is a simple
value (argument) or a function or method call, possibly with multiple arguments:
</p>
<pre>Argument
	The result is the value of evaluating the argument.
.Method [Argument...]
	The method can be alone or the last element of a chain but,
	unlike methods in the middle of a chain, it can take arguments.
	The result is the value of calling the method with the
	arguments:
		dot.Method(Argument1, etc.)
functionName [Argument...]
	The result is the value of calling the function associated
	with the name:
		function(Argument1, etc.)
	Functions and function names are described below.
</pre>
<h3 id="Pipelines">Pipelines</h3>
<p>
A pipeline may be &#34;chained&#34; by separating a sequence of commands with pipeline
characters &#39;|&#39;. In a chained pipeline, the result of the each command is
passed as the last argument of the following command. The output of the final
command in the pipeline is the value of the pipeline.
</p>
<p>
The output of a command will be either one value or two values, the second of
which has type error. If that second value is present and evaluates to
non-nil, execution terminates and the error is returned to the caller of
Execute.
</p>
<h3 id="Variables">Variables</h3>
<p>
A pipeline inside an action may initialize a variable to capture the result.
The initialization has syntax
</p>
<pre>$variable := pipeline
</pre>
<p>
where $variable is the name of the variable. An action that declares a
variable produces no output.
</p>
<p>
If a &#34;range&#34; action initializes a variable, the variable is set to the
successive elements of the iteration.  Also, a &#34;range&#34; may declare two
variables, separated by a comma:
</p>
<pre>$index, $element := pipeline
</pre>
<p>
in which case $index and $element are set to the successive values of the
array/slice index or map key and element, respectively.  Note that if there is
only one variable, it is assigned the element; this is opposite to the
convention in Go range clauses.
</p>
<p>
A variable&#39;s scope extends to the &#34;end&#34; action of the control structure (&#34;if&#34;,
&#34;with&#34;, or &#34;range&#34;) in which it is declared, or to the end of the template if
there is no such control structure.  A template invocation does not inherit
variables from the point of its invocation.
</p>
<p>
When execution begins, $ is set to the data argument passed to Execute, that is,
to the starting value of dot.
</p>
<h3 id="Examples">Examples</h3>
<p>
Here are some example one-line templates demonstrating pipelines and variables.
All produce the quoted word &#34;output&#34;:
</p>
<pre>{{&#34;\&#34;output\&#34;&#34;}}
	A string constant.
{{`&#34;output&#34;`}}
	A raw string constant.
{{printf &#34;%q&#34; &#34;output&#34;}}
	A function call.
{{&#34;output&#34; | printf &#34;%q&#34;}}
	A function call whose final argument comes from the previous
	command.
{{&#34;put&#34; | printf &#34;%s%s&#34; &#34;out&#34; | printf &#34;%q&#34;}}
	A more elaborate call.
{{&#34;output&#34; | printf &#34;%s&#34; | printf &#34;%q&#34;}}
	A longer chain.
{{with &#34;output&#34;}}{{printf &#34;%q&#34; .}}{{end}}
	A with action using dot.
{{with $x := &#34;output&#34; | printf &#34;%q&#34;}}{{$x}}{{end}}
	A with action that creates and uses a variable.
{{with $x := &#34;output&#34;}}{{printf &#34;%q&#34; $x}}{{end}}
	A with action that uses the variable in another action.
{{with $x := &#34;output&#34;}}{{$x | printf &#34;%q&#34;}}{{end}}
	The same, but pipelined.
</pre>
<h3 id="Functions">Functions</h3>
<p>
During execution functions are found in two function maps: first in the
template, then in the global function map. By default, no functions are defined
in the template but the Funcs method can be used to add them.
</p>
<p>
Predefined global functions are named as follows.
</p>
<pre>and
	Returns the boolean AND of its arguments by returning the
	first empty argument or the last argument, that is,
	&#34;and x y&#34; behaves as &#34;if x then y else x&#34;. All the
	arguments are evaluated.
call
	Returns the result of calling the first argument, which
	must be a function, with the remaining arguments as parameters.
	Thus &#34;call .X.Y 1 2&#34; is, in Go notation, dot.X.Y(1, 2) where
	Y is a func-valued field, map entry, or the like.
	The first argument must be the result of an evaluation
	that yields a value of function type (as distinct from
	a predefined function such as print). The function must
	return either one or two result values, the second of which
	is of type error. If the arguments don&#39;t match the function
	or the returned error value is non-nil, execution stops.
html
	Returns the escaped HTML equivalent of the textual
	representation of its arguments.
index
	Returns the result of indexing its first argument by the
	following arguments. Thus &#34;index x 1 2 3&#34; is, in Go syntax,
	x[1][2][3]. Each indexed item must be a map, slice, or array.
js
	Returns the escaped JavaScript equivalent of the textual
	representation of its arguments.
len
	Returns the integer length of its argument.
not
	Returns the boolean negation of its single argument.
or
	Returns the boolean OR of its arguments by returning the
	first non-empty argument or the last argument, that is,
	&#34;or x y&#34; behaves as &#34;if x then x else y&#34;. All the
	arguments are evaluated.
print
	An alias for fmt.Sprint
printf
	An alias for fmt.Sprintf
println
	An alias for fmt.Sprintln
urlquery
	Returns the escaped value of the textual representation of
	its arguments in a form suitable for embedding in a URL query.
</pre>
<p>
The boolean functions take any zero value to be false and a non-zero value to
be true.
</p>
<h3 id="Associated_templates">Associated templates</h3>
<p>
Each template is named by a string specified when it is created. Also, each
template is associated with zero or more other templates that it may invoke by
name; such associations are transitive and form a name space of templates.
</p>
<p>
A template may use a template invocation to instantiate another associated
template; see the explanation of the &#34;template&#34; action above. The name must be
that of a template associated with the template that contains the invocation.
</p>
<h3 id="Nested_template_definitions">Nested template definitions</h3>
<p>
When parsing a template, another template may be defined and associated with the
template being parsed. Template definitions must appear at the top level of the
template, much like global variables in a Go program.
</p>
<p>
The syntax of such definitions is to surround each template declaration with a
&#34;define&#34; and &#34;end&#34; action.
</p>
<p>
The define action names the template being created by providing a string
constant. Here is a simple example:
</p>
<pre>`{{define &#34;T1&#34;}}ONE{{end}}
{{define &#34;T2&#34;}}TWO{{end}}
{{define &#34;T3&#34;}}{{template &#34;T1&#34;}} {{template &#34;T2&#34;}}{{end}}
{{template &#34;T3&#34;}}`
</pre>
<p>
This defines two templates, T1 and T2, and a third T3 that invokes the other two
when it is executed. Finally it invokes T3. If executed this template will
produce the text
</p>
<pre>ONE TWO
</pre>
<p>
By construction, a template may reside in only one association. If it&#39;s
necessary to have a template addressable from multiple associations, the
template definition must be parsed multiple times to create distinct *Template
values, or must be copied with the Clone or AddParseTree method.
</p>
<p>
Parse may be called multiple times to assemble the various associated templates;
see the ParseFiles and ParseGlob functions and methods for simple ways to parse
related templates stored in files.
</p>
<p>
A template may be executed directly or through ExecuteTemplate, which executes
an associated template identified by name. To invoke our example above, we
might write,
</p>
<pre>err := tmpl.Execute(os.Stdout, &#34;no data needed&#34;)
if err != nil {
	log.Fatalf(&#34;execution failed: %s&#34;, err)
}
</pre>
<p>
or to invoke a particular template explicitly by name,
</p>
<pre>err := tmpl.ExecuteTemplate(os.Stdout, &#34;T2&#34;, &#34;no data needed&#34;)
if err != nil {
	log.Fatalf(&#34;execution failed: %s&#34;, err)
}
</pre>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#HTMLEscape">func HTMLEscape(w io.Writer, b []byte)</a></dd>
			
				
				<dd><a href="#HTMLEscapeString">func HTMLEscapeString(s string) string</a></dd>
			
				
				<dd><a href="#HTMLEscaper">func HTMLEscaper(args ...interface{}) string</a></dd>
			
				
				<dd><a href="#JSEscape">func JSEscape(w io.Writer, b []byte)</a></dd>
			
				
				<dd><a href="#JSEscapeString">func JSEscapeString(s string) string</a></dd>
			
				
				<dd><a href="#JSEscaper">func JSEscaper(args ...interface{}) string</a></dd>
			
				
				<dd><a href="#URLQueryEscaper">func URLQueryEscaper(args ...interface{}) string</a></dd>
			
			
				
				<dd><a href="#FuncMap">type FuncMap</a></dd>
				
				
			
				
				<dd><a href="#Template">type Template</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Must">func Must(t *Template, err error) *Template</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#New">func New(name string) *Template</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseFiles">func ParseFiles(filenames ...string) (*Template, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseGlob">func ParseGlob(pattern string) (*Template, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Template.AddParseTree">func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Template.Clone">func (t *Template) Clone() (*Template, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Template.Delims">func (t *Template) Delims(left, right string) *Template</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Template.Execute">func (t *Template) Execute(wr io.Writer, data interface{}) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Template.ExecuteTemplate">func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Template.Funcs">func (t *Template) Funcs(funcMap FuncMap) *Template</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Template.Lookup">func (t *Template) Lookup(name string) *Template</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Template.Name">func (t *Template) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Template.New">func (t *Template) New(name string) *Template</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Template.Parse">func (t *Template) Parse(text string) (*Template, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Template.ParseFiles">func (t *Template) ParseFiles(filenames ...string) (*Template, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Template.ParseGlob">func (t *Template) ParseGlob(pattern string) (*Template, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Template.Templates">func (t *Template) Templates() []*Template</a></dd>
				
			
			
		</dl>

		
			<h4 id="examples">Examples</h4>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Template">Template</a></dd>
			
			<dd><a class="exampleLink" href="#example_Template_func">Template (Func)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Template_glob">Template (Glob)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Template_helpers">Template (Helpers)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Template_share">Template (Share)</a></dd>
			
			</dl>
		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/text/template/doc.htm">doc.go</a>
			
				<a href="src/pkg/text/template/exec.htm">exec.go</a>
			
				<a href="src/pkg/text/template/funcs.htm">funcs.go</a>
			
				<a href="src/pkg/text/template/helper.htm">helper.go</a>
			
				<a href="src/pkg/text/template/template.htm">template.go</a>
			
			</span>
			</p>
		
	
		
		
		
			
			
			<h2 id="HTMLEscape">func <a href="src/pkg/text/template/funcs.htm#L246">HTMLEscape</a></h2>
			<pre>func HTMLEscape(w io.Writer, b []byte)</pre>
			<p>
HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.
</p>

			
		
			
			
			<h2 id="HTMLEscapeString">func <a href="src/pkg/text/template/funcs.htm#L272">HTMLEscapeString</a></h2>
			<pre>func HTMLEscapeString(s string) string</pre>
			<p>
HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.
</p>

			
		
			
			
			<h2 id="HTMLEscaper">func <a href="src/pkg/text/template/funcs.htm#L284">HTMLEscaper</a></h2>
			<pre>func HTMLEscaper(args ...interface{}) string</pre>
			<p>
HTMLEscaper returns the escaped HTML equivalent of the textual
representation of its arguments.
</p>

			
		
			
			
			<h2 id="JSEscape">func <a href="src/pkg/text/template/funcs.htm#L310">JSEscape</a></h2>
			<pre>func JSEscape(w io.Writer, b []byte)</pre>
			<p>
JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.
</p>

			
		
			
			
			<h2 id="JSEscapeString">func <a href="src/pkg/text/template/funcs.htm#L357">JSEscapeString</a></h2>
			<pre>func JSEscapeString(s string) string</pre>
			<p>
JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.
</p>

			
		
			
			
			<h2 id="JSEscaper">func <a href="src/pkg/text/template/funcs.htm#L377">JSEscaper</a></h2>
			<pre>func JSEscaper(args ...interface{}) string</pre>
			<p>
JSEscaper returns the escaped JavaScript equivalent of the textual
representation of its arguments.
</p>

			
		
			
			
			<h2 id="URLQueryEscaper">func <a href="src/pkg/text/template/funcs.htm#L391">URLQueryEscaper</a></h2>
			<pre>func URLQueryEscaper(args ...interface{}) string</pre>
			<p>
URLQueryEscaper returns the escaped value of the textual representation of
its arguments in a form suitable for embedding in a URL query.
</p>

			
		
		
			
			
			<h2 id="FuncMap">type <a href="src/pkg/text/template/funcs.htm#L13">FuncMap</a></h2>
			<pre>type FuncMap map[string]interface{}</pre>
			<p>
FuncMap is the type of the map defining the mapping from names to functions.
Each function must have either a single return value, or two return values of
which the second has type error. In that case, if the second (error)
argument evaluates to non-nil during execution, execution terminates and
Execute returns that error.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Template">type <a href="src/pkg/text/template/template.htm#L16">Template</a></h2>
			<pre>type Template struct {
    *parse.Tree
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Template is the representation of a parsed template. The *parse.Tree
field is exported only for use by html/template and should be treated
as unexported by all other clients.
</p>


			

			

			<div id="example_Template" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code"><span class="comment">// Define a template.</span>
const letter = `
Dear {{.Name}},
{{if .Attended}}
It was a pleasure to see you at the wedding.{{else}}
It is a shame you couldn&#39;t make it to the wedding.{{end}}
{{with .Gift}}Thank you for the lovely {{.}}.
{{end}}
Best wishes,
Josie
`

<span class="comment">// Prepare some data to insert into the template.</span>
type Recipient struct {
    Name, Gift string
    Attended   bool
}
var recipients = []Recipient{
    {&#34;Aunt Mildred&#34;, &#34;bone china tea set&#34;, true},
    {&#34;Uncle John&#34;, &#34;moleskin pants&#34;, false},
    {&#34;Cousin Rodney&#34;, &#34;&#34;, false},
}

<span class="comment">// Create a new template and parse the letter into it.</span>
t := template.Must(template.New(&#34;letter&#34;).Parse(letter))

<span class="comment">// Execute the template for each recipient.</span>
for _, r := range recipients {
    err := t.Execute(os.Stdout, r)
    if err != nil {
        log.Println(&#34;executing template:&#34;, err)
    }
}

<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">Dear Aunt Mildred,

It was a pleasure to see you at the wedding.
Thank you for the lovely bone china tea set.

Best wishes,
Josie

Dear Uncle John,

It is a shame you couldn&#39;t make it to the wedding.
Thank you for the lovely moleskin pants.

Best wishes,
Josie

Dear Cousin Rodney,

It is a shame you couldn&#39;t make it to the wedding.

Best wishes,
Josie</pre>
		
	</div>
</div>
<div id="example_Template_func" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example (Func)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example (Func)</span></p>
		<p>This example demonstrates a custom function to process template text.
It installs the strings.Title function and uses it to
Make Title Text Look Good In Our Template&#39;s Output.
</p>
		<p>Code:</p>
		<pre class="code"><span class="comment">// First we create a FuncMap with which to register the function.</span>
funcMap := template.FuncMap{
    <span class="comment">// The name &#34;title&#34; is what the function will be called in the template text.</span>
    &#34;title&#34;: strings.Title,
}

<span class="comment">// A simple template definition to test our function.</span>
<span class="comment">// We print the input text several ways:</span>
<span class="comment">// - the original</span>
<span class="comment">// - title-cased</span>
<span class="comment">// - title-cased and then printed with %q</span>
<span class="comment">// - printed with %q and then title-cased.</span>
const templateText = `
Input: {{printf &#34;%q&#34; .}}
Output 0: {{title .}}
Output 1: {{title . | printf &#34;%q&#34;}}
Output 2: {{printf &#34;%q&#34; . | title}}
`

<span class="comment">// Create a template, add the function map, and parse the text.</span>
tmpl, err := template.New(&#34;titleTest&#34;).Funcs(funcMap).Parse(templateText)
if err != nil {
    log.Fatalf(&#34;parsing: %s&#34;, err)
}

<span class="comment">// Run the template to verify the output.</span>
err = tmpl.Execute(os.Stdout, &#34;the go programming language&#34;)
if err != nil {
    log.Fatalf(&#34;execution: %s&#34;, err)
}

<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">Input: &#34;the go programming language&#34;
Output 0: The Go Programming Language
Output 1: &#34;The Go Programming Language&#34;
Output 2: &#34;The Go Programming Language&#34;</pre>
		
	</div>
</div>
<div id="example_Template_glob" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example (Glob)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example (Glob)</span></p>
		<p>Here we demonstrate loading a set of templates from a directory.
</p>
		<p>Code:</p>
		<pre class="code"><span class="comment">// Here we create a temporary directory and populate it with our sample</span>
<span class="comment">// template definition files; usually the template files would already</span>
<span class="comment">// exist in some location known to the program.</span>
dir := createTestDir([]templateFile{
    <span class="comment">// T0.tmpl is a plain template file that just invokes T1.</span>
    {&#34;T0.tmpl&#34;, `T0 invokes T1: ({{template &#34;T1&#34;}})`},
    <span class="comment">// T1.tmpl defines a template, T1 that invokes T2.</span>
    {&#34;T1.tmpl&#34;, `{{define &#34;T1&#34;}}T1 invokes T2: ({{template &#34;T2&#34;}}){{end}}`},
    <span class="comment">// T2.tmpl defines a template T2.</span>
    {&#34;T2.tmpl&#34;, `{{define &#34;T2&#34;}}This is T2{{end}}`},
})
<span class="comment">// Clean up after the test; another quirk of running as an example.</span>
defer os.RemoveAll(dir)

<span class="comment">// pattern is the glob pattern used to find all the template files.</span>
pattern := filepath.Join(dir, &#34;*.tmpl&#34;)

<span class="comment">// Here starts the example proper.</span>
<span class="comment">// T0.tmpl is the first name matched, so it becomes the starting template,</span>
<span class="comment">// the value returned by ParseGlob.</span>
tmpl := template.Must(template.ParseGlob(pattern))

err := tmpl.Execute(os.Stdout, nil)
if err != nil {
    log.Fatalf(&#34;template execution: %s&#34;, err)
}
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">T0 invokes T1: (T1 invokes T2: (This is T2))</pre>
		
	</div>
</div>
<div id="example_Template_helpers" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example (Helpers)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example (Helpers)</span></p>
		<p>This example demonstrates one way to share some templates
and use them in different contexts. In this variant we add multiple driver
templates by hand to an existing bundle of templates.
</p>
		<p>Code:</p>
		<pre class="code"><span class="comment">// Here we create a temporary directory and populate it with our sample</span>
<span class="comment">// template definition files; usually the template files would already</span>
<span class="comment">// exist in some location known to the program.</span>
dir := createTestDir([]templateFile{
    <span class="comment">// T1.tmpl defines a template, T1 that invokes T2.</span>
    {&#34;T1.tmpl&#34;, `{{define &#34;T1&#34;}}T1 invokes T2: ({{template &#34;T2&#34;}}){{end}}`},
    <span class="comment">// T2.tmpl defines a template T2.</span>
    {&#34;T2.tmpl&#34;, `{{define &#34;T2&#34;}}This is T2{{end}}`},
})
<span class="comment">// Clean up after the test; another quirk of running as an example.</span>
defer os.RemoveAll(dir)

<span class="comment">// pattern is the glob pattern used to find all the template files.</span>
pattern := filepath.Join(dir, &#34;*.tmpl&#34;)

<span class="comment">// Here starts the example proper.</span>
<span class="comment">// Load the helpers.</span>
templates := template.Must(template.ParseGlob(pattern))
<span class="comment">// Add one driver template to the bunch; we do this with an explicit template definition.</span>
_, err := templates.Parse(&#34;{{define `driver1`}}Driver 1 calls T1: ({{template `T1`}})\n{{end}}&#34;)
if err != nil {
    log.Fatal(&#34;parsing driver1: &#34;, err)
}
<span class="comment">// Add another driver template.</span>
_, err = templates.Parse(&#34;{{define `driver2`}}Driver 2 calls T2: ({{template `T2`}})\n{{end}}&#34;)
if err != nil {
    log.Fatal(&#34;parsing driver2: &#34;, err)
}
<span class="comment">// We load all the templates before execution. This package does not require</span>
<span class="comment">// that behavior but html/template&#39;s escaping does, so it&#39;s a good habit.</span>
err = templates.ExecuteTemplate(os.Stdout, &#34;driver1&#34;, nil)
if err != nil {
    log.Fatalf(&#34;driver1 execution: %s&#34;, err)
}
err = templates.ExecuteTemplate(os.Stdout, &#34;driver2&#34;, nil)
if err != nil {
    log.Fatalf(&#34;driver2 execution: %s&#34;, err)
}
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">Driver 1 calls T1: (T1 invokes T2: (This is T2))
Driver 2 calls T2: (This is T2)</pre>
		
	</div>
</div>
<div id="example_Template_share" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example (Share)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example (Share)</span></p>
		<p>This example demonstrates how to use one group of driver
templates with distinct sets of helper templates.
</p>
		<p>Code:</p>
		<pre class="code"><span class="comment">// Here we create a temporary directory and populate it with our sample</span>
<span class="comment">// template definition files; usually the template files would already</span>
<span class="comment">// exist in some location known to the program.</span>
dir := createTestDir([]templateFile{
    <span class="comment">// T0.tmpl is a plain template file that just invokes T1.</span>
    {&#34;T0.tmpl&#34;, &#34;T0 ({{.}} version) invokes T1: ({{template `T1`}})\n&#34;},
    <span class="comment">// T1.tmpl defines a template, T1 that invokes T2. Note T2 is not defined</span>
    {&#34;T1.tmpl&#34;, `{{define &#34;T1&#34;}}T1 invokes T2: ({{template &#34;T2&#34;}}){{end}}`},
})
<span class="comment">// Clean up after the test; another quirk of running as an example.</span>
defer os.RemoveAll(dir)

<span class="comment">// pattern is the glob pattern used to find all the template files.</span>
pattern := filepath.Join(dir, &#34;*.tmpl&#34;)

<span class="comment">// Here starts the example proper.</span>
<span class="comment">// Load the drivers.</span>
drivers := template.Must(template.ParseGlob(pattern))

<span class="comment">// We must define an implementation of the T2 template. First we clone</span>
<span class="comment">// the drivers, then add a definition of T2 to the template name space.</span>

<span class="comment">// 1. Clone the helper set to create a new name space from which to run them.</span>
first, err := drivers.Clone()
if err != nil {
    log.Fatal(&#34;cloning helpers: &#34;, err)
}
<span class="comment">// 2. Define T2, version A, and parse it.</span>
_, err = first.Parse(&#34;{{define `T2`}}T2, version A{{end}}&#34;)
if err != nil {
    log.Fatal(&#34;parsing T2: &#34;, err)
}

<span class="comment">// Now repeat the whole thing, using a different version of T2.</span>
<span class="comment">// 1. Clone the drivers.</span>
second, err := drivers.Clone()
if err != nil {
    log.Fatal(&#34;cloning drivers: &#34;, err)
}
<span class="comment">// 2. Define T2, version B, and parse it.</span>
_, err = second.Parse(&#34;{{define `T2`}}T2, version B{{end}}&#34;)
if err != nil {
    log.Fatal(&#34;parsing T2: &#34;, err)
}

<span class="comment">// Execute the templates in the reverse order to verify the</span>
<span class="comment">// first is unaffected by the second.</span>
err = second.ExecuteTemplate(os.Stdout, &#34;T0.tmpl&#34;, &#34;second&#34;)
if err != nil {
    log.Fatalf(&#34;second execution: %s&#34;, err)
}
err = first.ExecuteTemplate(os.Stdout, &#34;T0.tmpl&#34;, &#34;first&#34;)
if err != nil {
    log.Fatalf(&#34;first: execution: %s&#34;, err)
}

<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">T0 (second version) invokes T1: (T1 invokes T2: (T2, version B))
T0 (first version) invokes T1: (T1 invokes T2: (T2, version A))</pre>
		
	</div>
</div>


			
				
				<h3 id="Must">func <a href="src/pkg/text/template/helper.htm#L11">Must</a></h3>
				<pre>func Must(t *Template, err error) *Template</pre>
				<p>
Must is a helper that wraps a call to a function returning (*Template, error)
and panics if the error is non-nil. It is intended for use in variable
initializations such as
</p>
<pre>var t = template.Must(template.New(&#34;name&#34;).Parse(&#34;text&#34;))
</pre>

				
			
				
				<h3 id="New">func <a href="src/pkg/text/template/template.htm#L25">New</a></h3>
				<pre>func New(name string) *Template</pre>
				<p>
New allocates a new template with the given name.
</p>

				
			
				
				<h3 id="ParseFiles">func <a href="src/pkg/text/template/helper.htm#L22">ParseFiles</a></h3>
				<pre>func ParseFiles(filenames ...string) (*Template, error)</pre>
				<p>
ParseFiles creates a new Template and parses the template definitions from
the named files. The returned template&#39;s name will have the (base) name and
(parsed) contents of the first file. There must be at least one file.
If an error occurs, parsing stops and the returned *Template is nil.
</p>

				
			
				
				<h3 id="ParseGlob">func <a href="src/pkg/text/template/helper.htm#L75">ParseGlob</a></h3>
				<pre>func ParseGlob(pattern string) (*Template, error)</pre>
				<p>
ParseGlob creates a new Template and parses the template definitions from the
files identified by the pattern, which must match at least one file. The
returned template will have the (base) name and (parsed) contents of the
first file matched by the pattern. ParseGlob is equivalent to calling
ParseFiles with the list of files matched by the pattern.
</p>

				
			

			
				
				<h3 id="Template.AddParseTree">func (*Template) <a href="src/pkg/text/template/template.htm#L97">AddParseTree</a></h3>
				<pre>func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)</pre>
				<p>
AddParseTree creates a new template with the name and parse tree
and associates it with t.
</p>

				
				
			
				
				<h3 id="Template.Clone">func (*Template) <a href="src/pkg/text/template/template.htm#L64">Clone</a></h3>
				<pre>func (t *Template) Clone() (*Template, error)</pre>
				<p>
Clone returns a duplicate of the template, including all associated
templates. The actual representation is not copied, but the name space of
associated templates is, so further calls to Parse in the copy will add
templates to the copy but not to the original. Clone can be used to prepare
common templates and use them with variant definitions for other templates
by adding the variants after the clone is made.
</p>

				
				
			
				
				<h3 id="Template.Delims">func (*Template) <a href="src/pkg/text/template/template.htm#L123">Delims</a></h3>
				<pre>func (t *Template) Delims(left, right string) *Template</pre>
				<p>
Delims sets the action delimiters to the specified strings, to be used in
subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template
definitions will inherit the settings. An empty delimiter stands for the
corresponding default: {{ or }}.
The return value is the template, so calls can be chained.
</p>

				
				
			
				
				<h3 id="Template.Execute">func (*Template) <a href="src/pkg/text/template/exec.htm#L95">Execute</a></h3>
				<pre>func (t *Template) Execute(wr io.Writer, data interface{}) (err error)</pre>
				<p>
Execute applies a parsed template to the specified data object,
and writes the output to wr.
</p>

				
				
			
				
				<h3 id="Template.ExecuteTemplate">func (*Template) <a href="src/pkg/text/template/exec.htm#L85">ExecuteTemplate</a></h3>
				<pre>func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error</pre>
				<p>
ExecuteTemplate applies the template associated with t that has the given name
to the specified data object and writes the output to wr.
</p>

				
				
			
				
				<h3 id="Template.Funcs">func (*Template) <a href="src/pkg/text/template/template.htm#L133">Funcs</a></h3>
				<pre>func (t *Template) Funcs(funcMap FuncMap) *Template</pre>
				<p>
Funcs adds the elements of the argument map to the template&#39;s function map.
It panics if a value in the map is not a function with appropriate return
type. However, it is legal to overwrite elements of the map. The return
value is the template, so calls can be chained.
</p>

				
				
			
				
				<h3 id="Template.Lookup">func (*Template) <a href="src/pkg/text/template/template.htm#L142">Lookup</a></h3>
				<pre>func (t *Template) Lookup(name string) *Template</pre>
				<p>
Lookup returns the template with the given name that is associated with t,
or nil if there is no such template.
</p>

				
				
			
				
				<h3 id="Template.Name">func (*Template) <a href="src/pkg/text/template/template.htm#L32">Name</a></h3>
				<pre>func (t *Template) Name() string</pre>
				<p>
Name returns the name of the template.
</p>

				
				
			
				
				<h3 id="Template.New">func (*Template) <a href="src/pkg/text/template/template.htm#L39">New</a></h3>
				<pre>func (t *Template) New(name string) *Template</pre>
				<p>
New allocates a new template associated with the given one and with the same
delimiters. The association, which is transitive, allows one template to
invoke another with a {{template}} action.
</p>

				
				
			
				
				<h3 id="Template.Parse">func (*Template) <a href="src/pkg/text/template/template.htm#L156">Parse</a></h3>
				<pre>func (t *Template) Parse(text string) (*Template, error)</pre>
				<p>
Parse parses a string into a template. Nested template definitions will be
associated with the top-level template t. Parse may be called multiple times
to parse definitions of templates to associate with t. It is an error if a
resulting template is non-empty (contains content other than template
definitions) and would replace a non-empty template with the same name.
(In multiple calls to Parse with the same receiver template, only one call
can contain text other than space, comments, and template definitions.)
</p>

				
				
			
				
				<h3 id="Template.ParseFiles">func (*Template) <a href="src/pkg/text/template/helper.htm#L29">ParseFiles</a></h3>
				<pre>func (t *Template) ParseFiles(filenames ...string) (*Template, error)</pre>
				<p>
ParseFiles parses the named files and associates the resulting templates with
t. If an error occurs, parsing stops and the returned template is nil;
otherwise it is t. There must be at least one file.
</p>

				
				
			
				
				<h3 id="Template.ParseGlob">func (*Template) <a href="src/pkg/text/template/helper.htm#L84">ParseGlob</a></h3>
				<pre>func (t *Template) ParseGlob(pattern string) (*Template, error)</pre>
				<p>
ParseGlob parses the template definitions in the files identified by the
pattern and associates the resulting templates with t. The pattern is
processed by filepath.Glob and must match at least one file. ParseGlob is
equivalent to calling t.ParseFiles with the list of files matched by the
pattern.
</p>

				
				
			
				
				<h3 id="Template.Templates">func (*Template) <a href="src/pkg/text/template/template.htm#L109">Templates</a></h3>
				<pre>func (t *Template) Templates() []*Template</pre>
				<p>
Templates returns a slice of the templates associated with t, including t
itself.
</p>

				
				
			
		
		</div>
	

	







	
	
		<h2 id="subdirectories">Subdirectories</h2>
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>

			<tr>
			<td class="name"><a href="text_template_parse.htm">parse</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package parse builds parse trees for templates as defined by text/template and html/template.</td>
			</tr>
		
	
	</table>
	



</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
