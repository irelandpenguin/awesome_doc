
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>tls - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package tls</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "crypto/tls"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package tls partially implements TLS 1.0, as specified in RFC 2246.
</p>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
				<dd><a href="#constants">Constants</a></dd>
			
			
			
				
				<dd><a href="#Listen">func Listen(network, laddr string, config *Config) (net.Listener, error)</a></dd>
			
				
				<dd><a href="#NewListener">func NewListener(inner net.Listener, config *Config) net.Listener</a></dd>
			
			
				
				<dd><a href="#Certificate">type Certificate</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LoadX509KeyPair">func LoadX509KeyPair(certFile, keyFile string) (cert Certificate, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#X509KeyPair">func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (cert Certificate, err error)</a></dd>
				
				
			
				
				<dd><a href="#ClientAuthType">type ClientAuthType</a></dd>
				
				
			
				
				<dd><a href="#Config">type Config</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Config.BuildNameToCertificate">func (c *Config) BuildNameToCertificate()</a></dd>
				
			
				
				<dd><a href="#Conn">type Conn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Client">func Client(conn net.Conn, config *Config) *Conn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Dial">func Dial(network, addr string, config *Config) (*Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Server">func Server(conn net.Conn, config *Config) *Conn</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.Close">func (c *Conn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.ConnectionState">func (c *Conn) ConnectionState() ConnectionState</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.Handshake">func (c *Conn) Handshake() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.LocalAddr">func (c *Conn) LocalAddr() net.Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.OCSPResponse">func (c *Conn) OCSPResponse() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.Read">func (c *Conn) Read(b []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.RemoteAddr">func (c *Conn) RemoteAddr() net.Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.SetDeadline">func (c *Conn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.SetReadDeadline">func (c *Conn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.SetWriteDeadline">func (c *Conn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.VerifyHostname">func (c *Conn) VerifyHostname(host string) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.Write">func (c *Conn) Write(b []byte) (int, error)</a></dd>
				
			
				
				<dd><a href="#ConnectionState">type ConnectionState</a></dd>
				
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/crypto/tls/alert.htm">alert.go</a>
			
				<a href="src/pkg/crypto/tls/cipher_suites.htm">cipher_suites.go</a>
			
				<a href="src/pkg/crypto/tls/common.htm">common.go</a>
			
				<a href="src/pkg/crypto/tls/conn.htm">conn.go</a>
			
				<a href="src/pkg/crypto/tls/handshake_client.htm">handshake_client.go</a>
			
				<a href="src/pkg/crypto/tls/handshake_messages.htm">handshake_messages.go</a>
			
				<a href="src/pkg/crypto/tls/handshake_server.htm">handshake_server.go</a>
			
				<a href="src/pkg/crypto/tls/key_agreement.htm">key_agreement.go</a>
			
				<a href="src/pkg/crypto/tls/prf.htm">prf.go</a>
			
				<a href="src/pkg/crypto/tls/tls.htm">tls.go</a>
			
			</span>
			</p>
		
	
		
			<h2 id="constants">Constants</h2>
			
				<pre>const (
    TLS_RSA_WITH_RC4_128_SHA            uint16 = 0x0005
    TLS_RSA_WITH_3DES_EDE_CBC_SHA       uint16 = 0x000a
    TLS_RSA_WITH_AES_128_CBC_SHA        uint16 = 0x002f
    TLS_ECDHE_RSA_WITH_RC4_128_SHA      uint16 = 0xc011
    TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA uint16 = 0xc012
    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA  uint16 = 0xc013
)</pre>
				<p>
A list of the possible cipher suite ids. Taken from
<a href="http://www.iana.org/assignments/tls-parameters/tls-parameters.xml">http://www.iana.org/assignments/tls-parameters/tls-parameters.xml</a>
</p>

			
		
		
		
			
			
			<h2 id="Listen">func <a href="src/pkg/crypto/tls/tls.htm#L57">Listen</a></h2>
			<pre>func Listen(network, laddr string, config *Config) (net.Listener, error)</pre>
			<p>
Listen creates a TLS listener accepting connections on the
given network address using net.Listen.
The configuration config must be non-nil and must have
at least one certificate.
</p>

			
		
			
			
			<h2 id="NewListener">func <a href="src/pkg/crypto/tls/tls.htm#L46">NewListener</a></h2>
			<pre>func NewListener(inner net.Listener, config *Config) net.Listener</pre>
			<p>
NewListener creates a Listener which accepts connections from an inner
Listener and wraps each connection with Server.
The configuration config must be non-nil and must have
at least one certificate.
</p>

			
		
		
			
			
			<h2 id="Certificate">type <a href="src/pkg/crypto/tls/common.htm#L253">Certificate</a></h2>
			<pre>type Certificate struct {
    Certificate [][]byte
    PrivateKey  crypto.PrivateKey <span class="comment">// supported types: *rsa.PrivateKey</span>
    <span class="comment">// OCSPStaple contains an optional OCSP response which will be served</span>
    <span class="comment">// to clients that request it.</span>
    OCSPStaple []byte
    <span class="comment">// Leaf is the parsed form of the leaf certificate, which may be</span>
    <span class="comment">// initialized using x509.ParseCertificate to reduce per-handshake</span>
    <span class="comment">// processing for TLS clients doing client authentication. If nil, the</span>
    <span class="comment">// leaf certificate will be parsed as needed.</span>
    Leaf *x509.Certificate
}</pre>
			<p>
A Certificate is a chain of one or more certificates, leaf first.
</p>


			

			

			

			
				
				<h3 id="LoadX509KeyPair">func <a href="src/pkg/crypto/tls/tls.htm#L108">LoadX509KeyPair</a></h3>
				<pre>func LoadX509KeyPair(certFile, keyFile string) (cert Certificate, err error)</pre>
				<p>
LoadX509KeyPair reads and parses a public/private key pair from a pair of
files. The files must contain PEM encoded data.
</p>

				
			
				
				<h3 id="X509KeyPair">func <a href="src/pkg/crypto/tls/tls.htm#L122">X509KeyPair</a></h3>
				<pre>func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (cert Certificate, err error)</pre>
				<p>
X509KeyPair parses a public/private key pair from a pair of
PEM encoded data.
</p>

				
			

			
		
			
			
			<h2 id="ClientAuthType">type <a href="src/pkg/crypto/tls/common.htm#L106">ClientAuthType</a></h2>
			<pre>type ClientAuthType int</pre>
			<p>
ClientAuthType declares the policy the server will follow for
TLS Client Authentication.
</p>


			
				<pre>const (
    NoClientCert ClientAuthType = iota
    RequestClientCert
    RequireAnyClientCert
    VerifyClientCertIfGiven
    RequireAndVerifyClientCert
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="Config">type <a href="src/pkg/crypto/tls/common.htm#L118">Config</a></h2>
			<pre>type Config struct {
    <span class="comment">// Rand provides the source of entropy for nonces and RSA blinding.</span>
    <span class="comment">// If Rand is nil, TLS uses the cryptographic random reader in package</span>
    <span class="comment">// crypto/rand.</span>
    Rand io.Reader

    <span class="comment">// Time returns the current time as the number of seconds since the epoch.</span>
    <span class="comment">// If Time is nil, TLS uses time.Now.</span>
    Time func() time.Time

    <span class="comment">// Certificates contains one or more certificate chains</span>
    <span class="comment">// to present to the other side of the connection.</span>
    <span class="comment">// Server configurations must include at least one certificate.</span>
    Certificates []Certificate

    <span class="comment">// NameToCertificate maps from a certificate name to an element of</span>
    <span class="comment">// Certificates. Note that a certificate name can be of the form</span>
    <span class="comment">// &#39;*.example.com&#39; and so doesn&#39;t have to be a domain name as such.</span>
    <span class="comment">// See Config.BuildNameToCertificate</span>
    <span class="comment">// The nil value causes the first element of Certificates to be used</span>
    <span class="comment">// for all connections.</span>
    NameToCertificate map[string]*Certificate

    <span class="comment">// RootCAs defines the set of root certificate authorities</span>
    <span class="comment">// that clients use when verifying server certificates.</span>
    <span class="comment">// If RootCAs is nil, TLS uses the host&#39;s root CA set.</span>
    RootCAs *x509.CertPool

    <span class="comment">// NextProtos is a list of supported, application level protocols.</span>
    NextProtos []string

    <span class="comment">// ServerName is included in the client&#39;s handshake to support virtual</span>
    <span class="comment">// hosting.</span>
    ServerName string

    <span class="comment">// ClientAuth determines the server&#39;s policy for</span>
    <span class="comment">// TLS Client Authentication. The default is NoClientCert.</span>
    ClientAuth ClientAuthType

    <span class="comment">// ClientCAs defines the set of root certificate authorities</span>
    <span class="comment">// that servers use if required to verify a client certificate</span>
    <span class="comment">// by the policy in ClientAuth.</span>
    ClientCAs *x509.CertPool

    <span class="comment">// InsecureSkipVerify controls whether a client verifies the</span>
    <span class="comment">// server&#39;s certificate chain and host name.</span>
    <span class="comment">// If InsecureSkipVerify is true, TLS accepts any certificate</span>
    <span class="comment">// presented by the server and any host name in that certificate.</span>
    <span class="comment">// In this mode, TLS is susceptible to man-in-the-middle attacks.</span>
    <span class="comment">// This should be used only for testing.</span>
    InsecureSkipVerify bool

    <span class="comment">// CipherSuites is a list of supported cipher suites. If CipherSuites</span>
    <span class="comment">// is nil, TLS uses a list of suites supported by the implementation.</span>
    CipherSuites []uint16
}</pre>
			<p>
A Config structure is used to configure a TLS client or server. After one
has been passed to a TLS function it must not be modified.
</p>


			

			

			

			

			
				
				<h3 id="Config.BuildNameToCertificate">func (*Config) <a href="src/pkg/crypto/tls/common.htm#L235">BuildNameToCertificate</a></h3>
				<pre>func (c *Config) BuildNameToCertificate()</pre>
				<p>
BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate
from the CommonName and SubjectAlternateName fields of each of the leaf
certificates.
</p>

				
				
			
		
			
			
			<h2 id="Conn">type <a href="src/pkg/crypto/tls/conn.htm#L13">Conn</a></h2>
			<pre>type Conn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Conn represents a secured connection.
It implements the net.Conn interface.
</p>


			

			

			

			
				
				<h3 id="Client">func <a href="src/pkg/crypto/tls/tls.htm#L21">Client</a></h3>
				<pre>func Client(conn net.Conn, config *Config) *Conn</pre>
				<p>
Client returns a new TLS client side connection
using conn as the underlying transport.
Client interprets a nil configuration as equivalent to
the zero configuration; see the documentation of Config
for the defaults.
</p>

				
			
				
				<h3 id="Dial">func <a href="src/pkg/crypto/tls/tls.htm#L74">Dial</a></h3>
				<pre>func Dial(network, addr string, config *Config) (*Conn, error)</pre>
				<p>
Dial connects to the given network address using net.Dial
and then initiates a TLS handshake, returning the resulting
TLS connection.
Dial interprets a nil configuration as equivalent to
the zero configuration; see the documentation of Config
for the defaults.
</p>

				
			
				
				<h3 id="Server">func <a href="src/pkg/crypto/tls/tls.htm#L12">Server</a></h3>
				<pre>func Server(conn net.Conn, config *Config) *Conn</pre>
				<p>
Server returns a new TLS server side connection
using conn as the underlying transport.
The configuration config must be non-nil and must have
at least one certificate.
</p>

				
			

			
				
				<h3 id="Conn.Close">func (*Conn) <a href="src/pkg/crypto/tls/conn.htm#L769">Close</a></h3>
				<pre>func (c *Conn) Close() error</pre>
				<p>
Close closes the connection.
</p>

				
				
			
				
				<h3 id="Conn.ConnectionState">func (*Conn) <a href="src/pkg/crypto/tls/conn.htm#L804">ConnectionState</a></h3>
				<pre>func (c *Conn) ConnectionState() ConnectionState</pre>
				<p>
ConnectionState returns basic TLS details about the connection.
</p>

				
				
			
				
				<h3 id="Conn.Handshake">func (*Conn) <a href="src/pkg/crypto/tls/conn.htm#L788">Handshake</a></h3>
				<pre>func (c *Conn) Handshake() error</pre>
				<p>
Handshake runs the client or server handshake
protocol if it has not yet been run.
Most uses of this package need not call Handshake
explicitly: the first Read or Write will call it automatically.
</p>

				
				
			
				
				<h3 id="Conn.LocalAddr">func (*Conn) <a href="src/pkg/crypto/tls/conn.htm#L71">LocalAddr</a></h3>
				<pre>func (c *Conn) LocalAddr() net.Addr</pre>
				<p>
LocalAddr returns the local network address.
</p>

				
				
			
				
				<h3 id="Conn.OCSPResponse">func (*Conn) <a href="src/pkg/crypto/tls/conn.htm#L824">OCSPResponse</a></h3>
				<pre>func (c *Conn) OCSPResponse() []byte</pre>
				<p>
OCSPResponse returns the stapled OCSP response from the TLS server, if
any. (Only valid for client connections.)
</p>

				
				
			
				
				<h3 id="Conn.Read">func (*Conn) <a href="src/pkg/crypto/tls/conn.htm#L743">Read</a></h3>
				<pre>func (c *Conn) Read(b []byte) (n int, err error)</pre>
				<p>
Read can be made to time out and return a net.Error with Timeout() == true
after a fixed time limit; see SetDeadline and SetReadDeadline.
</p>

				
				
			
				
				<h3 id="Conn.RemoteAddr">func (*Conn) <a href="src/pkg/crypto/tls/conn.htm#L76">RemoteAddr</a></h3>
				<pre>func (c *Conn) RemoteAddr() net.Addr</pre>
				<p>
RemoteAddr returns the remote network address.
</p>

				
				
			
				
				<h3 id="Conn.SetDeadline">func (*Conn) <a href="src/pkg/crypto/tls/conn.htm#L83">SetDeadline</a></h3>
				<pre>func (c *Conn) SetDeadline(t time.Time) error</pre>
				<p>
SetDeadline sets the read and write deadlines associated with the connection.
A zero value for t means Read and Write will not time out.
After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.
</p>

				
				
			
				
				<h3 id="Conn.SetReadDeadline">func (*Conn) <a href="src/pkg/crypto/tls/conn.htm#L89">SetReadDeadline</a></h3>
				<pre>func (c *Conn) SetReadDeadline(t time.Time) error</pre>
				<p>
SetReadDeadline sets the read deadline on the underlying connection.
A zero value for t means Read will not time out.
</p>

				
				
			
				
				<h3 id="Conn.SetWriteDeadline">func (*Conn) <a href="src/pkg/crypto/tls/conn.htm#L96">SetWriteDeadline</a></h3>
				<pre>func (c *Conn) SetWriteDeadline(t time.Time) error</pre>
				<p>
SetWriteDeadline sets the write deadline on the underlying conneciton.
A zero value for t means Write will not time out.
After a Write has timed out, the TLS state is corrupt and all future writes will return the same error.
</p>

				
				
			
				
				<h3 id="Conn.VerifyHostname">func (*Conn) <a href="src/pkg/crypto/tls/conn.htm#L834">VerifyHostname</a></h3>
				<pre>func (c *Conn) VerifyHostname(host string) error</pre>
				<p>
VerifyHostname checks that the peer certificate chain is valid for
connecting to host.  If so, it returns nil; if not, it returns an error
describing the problem.
</p>

				
				
			
				
				<h3 id="Conn.Write">func (*Conn) <a href="src/pkg/crypto/tls/conn.htm#L720">Write</a></h3>
				<pre>func (c *Conn) Write(b []byte) (int, error)</pre>
				<p>
Write writes data to the connection.
</p>

				
				
			
		
			
			
			<h2 id="ConnectionState">type <a href="src/pkg/crypto/tls/common.htm#L88">ConnectionState</a></h2>
			<pre>type ConnectionState struct {
    HandshakeComplete          bool
    CipherSuite                uint16
    NegotiatedProtocol         string
    NegotiatedProtocolIsMutual bool

    <span class="comment">// ServerName contains the server name indicated by the client, if any.</span>
    <span class="comment">// (Only valid for server connections.)</span>
    ServerName string

    <span class="comment">// the certificate chain that was presented by the other side</span>
    PeerCertificates []*x509.Certificate
    <span class="comment">// the verified certificate chains built from PeerCertificates.</span>
    VerifiedChains [][]*x509.Certificate
}</pre>
			<p>
ConnectionState records basic TLS details about the connection.
</p>


			

			

			

			

			
		
		</div>
	

	









</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
