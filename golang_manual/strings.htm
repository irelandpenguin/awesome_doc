
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>strings - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>


<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package strings</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "strings"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
				<dd><a href="#examples">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package strings implements simple functions to manipulate strings.
</p>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#Contains">func Contains(s, substr string) bool</a></dd>
			
				
				<dd><a href="#ContainsAny">func ContainsAny(s, chars string) bool</a></dd>
			
				
				<dd><a href="#ContainsRune">func ContainsRune(s string, r rune) bool</a></dd>
			
				
				<dd><a href="#Count">func Count(s, sep string) int</a></dd>
			
				
				<dd><a href="#EqualFold">func EqualFold(s, t string) bool</a></dd>
			
				
				<dd><a href="#Fields">func Fields(s string) []string</a></dd>
			
				
				<dd><a href="#FieldsFunc">func FieldsFunc(s string, f func(rune) bool) []string</a></dd>
			
				
				<dd><a href="#HasPrefix">func HasPrefix(s, prefix string) bool</a></dd>
			
				
				<dd><a href="#HasSuffix">func HasSuffix(s, suffix string) bool</a></dd>
			
				
				<dd><a href="#Index">func Index(s, sep string) int</a></dd>
			
				
				<dd><a href="#IndexAny">func IndexAny(s, chars string) int</a></dd>
			
				
				<dd><a href="#IndexFunc">func IndexFunc(s string, f func(rune) bool) int</a></dd>
			
				
				<dd><a href="#IndexRune">func IndexRune(s string, r rune) int</a></dd>
			
				
				<dd><a href="#Join">func Join(a []string, sep string) string</a></dd>
			
				
				<dd><a href="#LastIndex">func LastIndex(s, sep string) int</a></dd>
			
				
				<dd><a href="#LastIndexAny">func LastIndexAny(s, chars string) int</a></dd>
			
				
				<dd><a href="#LastIndexFunc">func LastIndexFunc(s string, f func(rune) bool) int</a></dd>
			
				
				<dd><a href="#Map">func Map(mapping func(rune) rune, s string) string</a></dd>
			
				
				<dd><a href="#Repeat">func Repeat(s string, count int) string</a></dd>
			
				
				<dd><a href="#Replace">func Replace(s, old, new string, n int) string</a></dd>
			
				
				<dd><a href="#Split">func Split(s, sep string) []string</a></dd>
			
				
				<dd><a href="#SplitAfter">func SplitAfter(s, sep string) []string</a></dd>
			
				
				<dd><a href="#SplitAfterN">func SplitAfterN(s, sep string, n int) []string</a></dd>
			
				
				<dd><a href="#SplitN">func SplitN(s, sep string, n int) []string</a></dd>
			
				
				<dd><a href="#Title">func Title(s string) string</a></dd>
			
				
				<dd><a href="#ToLower">func ToLower(s string) string</a></dd>
			
				
				<dd><a href="#ToLowerSpecial">func ToLowerSpecial(_case unicode.SpecialCase, s string) string</a></dd>
			
				
				<dd><a href="#ToTitle">func ToTitle(s string) string</a></dd>
			
				
				<dd><a href="#ToTitleSpecial">func ToTitleSpecial(_case unicode.SpecialCase, s string) string</a></dd>
			
				
				<dd><a href="#ToUpper">func ToUpper(s string) string</a></dd>
			
				
				<dd><a href="#ToUpperSpecial">func ToUpperSpecial(_case unicode.SpecialCase, s string) string</a></dd>
			
				
				<dd><a href="#Trim">func Trim(s string, cutset string) string</a></dd>
			
				
				<dd><a href="#TrimFunc">func TrimFunc(s string, f func(rune) bool) string</a></dd>
			
				
				<dd><a href="#TrimLeft">func TrimLeft(s string, cutset string) string</a></dd>
			
				
				<dd><a href="#TrimLeftFunc">func TrimLeftFunc(s string, f func(rune) bool) string</a></dd>
			
				
				<dd><a href="#TrimRight">func TrimRight(s string, cutset string) string</a></dd>
			
				
				<dd><a href="#TrimRightFunc">func TrimRightFunc(s string, f func(rune) bool) string</a></dd>
			
				
				<dd><a href="#TrimSpace">func TrimSpace(s string) string</a></dd>
			
			
				
				<dd><a href="#Reader">type Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReader">func NewReader(s string) *Reader</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Len">func (r *Reader) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Read">func (r *Reader) Read(b []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadAt">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadByte">func (r *Reader) ReadByte() (b byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadRune">func (r *Reader) ReadRune() (ch rune, size int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Seek">func (r *Reader) Seek(offset int64, whence int) (int64, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.UnreadByte">func (r *Reader) UnreadByte() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.UnreadRune">func (r *Reader) UnreadRune() error</a></dd>
				
			
				
				<dd><a href="#Replacer">type Replacer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReplacer">func NewReplacer(oldnew ...string) *Replacer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Replacer.Replace">func (r *Replacer) Replace(s string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Replacer.WriteString">func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)</a></dd>
				
			
			
				<dd><a href="#bugs">Bugs</a></dd>
			
		</dl>

		
			<h4 id="examples">Examples</h4>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Contains">Contains</a></dd>
			
			<dd><a class="exampleLink" href="#example_ContainsAny">ContainsAny</a></dd>
			
			<dd><a class="exampleLink" href="#example_Count">Count</a></dd>
			
			<dd><a class="exampleLink" href="#example_EqualFold">EqualFold</a></dd>
			
			<dd><a class="exampleLink" href="#example_Fields">Fields</a></dd>
			
			<dd><a class="exampleLink" href="#example_Index">Index</a></dd>
			
			<dd><a class="exampleLink" href="#example_IndexRune">IndexRune</a></dd>
			
			<dd><a class="exampleLink" href="#example_Join">Join</a></dd>
			
			<dd><a class="exampleLink" href="#example_LastIndex">LastIndex</a></dd>
			
			<dd><a class="exampleLink" href="#example_Map">Map</a></dd>
			
			<dd><a class="exampleLink" href="#example_NewReplacer">NewReplacer</a></dd>
			
			<dd><a class="exampleLink" href="#example_Repeat">Repeat</a></dd>
			
			<dd><a class="exampleLink" href="#example_Replace">Replace</a></dd>
			
			<dd><a class="exampleLink" href="#example_Split">Split</a></dd>
			
			<dd><a class="exampleLink" href="#example_SplitAfter">SplitAfter</a></dd>
			
			<dd><a class="exampleLink" href="#example_SplitAfterN">SplitAfterN</a></dd>
			
			<dd><a class="exampleLink" href="#example_SplitN">SplitN</a></dd>
			
			<dd><a class="exampleLink" href="#example_Title">Title</a></dd>
			
			<dd><a class="exampleLink" href="#example_ToLower">ToLower</a></dd>
			
			<dd><a class="exampleLink" href="#example_ToTitle">ToTitle</a></dd>
			
			<dd><a class="exampleLink" href="#example_ToUpper">ToUpper</a></dd>
			
			<dd><a class="exampleLink" href="#example_Trim">Trim</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimSpace">TrimSpace</a></dd>
			
			</dl>
		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/strings/reader..htm">reader.go</a>
			
				<a href="src/pkg/strings/replace.htm">replace.go</a>
			
				<a href="src/pkg/strings/strings.htm">strings.go</a>
			
			</span>
			</p>
		
	
		
		
		
			
			
			<h2 id="Contains">func <a href="src/pkg/strings/strings.htm#L56">Contains</a></h2>
			<pre>func Contains(s, substr string) bool</pre>
			<p>
Contains returns true if substr is within s.
</p>

			<div id="example_Contains" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Println(strings.Contains(&#34;seafood&#34;, &#34;foo&#34;))
fmt.Println(strings.Contains(&#34;seafood&#34;, &#34;bar&#34;))
fmt.Println(strings.Contains(&#34;seafood&#34;, &#34;&#34;))
fmt.Println(strings.Contains(&#34;&#34;, &#34;&#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">true
false
true
true</pre>
		
	</div>
</div>

		
			
			
			<h2 id="ContainsAny">func <a href="src/pkg/strings/strings.htm#L61">ContainsAny</a></h2>
			<pre>func ContainsAny(s, chars string) bool</pre>
			<p>
ContainsAny returns true if any Unicode code points in chars are within s.
</p>

			<div id="example_ContainsAny" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Println(strings.ContainsAny(&#34;team&#34;, &#34;i&#34;))
fmt.Println(strings.ContainsAny(&#34;failure&#34;, &#34;u &amp; i&#34;))
fmt.Println(strings.ContainsAny(&#34;foo&#34;, &#34;&#34;))
fmt.Println(strings.ContainsAny(&#34;&#34;, &#34;&#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">false
true
false
false</pre>
		
	</div>
</div>

		
			
			
			<h2 id="ContainsRune">func <a href="src/pkg/strings/strings.htm#L66">ContainsRune</a></h2>
			<pre>func ContainsRune(s string, r rune) bool</pre>
			<p>
ContainsRune returns true if the Unicode code point r is within s.
</p>

			
		
			
			
			<h2 id="Count">func <a href="src/pkg/strings/strings.htm#L30">Count</a></h2>
			<pre>func Count(s, sep string) int</pre>
			<p>
Count counts the number of non-overlapping instances of sep in s.
</p>

			<div id="example_Count" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Println(strings.Count(&#34;cheese&#34;, &#34;e&#34;))
fmt.Println(strings.Count(&#34;five&#34;, &#34;&#34;)) <span class="comment">// before &amp; after each rune</span>

<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">3
5</pre>
		
	</div>
</div>

		
			
			
			<h2 id="EqualFold">func <a href="src/pkg/strings/strings.htm#L590">EqualFold</a></h2>
			<pre>func EqualFold(s, t string) bool</pre>
			<p>
EqualFold reports whether s and t, interpreted as UTF-8 strings,
are equal under Unicode case-folding.
</p>

			<div id="example_EqualFold" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Println(strings.EqualFold(&#34;Go&#34;, &#34;go&#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">true</pre>
		
	</div>
</div>

		
			
			
			<h2 id="Fields">func <a href="src/pkg/strings/strings.htm#L238">Fields</a></h2>
			<pre>func Fields(s string) []string</pre>
			<p>
Fields splits the string s around each instance of one or more consecutive white space
characters, returning an array of substrings of s or an empty list if s contains only white space.
</p>

			<div id="example_Fields" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Printf(&#34;Fields are: %q&#34;, strings.Fields(&#34;  foo bar  baz   &#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">Fields are: [&#34;foo&#34; &#34;bar&#34; &#34;baz&#34;]</pre>
		
	</div>
</div>

		
			
			
			<h2 id="FieldsFunc">func <a href="src/pkg/strings/strings.htm#L245">FieldsFunc</a></h2>
			<pre>func FieldsFunc(s string, f func(rune) bool) []string</pre>
			<p>
FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)
and returns an array of slices of s. If all code points in s satisfy f(c) or the
string is empty, an empty slice is returned.
</p>

			
		
			
			
			<h2 id="HasPrefix">func <a href="src/pkg/strings/strings.htm#L302">HasPrefix</a></h2>
			<pre>func HasPrefix(s, prefix string) bool</pre>
			<p>
HasPrefix tests whether the string s begins with prefix.
</p>

			
		
			
			
			<h2 id="HasSuffix">func <a href="src/pkg/strings/strings.htm#L307">HasSuffix</a></h2>
			<pre>func HasSuffix(s, suffix string) bool</pre>
			<p>
HasSuffix tests whether the string s ends with suffix.
</p>

			
		
			
			
			<h2 id="Index">func <a href="src/pkg/strings/strings.htm#L71">Index</a></h2>
			<pre>func Index(s, sep string) int</pre>
			<p>
Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.
</p>

			<div id="example_Index" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Println(strings.Index(&#34;chicken&#34;, &#34;ken&#34;))
fmt.Println(strings.Index(&#34;chicken&#34;, &#34;dmr&#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">4
-1</pre>
		
	</div>
</div>

		
			
			
			<h2 id="IndexAny">func <a href="src/pkg/strings/strings.htm#L143">IndexAny</a></h2>
			<pre>func IndexAny(s, chars string) int</pre>
			<p>
IndexAny returns the index of the first instance of any Unicode code point
from chars in s, or -1 if no Unicode code point from chars is present in s.
</p>

			
		
			
			
			<h2 id="IndexFunc">func <a href="src/pkg/strings/strings.htm#L471">IndexFunc</a></h2>
			<pre>func IndexFunc(s string, f func(rune) bool) int</pre>
			<p>
IndexFunc returns the index into s of the first Unicode
code point satisfying f(c), or -1 if none do.
</p>

			
		
			
			
			<h2 id="IndexRune">func <a href="src/pkg/strings/strings.htm#L122">IndexRune</a></h2>
			<pre>func IndexRune(s string, r rune) int</pre>
			<p>
IndexRune returns the index of the first instance of the Unicode code point
r, or -1 if rune is not present in s.
</p>

			<div id="example_IndexRune" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Println(strings.IndexRune(&#34;chicken&#34;, &#39;k&#39;))
fmt.Println(strings.IndexRune(&#34;chicken&#34;, &#39;d&#39;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">4
-1</pre>
		
	</div>
</div>

		
			
			
			<h2 id="Join">func <a href="src/pkg/strings/strings.htm#L280">Join</a></h2>
			<pre>func Join(a []string, sep string) string</pre>
			<p>
Join concatenates the elements of a to create a single string.   The separator string
sep is placed between elements in the resulting string.
</p>

			<div id="example_Join" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">s := []string{&#34;foo&#34;, &#34;bar&#34;, &#34;baz&#34;}
fmt.Println(strings.Join(s, &#34;, &#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">foo, bar, baz</pre>
		
	</div>
</div>

		
			
			
			<h2 id="LastIndex">func <a href="src/pkg/strings/strings.htm#L96">LastIndex</a></h2>
			<pre>func LastIndex(s, sep string) int</pre>
			<p>
LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.
</p>

			<div id="example_LastIndex" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Println(strings.Index(&#34;go gopher&#34;, &#34;go&#34;))
fmt.Println(strings.LastIndex(&#34;go gopher&#34;, &#34;go&#34;))
fmt.Println(strings.LastIndex(&#34;go gopher&#34;, &#34;rodent&#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">0
3
-1</pre>
		
	</div>
</div>

		
			
			
			<h2 id="LastIndexAny">func <a href="src/pkg/strings/strings.htm#L159">LastIndexAny</a></h2>
			<pre>func LastIndexAny(s, chars string) int</pre>
			<p>
LastIndexAny returns the index of the last instance of any Unicode code
point from chars in s, or -1 if no Unicode code point from chars is
present in s.
</p>

			
		
			
			
			<h2 id="LastIndexFunc">func <a href="src/pkg/strings/strings.htm#L477">LastIndexFunc</a></h2>
			<pre>func LastIndexFunc(s string, f func(rune) bool) int</pre>
			<p>
LastIndexFunc returns the index into s of the last
Unicode code point satisfying f(c), or -1 if none do.
</p>

			
		
			
			
			<h2 id="Map">func <a href="src/pkg/strings/strings.htm#L314">Map</a></h2>
			<pre>func Map(mapping func(rune) rune, s string) string</pre>
			<p>
Map returns a copy of the string s with all its characters modified
according to the mapping function. If mapping returns a negative value, the character is
dropped from the string with no replacement.
</p>

			<div id="example_Map" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">rot13 := func(r rune) rune {
    switch {
    case r &gt;= &#39;A&#39; &amp;&amp; r &lt;= &#39;Z&#39;:
        return &#39;A&#39; + (r-&#39;A&#39;+13)%26
    case r &gt;= &#39;a&#39; &amp;&amp; r &lt;= &#39;z&#39;:
        return &#39;a&#39; + (r-&#39;a&#39;+13)%26
    }
    return r
}
fmt.Println(strings.Map(rot13, &#34;&#39;Twas brillig and the slithy gopher...&#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">&#39;Gjnf oevyyvt naq gur fyvgul tbcure...</pre>
		
	</div>
</div>

		
			
			
			<h2 id="Repeat">func <a href="src/pkg/strings/strings.htm#L355">Repeat</a></h2>
			<pre>func Repeat(s string, count int) string</pre>
			<p>
Repeat returns a new string consisting of count copies of the string s.
</p>

			<div id="example_Repeat" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Println(&#34;ba&#34; + strings.Repeat(&#34;na&#34;, 2))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">banana</pre>
		
	</div>
</div>

		
			
			
			<h2 id="Replace">func <a href="src/pkg/strings/strings.htm#L554">Replace</a></h2>
			<pre>func Replace(s, old, new string, n int) string</pre>
			<p>
Replace returns a copy of the string s with the first n
non-overlapping instances of old replaced by new.
If n &lt; 0, there is no limit on the number of replacements.
</p>

			<div id="example_Replace" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Println(strings.Replace(&#34;oink oink oink&#34;, &#34;k&#34;, &#34;ky&#34;, 2))
fmt.Println(strings.Replace(&#34;oink oink oink&#34;, &#34;oink&#34;, &#34;moo&#34;, -1))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">oinky oinky oink
moo moo moo</pre>
		
	</div>
</div>

		
			
			
			<h2 id="Split">func <a href="src/pkg/strings/strings.htm#L226">Split</a></h2>
			<pre>func Split(s, sep string) []string</pre>
			<p>
Split slices s into all substrings separated by sep and returns a slice of
the substrings between those separators.
If sep is empty, Split splits after each UTF-8 sequence.
It is equivalent to SplitN with a count of -1.
</p>

			<div id="example_Split" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Printf(&#34;%q\n&#34;, strings.Split(&#34;a,b,c&#34;, &#34;,&#34;))
fmt.Printf(&#34;%q\n&#34;, strings.Split(&#34;a man a plan a canal panama&#34;, &#34;a &#34;))
fmt.Printf(&#34;%q\n&#34;, strings.Split(&#34; xyz &#34;, &#34;&#34;))
fmt.Printf(&#34;%q\n&#34;, strings.Split(&#34;&#34;, &#34;Bernardo O&#39;Higgins&#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">[&#34;a&#34; &#34;b&#34; &#34;c&#34;]
[&#34;&#34; &#34;man &#34; &#34;plan &#34; &#34;canal panama&#34;]
[&#34; &#34; &#34;x&#34; &#34;y&#34; &#34;z&#34; &#34; &#34;]
[&#34;&#34;]</pre>
		
	</div>
</div>

		
			
			
			<h2 id="SplitAfter">func <a href="src/pkg/strings/strings.htm#L232">SplitAfter</a></h2>
			<pre>func SplitAfter(s, sep string) []string</pre>
			<p>
SplitAfter slices s into all substrings after each instance of sep and
returns a slice of those substrings.
If sep is empty, SplitAfter splits after each UTF-8 sequence.
It is equivalent to SplitAfterN with a count of -1.
</p>

			<div id="example_SplitAfter" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Printf(&#34;%q\n&#34;, strings.SplitAfter(&#34;a,b,c&#34;, &#34;,&#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">[&#34;a,&#34; &#34;b,&#34; &#34;c&#34;]</pre>
		
	</div>
</div>

		
			
			
			<h2 id="SplitAfterN">func <a href="src/pkg/strings/strings.htm#L218">SplitAfterN</a></h2>
			<pre>func SplitAfterN(s, sep string, n int) []string</pre>
			<p>
SplitAfterN slices s into substrings after each instance of sep and
returns a slice of those substrings.
If sep is empty, SplitAfterN splits after each UTF-8 sequence.
The count determines the number of substrings to return:
</p>
<pre>n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.
n == 0: the result is nil (zero substrings)
n &lt; 0: all substrings
</pre>

			<div id="example_SplitAfterN" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Printf(&#34;%q\n&#34;, strings.SplitAfterN(&#34;a,b,c&#34;, &#34;,&#34;, 2))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">[&#34;a,&#34; &#34;b,c&#34;]</pre>
		
	</div>
</div>

		
			
			
			<h2 id="SplitN">func <a href="src/pkg/strings/strings.htm#L209">SplitN</a></h2>
			<pre>func SplitN(s, sep string, n int) []string</pre>
			<p>
SplitN slices s into substrings separated by sep and returns a slice of
the substrings between those separators.
If sep is empty, SplitN splits after each UTF-8 sequence.
The count determines the number of substrings to return:
</p>
<pre>n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.
n == 0: the result is nil (zero substrings)
n &lt; 0: all substrings
</pre>

			<div id="example_SplitN" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Printf(&#34;%q\n&#34;, strings.SplitN(&#34;a,b,c&#34;, &#34;,&#34;, 2))
z := strings.SplitN(&#34;a,b,c&#34;, &#34;,&#34;, 0)
fmt.Printf(&#34;%q (nil = %v)\n&#34;, z, z == nil)
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">[&#34;a&#34; &#34;b,c&#34;]
[] (nil = true)</pre>
		
	</div>
</div>

		
			
			
			<h2 id="Title">func <a href="src/pkg/strings/strings.htm#L423">Title</a></h2>
			<pre>func Title(s string) string</pre>
			<p>
Title returns a copy of the string s with all Unicode letters that begin words
mapped to their title case.
</p>

			<div id="example_Title" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Println(strings.Title(&#34;her royal highness&#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">Her Royal Highness</pre>
		
	</div>
</div>

		
			
			
			<h2 id="ToLower">func <a href="src/pkg/strings/strings.htm#L371">ToLower</a></h2>
			<pre>func ToLower(s string) string</pre>
			<p>
ToLower returns a copy of the string s with all Unicode letters mapped to their lower case.
</p>

			<div id="example_ToLower" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Println(strings.ToLower(&#34;Gopher&#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">gopher</pre>
		
	</div>
</div>

		
			
			
			<h2 id="ToLowerSpecial">func <a href="src/pkg/strings/strings.htm#L384">ToLowerSpecial</a></h2>
			<pre>func ToLowerSpecial(_case unicode.SpecialCase, s string) string</pre>
			<p>
ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their
lower case, giving priority to the special casing rules.
</p>

			
		
			
			
			<h2 id="ToTitle">func <a href="src/pkg/strings/strings.htm#L374">ToTitle</a></h2>
			<pre>func ToTitle(s string) string</pre>
			<p>
ToTitle returns a copy of the string s with all Unicode letters mapped to their title case.
</p>

			<div id="example_ToTitle" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Println(strings.ToTitle(&#34;loud noises&#34;))
fmt.Println(strings.ToTitle(&#34;ݧ֧&#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">LOUD NOISES
</pre>
		
	</div>
</div>

		
			
			
			<h2 id="ToTitleSpecial">func <a href="src/pkg/strings/strings.htm#L390">ToTitleSpecial</a></h2>
			<pre>func ToTitleSpecial(_case unicode.SpecialCase, s string) string</pre>
			<p>
ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their
title case, giving priority to the special casing rules.
</p>

			
		
			
			
			<h2 id="ToUpper">func <a href="src/pkg/strings/strings.htm#L368">ToUpper</a></h2>
			<pre>func ToUpper(s string) string</pre>
			<p>
ToUpper returns a copy of the string s with all Unicode letters mapped to their upper case.
</p>

			<div id="example_ToUpper" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Println(strings.ToUpper(&#34;Gopher&#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">GOPHER</pre>
		
	</div>
</div>

		
			
			
			<h2 id="ToUpperSpecial">func <a href="src/pkg/strings/strings.htm#L378">ToUpperSpecial</a></h2>
			<pre>func ToUpperSpecial(_case unicode.SpecialCase, s string) string</pre>
			<p>
ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their
upper case, giving priority to the special casing rules.
</p>

			
		
			
			
			<h2 id="Trim">func <a href="src/pkg/strings/strings.htm#L520">Trim</a></h2>
			<pre>func Trim(s string, cutset string) string</pre>
			<p>
Trim returns a slice of the string s with all leading and
trailing Unicode code points contained in cutset removed.
</p>

			<div id="example_Trim" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Printf(&#34;[%q]&#34;, strings.Trim(&#34; !!! Achtung !!! &#34;, &#34;! &#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">[&#34;Achtung&#34;]</pre>
		
	</div>
</div>

		
			
			
			<h2 id="TrimFunc">func <a href="src/pkg/strings/strings.htm#L465">TrimFunc</a></h2>
			<pre>func TrimFunc(s string, f func(rune) bool) string</pre>
			<p>
TrimFunc returns a slice of the string s with all leading
and trailing Unicode code points c satisfying f(c) removed.
</p>

			
		
			
			
			<h2 id="TrimLeft">func <a href="src/pkg/strings/strings.htm#L529">TrimLeft</a></h2>
			<pre>func TrimLeft(s string, cutset string) string</pre>
			<p>
TrimLeft returns a slice of the string s with all leading
Unicode code points contained in cutset removed.
</p>

			
		
			
			
			<h2 id="TrimLeftFunc">func <a href="src/pkg/strings/strings.htm#L442">TrimLeftFunc</a></h2>
			<pre>func TrimLeftFunc(s string, f func(rune) bool) string</pre>
			<p>
TrimLeftFunc returns a slice of the string s with all leading
Unicode code points c satisfying f(c) removed.
</p>

			
		
			
			
			<h2 id="TrimRight">func <a href="src/pkg/strings/strings.htm#L538">TrimRight</a></h2>
			<pre>func TrimRight(s string, cutset string) string</pre>
			<p>
TrimRight returns a slice of the string s, with all trailing
Unicode code points contained in cutset removed.
</p>

			
		
			
			
			<h2 id="TrimRightFunc">func <a href="src/pkg/strings/strings.htm#L452">TrimRightFunc</a></h2>
			<pre>func TrimRightFunc(s string, f func(rune) bool) string</pre>
			<p>
TrimRightFunc returns a slice of the string s with all trailing
Unicode code points c satisfying f(c) removed.
</p>

			
		
			
			
			<h2 id="TrimSpace">func <a href="src/pkg/strings/strings.htm#L547">TrimSpace</a></h2>
			<pre>func TrimSpace(s string) string</pre>
			<p>
TrimSpace returns a slice of the string s, with all leading
and trailing white space removed, as defined by Unicode.
</p>

			<div id="example_TrimSpace" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">fmt.Println(strings.TrimSpace(&#34; \t\n a lone gopher \n\t\r\n&#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">a lone gopher</pre>
		
	</div>
</div>

		
		
			
			
			<h2 id="Reader">type <a href="src/pkg/strings/reader..htm#L6">Reader</a></h2>
			<pre>type Reader struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Reader implements the io.Reader, io.ReaderAt, io.Seeker,
io.ByteScanner, and io.RuneScanner interfaces by reading
from a string.
</p>


			

			

			

			
				
				<h3 id="NewReader">func <a href="src/pkg/strings/reader..htm#L115">NewReader</a></h3>
				<pre>func NewReader(s string) *Reader</pre>
				<p>
NewReader returns a new Reader reading from s.
It is similar to bytes.NewBufferString but more efficient and read-only.
</p>

				
			

			
				
				<h3 id="Reader.Len">func (*Reader) <a href="src/pkg/strings/reader..htm#L14">Len</a></h3>
				<pre>func (r *Reader) Len() int</pre>
				<p>
Len returns the number of bytes of the unread portion of the
string.
</p>

				
				
			
				
				<h3 id="Reader.Read">func (*Reader) <a href="src/pkg/strings/reader..htm#L21">Read</a></h3>
				<pre>func (r *Reader) Read(b []byte) (n int, err error)</pre>
				
				
				
			
				
				<h3 id="Reader.ReadAt">func (*Reader) <a href="src/pkg/strings/reader..htm#L34">ReadAt</a></h3>
				<pre>func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</pre>
				
				
				
			
				
				<h3 id="Reader.ReadByte">func (*Reader) <a href="src/pkg/strings/reader..htm#L48">ReadByte</a></h3>
				<pre>func (r *Reader) ReadByte() (b byte, err error)</pre>
				
				
				
			
				
				<h3 id="Reader.ReadRune">func (*Reader) <a href="src/pkg/strings/reader..htm#L67">ReadRune</a></h3>
				<pre>func (r *Reader) ReadRune() (ch rune, size int, err error)</pre>
				
				
				
			
				
				<h3 id="Reader.Seek">func (*Reader) <a href="src/pkg/strings/reader..htm#L91">Seek</a></h3>
				<pre>func (r *Reader) Seek(offset int64, whence int) (int64, error)</pre>
				<p>
Seek implements the io.Seeker interface.
</p>

				
				
			
				
				<h3 id="Reader.UnreadByte">func (*Reader) <a href="src/pkg/strings/reader..htm#L58">UnreadByte</a></h3>
				<pre>func (r *Reader) UnreadByte() error</pre>
				
				
				
			
				
				<h3 id="Reader.UnreadRune">func (*Reader) <a href="src/pkg/strings/reader..htm#L81">UnreadRune</a></h3>
				<pre>func (r *Reader) UnreadRune() error</pre>
				
				
				
			
		
			
			
			<h2 id="Replacer">type <a href="src/pkg/strings/replace.htm#L1">Replacer</a></h2>
			<pre>type Replacer struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Replacer replaces a list of strings with replacements.
</p>


			

			

			

			
				
				<h3 id="NewReplacer">func <a href="src/pkg/strings/replace.htm#L21">NewReplacer</a></h3>
				<pre>func NewReplacer(oldnew ...string) *Replacer</pre>
				<p>
NewReplacer returns a new Replacer from a list of old, new string pairs.
Replacements are performed in order, without overlapping matches.
</p>

				<div id="example_NewReplacer" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">r := strings.NewReplacer(&#34;&lt;&#34;, &#34;&amp;lt;&#34;, &#34;&gt;&#34;, &#34;&amp;gt;&#34;)
fmt.Println(r.Replace(&#34;This is &lt;b&gt;HTML&lt;/b&gt;!&#34;))
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">This is &amp;lt;b&amp;gt;HTML&amp;lt;/b&amp;gt;!</pre>
		
	</div>
</div>

			

			
				
				<h3 id="Replacer.Replace">func (*Replacer) <a href="src/pkg/strings/replace.htm#L70">Replace</a></h3>
				<pre>func (r *Replacer) Replace(s string) string</pre>
				<p>
Replace returns a copy of s with all replacements performed.
</p>

				
				
			
				
				<h3 id="Replacer.WriteString">func (*Replacer) <a href="src/pkg/strings/replace.htm#L75">WriteString</a></h3>
				<pre>func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error)</pre>
				<p>
WriteString writes s to w with all replacements performed.
</p>

				
				
			
		
		</div>
	

	
		<h2 id="bugs">Bugs</h2>
		
		<p>
The rule Title uses for word boundaries does not handle Unicode punctuation properly.
</p>

		
	









</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
