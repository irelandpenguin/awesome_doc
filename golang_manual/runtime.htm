
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>runtime - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package runtime</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "runtime"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
			
				<dd><a href="#subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package runtime contains operations that interact with Go&#39;s runtime system,
such as functions to control goroutines. It also includes the low-level type information
used by the reflect package; see reflect&#39;s documentation for the programmable
interface to the run-time type system.
</p>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
				<dd><a href="#constants">Constants</a></dd>
			
			
				<dd><a href="#variables">Variables</a></dd>
			
			
				
				<dd><a href="#Breakpoint">func Breakpoint()</a></dd>
			
				
				<dd><a href="#CPUProfile">func CPUProfile() []byte</a></dd>
			
				
				<dd><a href="#Caller">func Caller(skip int) (pc uintptr, file string, line int, ok bool)</a></dd>
			
				
				<dd><a href="#Callers">func Callers(skip int, pc []uintptr) int</a></dd>
			
				
				<dd><a href="#GC">func GC()</a></dd>
			
				
				<dd><a href="#GOMAXPROCS">func GOMAXPROCS(n int) int</a></dd>
			
				
				<dd><a href="#GOROOT">func GOROOT() string</a></dd>
			
				
				<dd><a href="#Goexit">func Goexit()</a></dd>
			
				
				<dd><a href="#GoroutineProfile">func GoroutineProfile(p []StackRecord) (n int, ok bool)</a></dd>
			
				
				<dd><a href="#Gosched">func Gosched()</a></dd>
			
				
				<dd><a href="#LockOSThread">func LockOSThread()</a></dd>
			
				
				<dd><a href="#MemProfile">func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)</a></dd>
			
				
				<dd><a href="#NumCPU">func NumCPU() int</a></dd>
			
				
				<dd><a href="#NumCgoCall">func NumCgoCall() int64</a></dd>
			
				
				<dd><a href="#NumGoroutine">func NumGoroutine() int</a></dd>
			
				
				<dd><a href="#ReadMemStats">func ReadMemStats(m *MemStats)</a></dd>
			
				
				<dd><a href="#SetCPUProfileRate">func SetCPUProfileRate(hz int)</a></dd>
			
				
				<dd><a href="#SetFinalizer">func SetFinalizer(x, f interface{})</a></dd>
			
				
				<dd><a href="#Stack">func Stack(buf []byte, all bool) int</a></dd>
			
				
				<dd><a href="#ThreadCreateProfile">func ThreadCreateProfile(p []StackRecord) (n int, ok bool)</a></dd>
			
				
				<dd><a href="#UnlockOSThread">func UnlockOSThread()</a></dd>
			
				
				<dd><a href="#Version">func Version() string</a></dd>
			
			
				
				<dd><a href="#Error">type Error</a></dd>
				
				
			
				
				<dd><a href="#Func">type Func</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FuncForPC">func FuncForPC(pc uintptr) *Func</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.Entry">func (f *Func) Entry() uintptr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.FileLine">func (f *Func) FileLine(pc uintptr) (file string, line int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.Name">func (f *Func) Name() string</a></dd>
				
			
				
				<dd><a href="#MemProfileRecord">type MemProfileRecord</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MemProfileRecord.InUseBytes">func (r *MemProfileRecord) InUseBytes() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MemProfileRecord.InUseObjects">func (r *MemProfileRecord) InUseObjects() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MemProfileRecord.Stack">func (r *MemProfileRecord) Stack() []uintptr</a></dd>
				
			
				
				<dd><a href="#MemStats">type MemStats</a></dd>
				
				
			
				
				<dd><a href="#StackRecord">type StackRecord</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#StackRecord.Stack">func (r *StackRecord) Stack() []uintptr</a></dd>
				
			
				
				<dd><a href="#TypeAssertionError">type TypeAssertionError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAssertionError.Error">func (e *TypeAssertionError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAssertionError.RuntimeError">func (*TypeAssertionError) RuntimeError()</a></dd>
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/runtime/compiler.htm">compiler.go</a>
			
				<a href="src/pkg/runtime/debug.htm">debug.go</a>
			
				<a href="src/pkg/runtime/error.htm">error.go</a>
			
				<a href="src/pkg/runtime/extern.htm">extern.go</a>
			
				<a href="src/pkg/runtime/mem.htm">mem.go</a>
			
				<a href="src/pkg/runtime/softfloat64.htm">softfloat64.go</a>
			
				<a href="src/pkg/runtime/type.htm">type.go</a>
			
				<a href="src/pkg/runtime/zgoarch_amd64.htm">zgoarch_amd64.go</a>
			
				<a href="src/pkg/runtime/zgoos_linux.htm">zgoos_linux.go</a>
			
				<a href="src/pkg/runtime/zruntime_defs_linux_amd64.htm">zruntime_defs_linux_amd64.go</a>
			
				<a href="src/pkg/runtime/zversion.htm">zversion.go</a>
			
			</span>
			</p>
		
	
		
			<h2 id="constants">Constants</h2>
			
				<pre>const Compiler = &#34;gc&#34;</pre>
				<p>
Compiler is the name of the compiler toolchain that built the
running binary.  Known toolchains are:
</p>
<pre>gc      The 5g/6g/8g compiler suite at code.google.com/p/go.
gccgo   The gccgo front end, part of the GCC compiler suite.
</pre>

			
				<pre>const GOARCH string = theGoarch</pre>
				<p>
GOARCH is the running program&#39;s architecture target:
386, amd64, or arm.
</p>

			
				<pre>const GOOS string = theGoos</pre>
				<p>
GOOS is the running program&#39;s operating system target:
one of darwin, freebsd, linux, and so on.
</p>

			
		
		
			<h2 id="variables">Variables</h2>
			
				<pre>var MemProfileRate int = 512 * 1024</pre>
				<p>
MemProfileRate controls the fraction of memory allocations
that are recorded and reported in the memory profile.
The profiler aims to sample an average of
one allocation per MemProfileRate bytes allocated.
</p>
<p>
To include every allocated block in the profile, set MemProfileRate to 1.
To turn off profiling entirely, set MemProfileRate to 0.
</p>
<p>
The tools that process the memory profiles assume that the
profile rate is constant across the lifetime of the program
and equal to the current value.  Programs that change the
memory profiling rate should do so just once, as early as
possible in the execution of the program (for example,
at the beginning of main).
</p>

			
		
		
			
			
			<h2 id="Breakpoint">func <a href="src/pkg/runtime/debug.htm#L1">Breakpoint</a></h2>
			<pre>func Breakpoint()</pre>
			<p>
Breakpoint() executes a breakpoint trap.
</p>

			
		
			
			
			<h2 id="CPUProfile">func <a href="src/pkg/runtime/debug.htm#L121">CPUProfile</a></h2>
			<pre>func CPUProfile() []byte</pre>
			<p>
CPUProfile returns the next chunk of binary CPU profiling stack trace data,
blocking until data is available.  If profiling is turned off and all the profile
data accumulated while it was on has been returned, CPUProfile returns nil.
The caller must save the returned data before calling CPUProfile again.
Most clients should use the runtime/pprof package or
the testing package&#39;s -test.cpuprofile flag instead of calling
CPUProfile directly.
</p>

			
		
			
			
			<h2 id="Caller">func <a href="src/pkg/runtime/extern.htm#L17">Caller</a></h2>
			<pre>func Caller(skip int) (pc uintptr, file string, line int, ok bool)</pre>
			<p>
Caller reports file and line number information about function invocations on
the calling goroutine&#39;s stack.  The argument skip is the number of stack frames
to ascend, with 1 identifying the caller of Caller.  (For historical reasons the
meaning of skip differs between Caller and Callers.) The return values report the
program counter, file name, and line number within the file of the corresponding
call.  The boolean ok is false if it was not possible to recover the information.
</p>

			
		
			
			
			<h2 id="Callers">func <a href="src/pkg/runtime/extern.htm#L23">Callers</a></h2>
			<pre>func Callers(skip int, pc []uintptr) int</pre>
			<p>
Callers fills the slice pc with the program counters of function invocations
on the calling goroutine&#39;s stack.  The argument skip is the number of stack frames
to skip before recording in pc, with 0 starting at the caller of Callers.
It returns the number of entries written to pc.
</p>

			
		
			
			
			<h2 id="GC">func <a href="src/pkg/runtime/mem.htm#L61">GC</a></h2>
			<pre>func GC()</pre>
			<p>
GC runs a garbage collection.
</p>

			
		
			
			
			<h2 id="GOMAXPROCS">func <a href="src/pkg/runtime/debug.htm#L14">GOMAXPROCS</a></h2>
			<pre>func GOMAXPROCS(n int) int</pre>
			<p>
GOMAXPROCS sets the maximum number of CPUs that can be executing
simultaneously and returns the previous setting.  If n &lt; 1, it does not
change the current setting.
The number of logical CPUs on the local machine can be queried with NumCPU.
This call will go away when the scheduler improves.
</p>

			
		
			
			
			<h2 id="GOROOT">func <a href="src/pkg/runtime/extern.htm#L107">GOROOT</a></h2>
			<pre>func GOROOT() string</pre>
			<p>
GOROOT returns the root of the Go tree.
It uses the GOROOT environment variable, if set,
or else the root used during the Go build.
</p>

			
		
			
			
			<h2 id="Goexit">func <a href="src/pkg/runtime/extern.htm#L9">Goexit</a></h2>
			<pre>func Goexit()</pre>
			<p>
Goexit terminates the goroutine that calls it.  No other goroutine is affected.
Goexit runs all deferred calls before terminating the goroutine.
</p>

			
		
			
			
			<h2 id="GoroutineProfile">func <a href="src/pkg/runtime/debug.htm#L112">GoroutineProfile</a></h2>
			<pre>func GoroutineProfile(p []StackRecord) (n int, ok bool)</pre>
			<p>
GoroutineProfile returns n, the number of records in the active goroutine stack profile.
If len(p) &gt;= n, GoroutineProfile copies the profile into p and returns n, true.
If len(p) &lt; n, GoroutineProfile does not change p and returns n, false.
</p>
<p>
Most clients should use the runtime/pprof package instead
of calling GoroutineProfile directly.
</p>

			
		
			
			
			<h2 id="Gosched">func <a href="src/pkg/runtime/extern.htm#L5">Gosched</a></h2>
			<pre>func Gosched()</pre>
			<p>
Gosched yields the processor, allowing other goroutines to run.  It does not
suspend the current goroutine, so execution resumes automatically.
</p>

			
		
			
			
			<h2 id="LockOSThread">func <a href="src/pkg/runtime/debug.htm#L3">LockOSThread</a></h2>
			<pre>func LockOSThread()</pre>
			<p>
LockOSThread wires the calling goroutine to its current operating system thread.
Until the calling goroutine exits or calls UnlockOSThread, it will always
execute in that thread, and no other goroutine can.
</p>

			
		
			
			
			<h2 id="MemProfile">func <a href="src/pkg/runtime/debug.htm#L80">MemProfile</a></h2>
			<pre>func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)</pre>
			<p>
MemProfile returns n, the number of records in the current memory profile.
If len(p) &gt;= n, MemProfile copies the profile into p and returns n, true.
If len(p) &lt; n, MemProfile does not change p and returns n, false.
</p>
<p>
If inuseZero is true, the profile includes allocation records
where r.AllocBytes &gt; 0 but r.AllocBytes == r.FreeBytes.
These are sites where memory was allocated, but it has all
been released back to the runtime.
</p>
<p>
Most clients should use the runtime/pprof package or
the testing package&#39;s -test.memprofile flag instead
of calling MemProfile directly.
</p>

			
		
			
			
			<h2 id="NumCPU">func <a href="src/pkg/runtime/debug.htm#L17">NumCPU</a></h2>
			<pre>func NumCPU() int</pre>
			<p>
NumCPU returns the number of logical CPUs on the local machine.
</p>

			
		
			
			
			<h2 id="NumCgoCall">func <a href="src/pkg/runtime/debug.htm#L20">NumCgoCall</a></h2>
			<pre>func NumCgoCall() int64</pre>
			<p>
NumCgoCall returns the number of cgo calls made by the current process.
</p>

			
		
			
			
			<h2 id="NumGoroutine">func <a href="src/pkg/runtime/debug.htm#L23">NumGoroutine</a></h2>
			<pre>func NumGoroutine() int</pre>
			<p>
NumGoroutine returns the number of goroutines that currently exist.
</p>

			
		
			
			
			<h2 id="ReadMemStats">func <a href="src/pkg/runtime/mem.htm#L58">ReadMemStats</a></h2>
			<pre>func ReadMemStats(m *MemStats)</pre>
			<p>
ReadMemStats populates m with memory allocator statistics.
</p>

			
		
			
			
			<h2 id="SetCPUProfileRate">func <a href="src/pkg/runtime/debug.htm#L129">SetCPUProfileRate</a></h2>
			<pre>func SetCPUProfileRate(hz int)</pre>
			<p>
SetCPUProfileRate sets the CPU profiling rate to hz samples per second.
If hz &lt;= 0, SetCPUProfileRate turns off profiling.
If the profiler is on, the rate cannot be changed without first turning it off.
Most clients should use the runtime/pprof package or
the testing package&#39;s -test.cpuprofile flag instead of calling
SetCPUProfileRate directly.
</p>

			
		
			
			
			<h2 id="SetFinalizer">func <a href="src/pkg/runtime/extern.htm#L100">SetFinalizer</a></h2>
			<pre>func SetFinalizer(x, f interface{})</pre>
			<p>
SetFinalizer sets the finalizer associated with x to f.
When the garbage collector finds an unreachable block
with an associated finalizer, it clears the association and runs
f(x) in a separate goroutine.  This makes x reachable again, but
now without an associated finalizer.  Assuming that SetFinalizer
is not called again, the next time the garbage collector sees
that x is unreachable, it will free x.
</p>
<p>
SetFinalizer(x, nil) clears any finalizer associated with x.
</p>
<p>
The argument x must be a pointer to an object allocated by
calling new or by taking the address of a composite literal.
The argument f must be a function that takes a single argument
of x&#39;s type and can have arbitrary ignored return values.
If either of these is not true, SetFinalizer aborts the program.
</p>
<p>
Finalizers are run in dependency order: if A points at B, both have
finalizers, and they are otherwise unreachable, only the finalizer
for A runs; once A is freed, the finalizer for B can run.
If a cyclic structure includes a block with a finalizer, that
cycle is not guaranteed to be garbage collected and the finalizer
is not guaranteed to run, because there is no ordering that
respects the dependencies.
</p>
<p>
The finalizer for x is scheduled to run at some arbitrary time after
x becomes unreachable.
There is no guarantee that finalizers will run before a program exits,
so typically they are useful only for releasing non-memory resources
associated with an object during a long-running program.
For example, an os.File object could use a finalizer to close the
associated operating system file descriptor when a program discards
an os.File without calling Close, but it would be a mistake
to depend on a finalizer to flush an in-memory I/O buffer such as a
bufio.Writer, because the buffer would not be flushed at program exit.
</p>
<p>
A single goroutine runs all finalizers for a program, sequentially.
If a finalizer must run for a long time, it should do so by starting
a new goroutine.
</p>

			
		
			
			
			<h2 id="Stack">func <a href="src/pkg/runtime/debug.htm#L135">Stack</a></h2>
			<pre>func Stack(buf []byte, all bool) int</pre>
			<p>
Stack formats a stack trace of the calling goroutine into buf
and returns the number of bytes written to buf.
If all is true, Stack formats stack traces of all other goroutines
into buf after the trace for the current goroutine.
</p>

			
		
			
			
			<h2 id="ThreadCreateProfile">func <a href="src/pkg/runtime/debug.htm#L104">ThreadCreateProfile</a></h2>
			<pre>func ThreadCreateProfile(p []StackRecord) (n int, ok bool)</pre>
			<p>
ThreadCreateProfile returns n, the number of records in the thread creation profile.
If len(p) &gt;= n, ThreadCreateProfile copies the profile into p and returns n, true.
If len(p) &lt; n, ThreadCreateProfile does not change p and returns n, false.
</p>
<p>
Most clients should use the runtime/pprof package instead
of calling ThreadCreateProfile directly.
</p>

			
		
			
			
			<h2 id="UnlockOSThread">func <a href="src/pkg/runtime/debug.htm#L7">UnlockOSThread</a></h2>
			<pre>func UnlockOSThread()</pre>
			<p>
UnlockOSThread unwires the calling goroutine from its fixed operating system thread.
If the calling goroutine has not called LockOSThread, UnlockOSThread is a no-op.
</p>

			
		
			
			
			<h2 id="Version">func <a href="src/pkg/runtime/extern.htm#L120">Version</a></h2>
			<pre>func Version() string</pre>
			<p>
Version returns the Go tree&#39;s version string.
It is either a sequence number or, when possible,
a release tag like &#34;release.2010-03-04&#34;.
A trailing + indicates that the tree had local modifications
at the time of the build.
</p>

			
		
		
			
			
			<h2 id="Error">type <a href="src/pkg/runtime/error.htm#L1">Error</a></h2>
			<pre>type Error interface {
    error

    <span class="comment">// RuntimeError is a no-op function but</span>
    <span class="comment">// serves to distinguish types that are runtime</span>
    <span class="comment">// errors from ordinary errors: a type is a</span>
    <span class="comment">// runtime error if it has a RuntimeError method.</span>
    RuntimeError()
}</pre>
			<p>
The Error interface identifies a run time error.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Func">type <a href="src/pkg/runtime/extern.htm#L25">Func</a></h2>
			<pre>type Func struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			
				
				<h3 id="FuncForPC">func <a href="src/pkg/runtime/extern.htm#L40">FuncForPC</a></h3>
				<pre>func FuncForPC(pc uintptr) *Func</pre>
				<p>
FuncForPC returns a *Func describing the function that contains the
given program counter address, or else nil.
</p>

				
			

			
				
				<h3 id="Func.Entry">func (*Func) <a href="src/pkg/runtime/extern.htm#L46">Entry</a></h3>
				<pre>func (f *Func) Entry() uintptr</pre>
				<p>
Entry returns the entry address of the function.
</p>

				
				
			
				
				<h3 id="Func.FileLine">func (*Func) <a href="src/pkg/runtime/extern.htm#L52">FileLine</a></h3>
				<pre>func (f *Func) FileLine(pc uintptr) (file string, line int)</pre>
				<p>
FileLine returns the file name and line number of the
source code corresponding to the program counter pc.
The result will not be accurate if pc is not a program
counter within f.
</p>

				
				
			
				
				<h3 id="Func.Name">func (*Func) <a href="src/pkg/runtime/extern.htm#L43">Name</a></h3>
				<pre>func (f *Func) Name() string</pre>
				<p>
Name returns the name of the function.
</p>

				
				
			
		
			
			
			<h2 id="MemProfileRecord">type <a href="src/pkg/runtime/debug.htm#L43">MemProfileRecord</a></h2>
			<pre>type MemProfileRecord struct {
    AllocBytes, FreeBytes     int64       <span class="comment">// number of bytes allocated, freed</span>
    AllocObjects, FreeObjects int64       <span class="comment">// number of objects allocated, freed</span>
    Stack0                    [32]uintptr <span class="comment">// stack trace for this record; ends at first 0 entry</span>
}</pre>
			<p>
A MemProfileRecord describes the live objects allocated
by a particular call sequence (stack trace).
</p>


			

			

			

			

			
				
				<h3 id="MemProfileRecord.InUseBytes">func (*MemProfileRecord) <a href="src/pkg/runtime/debug.htm#L50">InUseBytes</a></h3>
				<pre>func (r *MemProfileRecord) InUseBytes() int64</pre>
				<p>
InUseBytes returns the number of bytes in use (AllocBytes - FreeBytes).
</p>

				
				
			
				
				<h3 id="MemProfileRecord.InUseObjects">func (*MemProfileRecord) <a href="src/pkg/runtime/debug.htm#L53">InUseObjects</a></h3>
				<pre>func (r *MemProfileRecord) InUseObjects() int64</pre>
				<p>
InUseObjects returns the number of objects in use (AllocObjects - FreeObjects).
</p>

				
				
			
				
				<h3 id="MemProfileRecord.Stack">func (*MemProfileRecord) <a href="src/pkg/runtime/debug.htm#L59">Stack</a></h3>
				<pre>func (r *MemProfileRecord) Stack() []uintptr</pre>
				<p>
Stack returns the stack trace associated with the record,
a prefix of r.Stack0.
</p>

				
				
			
		
			
			
			<h2 id="MemStats">type <a href="src/pkg/runtime/mem.htm#L1">MemStats</a></h2>
			<pre>type MemStats struct {
    <span class="comment">// General statistics.</span>
    Alloc      uint64 <span class="comment">// bytes allocated and still in use</span>
    TotalAlloc uint64 <span class="comment">// bytes allocated (even if freed)</span>
    Sys        uint64 <span class="comment">// bytes obtained from system (should be sum of XxxSys below)</span>
    Lookups    uint64 <span class="comment">// number of pointer lookups</span>
    Mallocs    uint64 <span class="comment">// number of mallocs</span>
    Frees      uint64

    <span class="comment">// Main allocation heap statistics.</span>
    HeapAlloc    uint64 <span class="comment">// bytes allocated and still in use</span>
    HeapSys      uint64 <span class="comment">// bytes obtained from system</span>
    HeapIdle     uint64 <span class="comment">// bytes in idle spans</span>
    HeapInuse    uint64 <span class="comment">// bytes in non-idle span</span>
    HeapReleased uint64 <span class="comment">// bytes released to the OS</span>
    HeapObjects  uint64

    <span class="comment">// Low-level fixed-size structure allocator statistics.</span>
    <span class="comment">//	Inuse is bytes used now.</span>
    <span class="comment">//	Sys is bytes obtained from system.</span>
    StackInuse  uint64 <span class="comment">// bootstrap stacks</span>
    StackSys    uint64
    MSpanInuse  uint64 <span class="comment">// mspan structures</span>
    MSpanSys    uint64
    MCacheInuse uint64 <span class="comment">// mcache structures</span>
    MCacheSys   uint64
    BuckHashSys uint64

    <span class="comment">// Garbage collector statistics.</span>
    NextGC       uint64 <span class="comment">// next run in HeapAlloc time (bytes)</span>
    LastGC       uint64 <span class="comment">// last run in absolute time (ns)</span>
    PauseTotalNs uint64
    PauseNs      [256]uint64 <span class="comment">// most recent GC pause times</span>
    NumGC        uint32
    EnableGC     bool
    DebugGC      bool

    <span class="comment">// Per-size allocation statistics.</span>
    <span class="comment">// 61 is NumSizeClasses in the C code.</span>
    BySize [61]struct {
        Size    uint32
        Mallocs uint64
        Frees   uint64
    }
}</pre>
			<p>
A MemStats records statistics about the memory allocator.
</p>


			

			

			

			

			
		
			
			
			<h2 id="StackRecord">type <a href="src/pkg/runtime/debug.htm#L83">StackRecord</a></h2>
			<pre>type StackRecord struct {
    Stack0 [32]uintptr <span class="comment">// stack trace for this record; ends at first 0 entry</span>
}</pre>
			<p>
A StackRecord describes a single execution stack.
</p>


			

			

			

			

			
				
				<h3 id="StackRecord.Stack">func (*StackRecord) <a href="src/pkg/runtime/debug.htm#L89">Stack</a></h3>
				<pre>func (r *StackRecord) Stack() []uintptr</pre>
				<p>
Stack returns the stack trace associated with the record,
a prefix of r.Stack0.
</p>

				
				
			
		
			
			
			<h2 id="TypeAssertionError">type <a href="src/pkg/runtime/error.htm#L9">TypeAssertionError</a></h2>
			<pre>type TypeAssertionError struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A TypeAssertionError explains a failed type assertion.
</p>


			

			

			

			

			
				
				<h3 id="TypeAssertionError.Error">func (*TypeAssertionError) <a href="src/pkg/runtime/error.htm#L18">Error</a></h3>
				<pre>func (e *TypeAssertionError) Error() string</pre>
				
				
				
			
				
				<h3 id="TypeAssertionError.RuntimeError">func (*TypeAssertionError) <a href="src/pkg/runtime/error.htm#L16">RuntimeError</a></h3>
				<pre>func (*TypeAssertionError) RuntimeError()</pre>
				
				
				
			
		
		</div>
	

	







	
	
		<h2 id="subdirectories">Subdirectories</h2>
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
	
			<tr>
			<td class="name"><a href="runtime_cgo.htm">cgo</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package cgo contains runtime support for code generated by the cgo tool.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="runtime_debug.htm">debug</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package debug contains facilities for programs to debug themselves while they are running.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="runtime_pprof.htm">pprof</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package pprof writes runtime profiling data in the format expected by the pprof visualization tool.</td>
			</tr>
		
	
	</table>
	



</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
