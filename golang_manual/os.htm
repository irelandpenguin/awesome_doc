
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>os - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package os</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "os"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
			
				<dd><a href="#subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package os provides a platform-independent interface to operating system
functionality. The design is Unix-like, although the error handling is
Go-like; failing calls return values of type error rather than error numbers.
Often, more information is available within the error. For example,
if a call that takes a file name fails, such as Open or Stat, the error
will include the failing file name when printed and will be of type
*PathError, which may be unpacked for more information.
</p>
<p>
The os interface is intended to be uniform across all operating systems.
Features not generally available appear in the system-specific package syscall.
</p>
<p>
Here is a simple example, opening a file and reading some of it.
</p>
<pre>file, err := os.Open(&#34;file.go&#34;) // For read access.
if err != nil {
	log.Fatal(err)
}
</pre>
<p>
If the open fails, the error string will be self-explanatory, like
</p>
<pre>open file.go: no such file or directory
</pre>
<p>
The file&#39;s data can then be read into a slice of bytes. Read and
Write take their byte counts from the length of the argument slice.
</p>
<pre>data := make([]byte, 100)
count, err := file.Read(data)
if err != nil {
	log.Fatal(err)
}
fmt.Printf(&#34;read %d bytes: %q\n&#34;, count, data[:count])
</pre>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
				<dd><a href="#constants">Constants</a></dd>
			
			
				<dd><a href="#variables">Variables</a></dd>
			
			
				
				<dd><a href="#Chdir">func Chdir(dir string) error</a></dd>
			
				
				<dd><a href="#Chmod">func Chmod(name string, mode FileMode) error</a></dd>
			
				
				<dd><a href="#Chown">func Chown(name string, uid, gid int) error</a></dd>
			
				
				<dd><a href="#Chtimes">func Chtimes(name string, atime time.Time, mtime time.Time) error</a></dd>
			
				
				<dd><a href="#Clearenv">func Clearenv()</a></dd>
			
				
				<dd><a href="#Environ">func Environ() []string</a></dd>
			
				
				<dd><a href="#Exit">func Exit(code int)</a></dd>
			
				
				<dd><a href="#Expand">func Expand(s string, mapping func(string) string) string</a></dd>
			
				
				<dd><a href="#ExpandEnv">func ExpandEnv(s string) string</a></dd>
			
				
				<dd><a href="#Getegid">func Getegid() int</a></dd>
			
				
				<dd><a href="#Getenv">func Getenv(key string) string</a></dd>
			
				
				<dd><a href="#Geteuid">func Geteuid() int</a></dd>
			
				
				<dd><a href="#Getgid">func Getgid() int</a></dd>
			
				
				<dd><a href="#Getgroups">func Getgroups() ([]int, error)</a></dd>
			
				
				<dd><a href="#Getpagesize">func Getpagesize() int</a></dd>
			
				
				<dd><a href="#Getpid">func Getpid() int</a></dd>
			
				
				<dd><a href="#Getppid">func Getppid() int</a></dd>
			
				
				<dd><a href="#Getuid">func Getuid() int</a></dd>
			
				
				<dd><a href="#Getwd">func Getwd() (pwd string, err error)</a></dd>
			
				
				<dd><a href="#Hostname">func Hostname() (name string, err error)</a></dd>
			
				
				<dd><a href="#IsExist">func IsExist(err error) bool</a></dd>
			
				
				<dd><a href="#IsNotExist">func IsNotExist(err error) bool</a></dd>
			
				
				<dd><a href="#IsPathSeparator">func IsPathSeparator(c uint8) bool</a></dd>
			
				
				<dd><a href="#IsPermission">func IsPermission(err error) bool</a></dd>
			
				
				<dd><a href="#Lchown">func Lchown(name string, uid, gid int) error</a></dd>
			
				
				<dd><a href="#Link">func Link(oldname, newname string) error</a></dd>
			
				
				<dd><a href="#Mkdir">func Mkdir(name string, perm FileMode) error</a></dd>
			
				
				<dd><a href="#MkdirAll">func MkdirAll(path string, perm FileMode) error</a></dd>
			
				
				<dd><a href="#NewSyscallError">func NewSyscallError(syscall string, err error) error</a></dd>
			
				
				<dd><a href="#Readlink">func Readlink(name string) (string, error)</a></dd>
			
				
				<dd><a href="#Remove">func Remove(name string) error</a></dd>
			
				
				<dd><a href="#RemoveAll">func RemoveAll(path string) error</a></dd>
			
				
				<dd><a href="#Rename">func Rename(oldname, newname string) error</a></dd>
			
				
				<dd><a href="#SameFile">func SameFile(fi1, fi2 FileInfo) bool</a></dd>
			
				
				<dd><a href="#Setenv">func Setenv(key, value string) error</a></dd>
			
				
				<dd><a href="#Symlink">func Symlink(oldname, newname string) error</a></dd>
			
				
				<dd><a href="#TempDir">func TempDir() string</a></dd>
			
				
				<dd><a href="#Truncate">func Truncate(name string, size int64) error</a></dd>
			
			
				
				<dd><a href="#File">type File</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Create">func Create(name string) (file *File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFile">func NewFile(fd uintptr, name string) *File</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Open">func Open(name string) (file *File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#OpenFile">func OpenFile(name string, flag int, perm FileMode) (file *File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Pipe">func Pipe() (r *File, w *File, err error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Chdir">func (f *File) Chdir() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Chmod">func (f *File) Chmod(mode FileMode) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Chown">func (f *File) Chown(uid, gid int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Close">func (f *File) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Fd">func (f *File) Fd() uintptr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Name">func (f *File) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Read">func (f *File) Read(b []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.ReadAt">func (f *File) ReadAt(b []byte, off int64) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Readdir">func (f *File) Readdir(n int) (fi []FileInfo, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Readdirnames">func (f *File) Readdirnames(n int) (names []string, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Seek">func (f *File) Seek(offset int64, whence int) (ret int64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Stat">func (f *File) Stat() (fi FileInfo, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Sync">func (f *File) Sync() (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Truncate">func (f *File) Truncate(size int64) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Write">func (f *File) Write(b []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.WriteAt">func (f *File) WriteAt(b []byte, off int64) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.WriteString">func (f *File) WriteString(s string) (ret int, err error)</a></dd>
				
			
				
				<dd><a href="#FileInfo">type FileInfo</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Lstat">func Lstat(name string) (fi FileInfo, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Stat">func Stat(name string) (fi FileInfo, err error)</a></dd>
				
				
			
				
				<dd><a href="#FileMode">type FileMode</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FileMode.IsDir">func (m FileMode) IsDir() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FileMode.Perm">func (m FileMode) Perm() FileMode</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FileMode.String">func (m FileMode) String() string</a></dd>
				
			
				
				<dd><a href="#LinkError">type LinkError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LinkError.Error">func (e *LinkError) Error() string</a></dd>
				
			
				
				<dd><a href="#PathError">type PathError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PathError.Error">func (e *PathError) Error() string</a></dd>
				
			
				
				<dd><a href="#ProcAttr">type ProcAttr</a></dd>
				
				
			
				
				<dd><a href="#Process">type Process</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FindProcess">func FindProcess(pid int) (p *Process, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StartProcess">func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Process.Kill">func (p *Process) Kill() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Process.Release">func (p *Process) Release() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Process.Signal">func (p *Process) Signal(sig Signal) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Process.Wait">func (p *Process) Wait() (*ProcessState, error)</a></dd>
				
			
				
				<dd><a href="#ProcessState">type ProcessState</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ProcessState.Exited">func (p *ProcessState) Exited() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ProcessState.Pid">func (p *ProcessState) Pid() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ProcessState.String">func (p *ProcessState) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ProcessState.Success">func (p *ProcessState) Success() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ProcessState.Sys">func (p *ProcessState) Sys() interface{}</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ProcessState.SysUsage">func (p *ProcessState) SysUsage() interface{}</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ProcessState.SystemTime">func (p *ProcessState) SystemTime() time.Duration</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ProcessState.UserTime">func (p *ProcessState) UserTime() time.Duration</a></dd>
				
			
				
				<dd><a href="#Signal">type Signal</a></dd>
				
				
			
				
				<dd><a href="#SyscallError">type SyscallError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SyscallError.Error">func (e *SyscallError) Error() string</a></dd>
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/os/dir_unix.htm">dir_unix.go</a>
			
				<a href="src/pkg/os/doc.htm">doc.go</a>
			
				<a href="src/pkg/os/env.htm">env.go</a>
			
				<a href="src/pkg/os/error.htm">error.go</a>
			
				<a href="src/pkg/os/error_posix.htm">error_posix.go</a>
			
				<a href="src/pkg/os/exec.htm">exec.go</a>
			
				<a href="src/pkg/os/exec_posix.htm">exec_posix.go</a>
			
				<a href="src/pkg/os/exec_unix.htm">exec_unix.go</a>
			
				<a href="src/pkg/os/file.htm">file.go</a>
			
				<a href="src/pkg/os/file_posix.htm">file_posix.go</a>
			
				<a href="src/pkg/os/file_unix.htm">file_unix.go</a>
			
				<a href="src/pkg/os/getwd.htm">getwd.go</a>
			
				<a href="src/pkg/os/path.htm">path.go</a>
			
				<a href="src/pkg/os/path_unix.htm">path_unix.go</a>
			
				<a href="src/pkg/os/proc.htm">proc.go</a>
			
				<a href="src/pkg/os/stat_linux.htm">stat_linux.go</a>
			
				<a href="src/pkg/os/sys_linux.htm">sys_linux.go</a>
			
				<a href="src/pkg/os/types.htm">types.go</a>
			
			</span>
			</p>
		
	
		
			<h2 id="constants">Constants</h2>
			
				<pre>const (
    O_RDONLY int = syscall.O_RDONLY <span class="comment">// open the file read-only.</span>
    O_WRONLY int = syscall.O_WRONLY <span class="comment">// open the file write-only.</span>
    O_RDWR   int = syscall.O_RDWR   <span class="comment">// open the file read-write.</span>
    O_APPEND int = syscall.O_APPEND <span class="comment">// append data to the file when writing.</span>
    O_CREATE int = syscall.O_CREAT  <span class="comment">// create a new file if none exists.</span>
    O_EXCL   int = syscall.O_EXCL   <span class="comment">// used with O_CREATE, file must not exist</span>
    O_SYNC   int = syscall.O_SYNC   <span class="comment">// open for synchronous I/O.</span>
    O_TRUNC  int = syscall.O_TRUNC  <span class="comment">// if possible, truncate file when opened.</span>
)</pre>
				<p>
Flags to Open wrapping those of the underlying system. Not all flags
may be implemented on a given system.
</p>

			
				<pre>const (
    SEEK_SET int = 0 <span class="comment">// seek relative to the origin of the file</span>
    SEEK_CUR int = 1 <span class="comment">// seek relative to the current offset</span>
    SEEK_END int = 2 <span class="comment">// seek relative to the end</span>
)</pre>
				<p>
Seek whence values.
</p>

			
				<pre>const (
    PathSeparator     = &#39;/&#39; <span class="comment">// OS-specific path separator</span>
    PathListSeparator = &#39;:&#39; <span class="comment">// OS-specific path list separator</span>
)</pre>
				
			
				<pre>const DevNull = &#34;/dev/null&#34;</pre>
				<p>
DevNull is the name of the operating system&#39;s &ldquo;null device.&rdquo;
On Unix-like systems, it is &#34;/dev/null&#34;; on Windows, &#34;NUL&#34;.
</p>

			
		
		
			<h2 id="variables">Variables</h2>
			
				<pre>var (
    ErrInvalid    = errors.New(&#34;invalid argument&#34;)
    ErrPermission = errors.New(&#34;permission denied&#34;)
    ErrExist      = errors.New(&#34;file already exists&#34;)
    ErrNotExist   = errors.New(&#34;file does not exist&#34;)
)</pre>
				<p>
Portable analogs of some common system call errors.
</p>

			
				<pre>var (
    Stdin  = NewFile(uintptr(syscall.Stdin), &#34;/dev/stdin&#34;)
    Stdout = NewFile(uintptr(syscall.Stdout), &#34;/dev/stdout&#34;)
    Stderr = NewFile(uintptr(syscall.Stderr), &#34;/dev/stderr&#34;)
)</pre>
				<p>
Stdin, Stdout, and Stderr are open Files pointing to the standard input,
standard output, and standard error file descriptors.
</p>

			
				<pre>var Args []string</pre>
				<p>
Args hold the command-line arguments, starting with the program name.
</p>

			
		
		
			
			
			<h2 id="Chdir">func <a href="src/pkg/os/file.htm#L198">Chdir</a></h2>
			<pre>func Chdir(dir string) error</pre>
			<p>
Chdir changes the current working directory to the named directory.
If there is an error, it will be of type *PathError.
</p>

			
		
			
			
			<h2 id="Chmod">func <a href="src/pkg/os/file_posix.htm#L82">Chmod</a></h2>
			<pre>func Chmod(name string, mode FileMode) error</pre>
			<p>
Chmod changes the mode of the named file to mode.
If the file is a symbolic link, it changes the mode of the link&#39;s target.
If there is an error, it will be of type *PathError.
</p>

			
		
			
			
			<h2 id="Chown">func <a href="src/pkg/os/file_posix.htm#L101">Chown</a></h2>
			<pre>func Chown(name string, uid, gid int) error</pre>
			<p>
Chown changes the numeric uid and gid of the named file.
If the file is a symbolic link, it changes the uid and gid of the link&#39;s target.
If there is an error, it will be of type *PathError.
</p>

			
		
			
			
			<h2 id="Chtimes">func <a href="src/pkg/os/file_posix.htm#L156">Chtimes</a></h2>
			<pre>func Chtimes(name string, atime time.Time, mtime time.Time) error</pre>
			<p>
Chtimes changes the access and modification times of the named
file, similar to the Unix utime() or utimes() functions.
</p>
<p>
The underlying filesystem may truncate or round the values to a
less precise time unit.
If there is an error, it will be of type *PathError.
</p>

			
		
			
			
			<h2 id="Clearenv">func <a href="src/pkg/os/env.htm#L85">Clearenv</a></h2>
			<pre>func Clearenv()</pre>
			<p>
Clearenv deletes all environment variables.
</p>

			
		
			
			
			<h2 id="Environ">func <a href="src/pkg/os/env.htm#L91">Environ</a></h2>
			<pre>func Environ() []string</pre>
			<p>
Environ returns a copy of strings representing the environment,
in the form &#34;key=value&#34;.
</p>

			
		
			
			
			<h2 id="Exit">func <a href="src/pkg/os/proc.htm#L24">Exit</a></h2>
			<pre>func Exit(code int)</pre>
			<p>
Exit causes the current program to exit with the given status code.
Conventionally, code zero indicates success, non-zero an error.
</p>

			
		
			
			
			<h2 id="Expand">func <a href="src/pkg/os/env.htm#L3">Expand</a></h2>
			<pre>func Expand(s string, mapping func(string) string) string</pre>
			<p>
Expand replaces ${var} or $var in the string based on the mapping function.
Invocations of undefined variables are replaced with the empty string.
</p>

			
		
			
			
			<h2 id="ExpandEnv">func <a href="src/pkg/os/env.htm#L22">ExpandEnv</a></h2>
			<pre>func ExpandEnv(s string) string</pre>
			<p>
ExpandEnv replaces ${var} or $var in the string according to the values
of the current environment variables.  References to undefined
variables are replaced by the empty string.
</p>

			
		
			
			
			<h2 id="Getegid">func <a href="src/pkg/os/proc.htm#L14">Getegid</a></h2>
			<pre>func Getegid() int</pre>
			<p>
Getegid returns the numeric effective group id of the caller.
</p>

			
		
			
			
			<h2 id="Getenv">func <a href="src/pkg/os/env.htm#L69">Getenv</a></h2>
			<pre>func Getenv(key string) string</pre>
			<p>
Getenv retrieves the value of the environment variable named by the key.
It returns the value, which will be empty if the variable is not present.
</p>

			
		
			
			
			<h2 id="Geteuid">func <a href="src/pkg/os/proc.htm#L8">Geteuid</a></h2>
			<pre>func Geteuid() int</pre>
			<p>
Geteuid returns the numeric effective user id of the caller.
</p>

			
		
			
			
			<h2 id="Getgid">func <a href="src/pkg/os/proc.htm#L11">Getgid</a></h2>
			<pre>func Getgid() int</pre>
			<p>
Getgid returns the numeric group id of the caller.
</p>

			
		
			
			
			<h2 id="Getgroups">func <a href="src/pkg/os/proc.htm#L17">Getgroups</a></h2>
			<pre>func Getgroups() ([]int, error)</pre>
			<p>
Getgroups returns a list of the numeric ids of groups that the caller belongs to.
</p>

			
		
			
			
			<h2 id="Getpagesize">func <a href="src/pkg/os/types.htm#L3">Getpagesize</a></h2>
			<pre>func Getpagesize() int</pre>
			<p>
Getpagesize returns the underlying system&#39;s memory page size.
</p>

			
		
			
			
			<h2 id="Getpid">func <a href="src/pkg/os/exec.htm#L56">Getpid</a></h2>
			<pre>func Getpid() int</pre>
			<p>
Getpid returns the process id of the caller.
</p>

			
		
			
			
			<h2 id="Getppid">func <a href="src/pkg/os/exec.htm#L59">Getppid</a></h2>
			<pre>func Getppid() int</pre>
			<p>
Getppid returns the process id of the caller&#39;s parent.
</p>

			
		
			
			
			<h2 id="Getuid">func <a href="src/pkg/os/proc.htm#L5">Getuid</a></h2>
			<pre>func Getuid() int</pre>
			<p>
Getuid returns the numeric user id of the caller.
</p>

			
		
			
			
			<h2 id="Getwd">func <a href="src/pkg/os/getwd.htm#L5">Getwd</a></h2>
			<pre>func Getwd() (pwd string, err error)</pre>
			<p>
Getwd returns a rooted path name corresponding to the
current directory.  If the current directory can be
reached via multiple paths (due to symbolic links),
Getwd may return any one of them.
</p>

			
		
			
			
			<h2 id="Hostname">func <a href="src/pkg/os/doc.htm#L77">Hostname</a></h2>
			<pre>func Hostname() (name string, err error)</pre>
			<p>
Hostname returns the host name reported by the kernel.
</p>

			
		
			
			
			<h2 id="IsExist">func <a href="src/pkg/os/error.htm#L38">IsExist</a></h2>
			<pre>func IsExist(err error) bool</pre>
			<p>
IsExist returns whether the error is known to report that a file or directory
already exists. It is satisfied by ErrExist as well as some syscall errors.
</p>

			
		
			
			
			<h2 id="IsNotExist">func <a href="src/pkg/os/error.htm#L44">IsNotExist</a></h2>
			<pre>func IsNotExist(err error) bool</pre>
			<p>
IsNotExist returns whether the error is known to report that a file or directory
does not exist. It is satisfied by ErrNotExist as well as some syscall errors.
</p>

			
		
			
			
			<h2 id="IsPathSeparator">func <a href="src/pkg/os/path_unix.htm#L5">IsPathSeparator</a></h2>
			<pre>func IsPathSeparator(c uint8) bool</pre>
			<p>
IsPathSeparator returns true if c is a directory separator character.
</p>

			
		
			
			
			<h2 id="IsPermission">func <a href="src/pkg/os/error.htm#L50">IsPermission</a></h2>
			<pre>func IsPermission(err error) bool</pre>
			<p>
IsPermission returns whether the error is known to report that permission is denied.
It is satisfied by ErrPermission as well as some syscall errors.
</p>

			
		
			
			
			<h2 id="Lchown">func <a href="src/pkg/os/file_posix.htm#L111">Lchown</a></h2>
			<pre>func Lchown(name string, uid, gid int) error</pre>
			<p>
Lchown changes the numeric uid and gid of the named file.
If the file is a symbolic link, it changes the uid and gid of the link itself.
If there is an error, it will be of type *PathError.
</p>

			
		
			
			
			<h2 id="Link">func <a href="src/pkg/os/file_posix.htm#L19">Link</a></h2>
			<pre>func Link(oldname, newname string) error</pre>
			<p>
Link creates newname as a hard link to the oldname file.
If there is an error, it will be of type *LinkError.
</p>

			
		
			
			
			<h2 id="Mkdir">func <a href="src/pkg/os/file.htm#L188">Mkdir</a></h2>
			<pre>func Mkdir(name string, perm FileMode) error</pre>
			<p>
Mkdir creates a new directory with the specified name and permission bits.
If there is an error, it will be of type *PathError.
</p>

			
		
			
			
			<h2 id="MkdirAll">func <a href="src/pkg/os/path.htm#L9">MkdirAll</a></h2>
			<pre>func MkdirAll(path string, perm FileMode) error</pre>
			<p>
MkdirAll creates a directory named path,
along with any necessary parents, and returns nil,
or else returns an error.
The permission bits perm are used for all
directories that MkdirAll creates.
If path is already a directory, MkdirAll does nothing
and returns nil.
</p>

			
		
			
			
			<h2 id="NewSyscallError">func <a href="src/pkg/os/error.htm#L29">NewSyscallError</a></h2>
			<pre>func NewSyscallError(syscall string, err error) error</pre>
			<p>
NewSyscallError returns, as an error, a new SyscallError
with the given system call name and error details.
As a convenience, if err is nil, NewSyscallError returns nil.
</p>

			
		
			
			
			<h2 id="Readlink">func <a href="src/pkg/os/file_posix.htm#L39">Readlink</a></h2>
			<pre>func Readlink(name string) (string, error)</pre>
			<p>
Readlink returns the destination of the named symbolic link.
If there is an error, it will be of type *PathError.
</p>

			
		
			
			
			<h2 id="Remove">func <a href="src/pkg/os/file_unix.htm#L209">Remove</a></h2>
			<pre>func Remove(name string) error</pre>
			<p>
Remove removes the named file or directory.
If there is an error, it will be of type *PathError.
</p>

			
		
			
			
			<h2 id="RemoveAll">func <a href="src/pkg/os/path.htm#L56">RemoveAll</a></h2>
			<pre>func RemoveAll(path string) error</pre>
			<p>
RemoveAll removes path and any children it contains.
It removes everything it can but returns the first error
it encounters.  If the path does not exist, RemoveAll
returns nil (no error).
</p>

			
		
			
			
			<h2 id="Rename">func <a href="src/pkg/os/file_posix.htm#L55">Rename</a></h2>
			<pre>func Rename(oldname, newname string) error</pre>
			<p>
Rename renames a file.
</p>

			
		
			
			
			<h2 id="SameFile">func <a href="src/pkg/os/types.htm#L108">SameFile</a></h2>
			<pre>func SameFile(fi1, fi2 FileInfo) bool</pre>
			<p>
SameFile reports whether fi1 and fi2 describe the same file.
For example, on Unix this means that the device and inode fields
of the two underlying structures are identical; on other systems
the decision may be based on the path names.
SameFile only applies to results returned by this package&#39;s Stat.
It returns false in other cases.
</p>

			
		
			
			
			<h2 id="Setenv">func <a href="src/pkg/os/env.htm#L76">Setenv</a></h2>
			<pre>func Setenv(key, value string) error</pre>
			<p>
Setenv sets the value of the environment variable named by the key.
It returns an error, if any.
</p>

			
		
			
			
			<h2 id="Symlink">func <a href="src/pkg/os/file_posix.htm#L29">Symlink</a></h2>
			<pre>func Symlink(oldname, newname string) error</pre>
			<p>
Symlink creates newname as a symbolic link to oldname.
If there is an error, it will be of type *LinkError.
</p>

			
		
			
			
			<h2 id="TempDir">func <a href="src/pkg/os/file_unix.htm#L276">TempDir</a></h2>
			<pre>func TempDir() string</pre>
			<p>
TempDir returns the default directory to use for temporary files.
</p>

			
		
			
			
			<h2 id="Truncate">func <a href="src/pkg/os/file_unix.htm#L200">Truncate</a></h2>
			<pre>func Truncate(name string, size int64) error</pre>
			<p>
Truncate changes the size of the named file.
If the file is a symbolic link, it changes the size of the link&#39;s target.
If there is an error, it will be of type *PathError.
</p>

			
		
		
			
			
			<h2 id="File">type <a href="src/pkg/os/file_unix.htm#L5">File</a></h2>
			<pre>type File struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
File represents an open file descriptor.
</p>


			

			

			

			
				
				<h3 id="Create">func <a href="src/pkg/os/file.htm#L228">Create</a></h3>
				<pre>func Create(name string) (file *File, err error)</pre>
				<p>
Create creates the named file mode 0666 (before umask), truncating
it if it already exists.  If successful, methods on the returned
File can be used for I/O; the associated file descriptor has mode
O_RDWR.
If there is an error, it will be of type *PathError.
</p>

				
			
				
				<h3 id="NewFile">func <a href="src/pkg/os/file_unix.htm#L29">NewFile</a></h3>
				<pre>func NewFile(fd uintptr, name string) *File</pre>
				<p>
NewFile returns a new File with the given file descriptor and name.
</p>

				
			
				
				<h3 id="Open">func <a href="src/pkg/os/file.htm#L219">Open</a></h3>
				<pre>func Open(name string) (file *File, err error)</pre>
				<p>
Open opens the named file for reading.  If successful, methods on
the returned file can be used for reading; the associated file
descriptor has mode O_RDONLY.
If there is an error, it will be of type *PathError.
</p>

				
			
				
				<h3 id="OpenFile">func <a href="src/pkg/os/file_unix.htm#L55">OpenFile</a></h3>
				<pre>func OpenFile(name string, flag int, perm FileMode) (file *File, err error)</pre>
				<p>
OpenFile is the generalized open call; most users will use Open
or Create instead.  It opens the named file with specified flag
(O_RDONLY etc.) and perm, (0666 etc.) if applicable.  If successful,
methods on the returned File can be used for I/O.
If there is an error, it will be of type *PathError.
</p>

				
			
				
				<h3 id="Pipe">func <a href="src/pkg/os/file_unix.htm#L258">Pipe</a></h3>
				<pre>func Pipe() (r *File, w *File, err error)</pre>
				<p>
Pipe returns a connected pair of Files; reads from r return bytes written to w.
It returns the files and an error, if any.
</p>

				
			

			
				
				<h3 id="File.Chdir">func (*File) <a href="src/pkg/os/file.htm#L208">Chdir</a></h3>
				<pre>func (f *File) Chdir() error</pre>
				<p>
Chdir changes the current working directory to the file,
which must be a directory.
If there is an error, it will be of type *PathError.
</p>

				
				
			
				
				<h3 id="File.Chmod">func (*File) <a href="src/pkg/os/file_posix.htm#L91">Chmod</a></h3>
				<pre>func (f *File) Chmod(mode FileMode) error</pre>
				<p>
Chmod changes the mode of the file to mode.
If there is an error, it will be of type *PathError.
</p>

				
				
			
				
				<h3 id="File.Chown">func (*File) <a href="src/pkg/os/file_posix.htm#L120">Chown</a></h3>
				<pre>func (f *File) Chown(uid, gid int) error</pre>
				<p>
Chown changes the numeric uid and gid of the named file.
If there is an error, it will be of type *PathError.
</p>

				
				
			
				
				<h3 id="File.Close">func (*File) <a href="src/pkg/os/file_unix.htm#L77">Close</a></h3>
				<pre>func (f *File) Close() error</pre>
				<p>
Close closes the File, rendering it unusable for I/O.
It returns an error, if any.
</p>

				
				
			
				
				<h3 id="File.Fd">func (*File) <a href="src/pkg/os/file_unix.htm#L21">Fd</a></h3>
				<pre>func (f *File) Fd() uintptr</pre>
				<p>
Fd returns the integer Unix file descriptor referencing the open file.
</p>

				
				
			
				
				<h3 id="File.Name">func (*File) <a href="src/pkg/os/file.htm#L35">Name</a></h3>
				<pre>func (f *File) Name() string</pre>
				<p>
Name returns the name of the file as presented to Open.
</p>

				
				
			
				
				<h3 id="File.Read">func (*File) <a href="src/pkg/os/file.htm#L81">Read</a></h3>
				<pre>func (f *File) Read(b []byte) (n int, err error)</pre>
				<p>
Read reads up to len(b) bytes from the File.
It returns the number of bytes read and an error, if any.
EOF is signaled by a zero count with err set to io.EOF.
</p>

				
				
			
				
				<h3 id="File.ReadAt">func (*File) <a href="src/pkg/os/file.htm#L102">ReadAt</a></h3>
				<pre>func (f *File) ReadAt(b []byte, off int64) (n int, err error)</pre>
				<p>
ReadAt reads len(b) bytes from the File starting at byte offset off.
It returns the number of bytes read and the error, if any.
ReadAt always returns a non-nil error when n &lt; len(b).
At end of file, that error is io.EOF.
</p>

				
				
			
				
				<h3 id="File.Readdir">func (*File) <a href="src/pkg/os/doc.htm#L96">Readdir</a></h3>
				<pre>func (f *File) Readdir(n int) (fi []FileInfo, err error)</pre>
				<p>
Readdir reads the contents of the directory associated with file and
returns an array of up to n FileInfo values, as would be returned
by Lstat, in directory order. Subsequent calls on the same file will yield
further FileInfos.
</p>
<p>
If n &gt; 0, Readdir returns at most n FileInfo structures. In this case, if
Readdir returns an empty slice, it will return a non-nil error
explaining why. At the end of a directory, the error is io.EOF.
</p>
<p>
If n &lt;= 0, Readdir returns all the FileInfo from the directory in
a single slice. In this case, if Readdir succeeds (reads all
the way to the end of the directory), it returns the slice and a
nil error. If it encounters an error before the end of the
directory, Readdir returns the FileInfo read until that point
and a non-nil error.
</p>

				
				
			
				
				<h3 id="File.Readdirnames">func (*File) <a href="src/pkg/os/doc.htm#L112">Readdirnames</a></h3>
				<pre>func (f *File) Readdirnames(n int) (names []string, err error)</pre>
				<p>
Readdirnames reads and returns a slice of names from the directory f.
</p>
<p>
If n &gt; 0, Readdirnames returns at most n names. In this case, if
Readdirnames returns an empty slice, it will return a non-nil error
explaining why. At the end of a directory, the error is io.EOF.
</p>
<p>
If n &lt;= 0, Readdirnames returns all the names from the directory in
a single slice. In this case, if Readdirnames succeeds (reads all
the way to the end of the directory), it returns the slice and a
nil error. If it encounters an error before the end of the
directory, Readdirnames returns the names read until that point and
a non-nil error.
</p>

				
				
			
				
				<h3 id="File.Seek">func (*File) <a href="src/pkg/os/file.htm#L166">Seek</a></h3>
				<pre>func (f *File) Seek(offset int64, whence int) (ret int64, err error)</pre>
				<p>
Seek sets the offset for the next Read or Write on file to offset, interpreted
according to whence: 0 means relative to the origin of the file, 1 means
relative to the current offset, and 2 means relative to the end.
It returns the new offset and an error, if any.
</p>

				
				
			
				
				<h3 id="File.Stat">func (*File) <a href="src/pkg/os/file_unix.htm#L98">Stat</a></h3>
				<pre>func (f *File) Stat() (fi FileInfo, err error)</pre>
				<p>
Stat returns the FileInfo structure describing file.
If there is an error, it will be of type *PathError.
</p>

				
				
			
				
				<h3 id="File.Sync">func (*File) <a href="src/pkg/os/file_posix.htm#L140">Sync</a></h3>
				<pre>func (f *File) Sync() (err error)</pre>
				<p>
Sync commits the current contents of the file to stable storage.
Typically, this means flushing the file system&#39;s in-memory copy
of recently written data to disk.
</p>

				
				
			
				
				<h3 id="File.Truncate">func (*File) <a href="src/pkg/os/file_posix.htm#L130">Truncate</a></h3>
				<pre>func (f *File) Truncate(size int64) error</pre>
				<p>
Truncate changes the size of the file.
It does not change the I/O offset.
If there is an error, it will be of type *PathError.
</p>

				
				
			
				
				<h3 id="File.Write">func (*File) <a href="src/pkg/os/file.htm#L125">Write</a></h3>
				<pre>func (f *File) Write(b []byte) (n int, err error)</pre>
				<p>
Write writes len(b) bytes to the File.
It returns the number of bytes written and an error, if any.
Write returns a non-nil error when n != len(b).
</p>

				
				
			
				
				<h3 id="File.WriteAt">func (*File) <a href="src/pkg/os/file.htm#L145">WriteAt</a></h3>
				<pre>func (f *File) WriteAt(b []byte, off int64) (n int, err error)</pre>
				<p>
WriteAt writes len(b) bytes to the File starting at byte offset off.
It returns the number of bytes written and an error, if any.
WriteAt returns a non-nil error when n != len(b).
</p>

				
				
			
				
				<h3 id="File.WriteString">func (*File) <a href="src/pkg/os/file.htm#L179">WriteString</a></h3>
				<pre>func (f *File) WriteString(s string) (ret int, err error)</pre>
				<p>
WriteString is like Write, but writes the contents of string s rather than
an array of bytes.
</p>

				
				
			
		
			
			
			<h2 id="FileInfo">type <a href="src/pkg/os/types.htm#L6">FileInfo</a></h2>
			<pre>type FileInfo interface {
    Name() string       <span class="comment">// base name of the file</span>
    Size() int64        <span class="comment">// length in bytes for regular files; system-dependent for others</span>
    Mode() FileMode     <span class="comment">// file mode bits</span>
    ModTime() time.Time <span class="comment">// modification time</span>
    IsDir() bool        <span class="comment">// abbreviation for Mode().IsDir()</span>
    Sys() interface{}   <span class="comment">// underlying data source (can return nil)</span>
}</pre>
			<p>
A FileInfo describes a file and is returned by Stat and Lstat
</p>


			

			

			

			
				
				<h3 id="Lstat">func <a href="src/pkg/os/file_unix.htm#L122">Lstat</a></h3>
				<pre>func Lstat(name string) (fi FileInfo, err error)</pre>
				<p>
Lstat returns a FileInfo describing the named file.
If the file is a symbolic link, the returned FileInfo
describes the symbolic link.  Lstat makes no attempt to follow the link.
If there is an error, it will be of type *PathError.
</p>

				
			
				
				<h3 id="Stat">func <a href="src/pkg/os/file_unix.htm#L109">Stat</a></h3>
				<pre>func Stat(name string) (fi FileInfo, err error)</pre>
				<p>
Stat returns a FileInfo describing the named file.
If there is an error, it will be of type *PathError.
</p>

				
			

			
		
			
			
			<h2 id="FileMode">type <a href="src/pkg/os/types.htm#L20">FileMode</a></h2>
			<pre>type FileMode uint32</pre>
			<p>
A FileMode represents a file&#39;s mode and permission bits.
The bits have the same definition on all systems, so that
information about files can be moved from one system
to another portably.  Not all bits apply to all systems.
The only required bit is ModeDir for directories.
</p>


			
				<pre>const (
    <span class="comment">// The single letters are the abbreviations</span>
    <span class="comment">// used by the String method&#39;s formatting.</span>
    ModeDir        FileMode = 1 &lt;&lt; (32 - 1 - iota) <span class="comment">// d: is a directory</span>
    ModeAppend                                     <span class="comment">// a: append-only</span>
    ModeExclusive                                  <span class="comment">// l: exclusive use</span>
    ModeTemporary                                  <span class="comment">// T: temporary file (not backed up)</span>
    ModeSymlink                                    <span class="comment">// L: symbolic link</span>
    ModeDevice                                     <span class="comment">// D: device file</span>
    ModeNamedPipe                                  <span class="comment">// p: named pipe (FIFO)</span>
    ModeSocket                                     <span class="comment">// S: Unix domain socket</span>
    ModeSetuid                                     <span class="comment">// u: setuid</span>
    ModeSetgid                                     <span class="comment">// g: setgid</span>
    ModeCharDevice                                 <span class="comment">// c: Unix character device, when ModeDevice is set</span>
    ModeSticky

    <span class="comment">// Mask for the type bits. For regular files, none will be set.</span>
    ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice

    ModePerm FileMode = 0777 <span class="comment">// permission bits</span>
)</pre>
				<p>
The defined file mode bits are the most significant bits of the FileMode.
The nine least-significant bits are the standard Unix rwxrwxrwx permissions.
The values of these bits should be considered part of the public API and
may be used in wire protocols or disk representations: they must not be
changed, although new bits might be added.
</p>

			

			

			

			

			
				
				<h3 id="FileMode.IsDir">func (FileMode) <a href="src/pkg/os/types.htm#L77">IsDir</a></h3>
				<pre>func (m FileMode) IsDir() bool</pre>
				<p>
IsDir reports whether m describes a directory.
That is, it tests for the ModeDir bit being set in m.
</p>

				
				
			
				
				<h3 id="FileMode.Perm">func (FileMode) <a href="src/pkg/os/types.htm#L82">Perm</a></h3>
				<pre>func (m FileMode) Perm() FileMode</pre>
				<p>
Perm returns the Unix permission bits in m.
</p>

				
				
			
				
				<h3 id="FileMode.String">func (FileMode) <a href="src/pkg/os/types.htm#L49">String</a></h3>
				<pre>func (m FileMode) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="LinkError">type <a href="src/pkg/os/file.htm#L67">LinkError</a></h2>
			<pre>type LinkError struct {
    Op  string
    Old string
    New string
    Err error
}</pre>
			<p>
LinkError records an error during a link or symlink or rename
system call and the paths that caused it.
</p>


			

			

			

			

			
				
				<h3 id="LinkError.Error">func (*LinkError) <a href="src/pkg/os/file.htm#L74">Error</a></h3>
				<pre>func (e *LinkError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="PathError">type <a href="src/pkg/os/error.htm#L10">PathError</a></h2>
			<pre>type PathError struct {
    Op   string
    Path string
    Err  error
}</pre>
			<p>
PathError records an error and the operation and file path that caused it.
</p>


			

			

			

			

			
				
				<h3 id="PathError.Error">func (*PathError) <a href="src/pkg/os/error.htm#L16">Error</a></h3>
				<pre>func (e *PathError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="ProcAttr">type <a href="src/pkg/os/exec.htm#L17">ProcAttr</a></h2>
			<pre>type ProcAttr struct {
    <span class="comment">// If Dir is non-empty, the child changes into the directory before</span>
    <span class="comment">// creating the process.</span>
    Dir string
    <span class="comment">// If Env is non-nil, it gives the environment variables for the</span>
    <span class="comment">// new process in the form returned by Environ.</span>
    <span class="comment">// If it is nil, the result of Environ will be used.</span>
    Env []string
    <span class="comment">// Files specifies the open files inherited by the new process.  The</span>
    <span class="comment">// first three entries correspond to standard input, standard output, and</span>
    <span class="comment">// standard error.  An implementation may support additional entries,</span>
    <span class="comment">// depending on the underlying operating system.  A nil entry corresponds</span>
    <span class="comment">// to that file being closed when the process starts.</span>
    Files []*File

    <span class="comment">// Operating system-specific process creation attributes.</span>
    <span class="comment">// Note that setting this field means that your program</span>
    <span class="comment">// may not execute properly or even compile on some</span>
    <span class="comment">// operating systems.</span>
    Sys *syscall.SysProcAttr
}</pre>
			<p>
ProcAttr holds the attributes that will be applied to a new process
started by StartProcess.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Process">type <a href="src/pkg/os/exec.htm#L3">Process</a></h2>
			<pre>type Process struct {
    Pid int
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Process stores the information about a process created by StartProcess.
</p>


			

			

			

			
				
				<h3 id="FindProcess">func <a href="src/pkg/os/doc.htm#L2">FindProcess</a></h3>
				<pre>func FindProcess(pid int) (p *Process, err error)</pre>
				<p>
FindProcess looks for a running process by its pid.
The Process it returns can be used to obtain information
about the underlying operating system process.
</p>

				
			
				
				<h3 id="StartProcess">func <a href="src/pkg/os/doc.htm#L13">StartProcess</a></h3>
				<pre>func StartProcess(name string, argv []string, attr *ProcAttr) (*Process, error)</pre>
				<p>
StartProcess starts a new process with the program, arguments and attributes
specified by name, argv and attr.
</p>
<p>
StartProcess is a low-level interface. The os/exec package provides
higher-level interfaces.
</p>
<p>
If there is an error, it will be of type *PathError.
</p>

				
			

			
				
				<h3 id="Process.Kill">func (*Process) <a href="src/pkg/os/doc.htm#L25">Kill</a></h3>
				<pre>func (p *Process) Kill() error</pre>
				<p>
Kill causes the Process to exit immediately.
</p>

				
				
			
				
				<h3 id="Process.Release">func (*Process) <a href="src/pkg/os/doc.htm#L20">Release</a></h3>
				<pre>func (p *Process) Release() error</pre>
				<p>
Release releases any resources associated with the Process p,
rendering it unusable in the future.
Release only needs to be called if Wait is not.
</p>

				
				
			
				
				<h3 id="Process.Signal">func (*Process) <a href="src/pkg/os/doc.htm#L37">Signal</a></h3>
				<pre>func (p *Process) Signal(sig Signal) error</pre>
				<p>
Signal sends a signal to the Process.
</p>

				
				
			
				
				<h3 id="Process.Wait">func (*Process) <a href="src/pkg/os/doc.htm#L32">Wait</a></h3>
				<pre>func (p *Process) Wait() (*ProcessState, error)</pre>
				<p>
Wait waits for the Process to exit, and then returns a
ProcessState describing its status and an error, if any.
Wait releases any resources associated with the Process.
</p>

				
				
			
		
			
			
			<h2 id="ProcessState">type <a href="src/pkg/os/exec_posix.htm#L38">ProcessState</a></h2>
			<pre>type ProcessState struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
ProcessState stores information about a process, as reported by Wait.
</p>


			

			

			

			

			
				
				<h3 id="ProcessState.Exited">func (*ProcessState) <a href="src/pkg/os/doc.htm#L52">Exited</a></h3>
				<pre>func (p *ProcessState) Exited() bool</pre>
				<p>
Exited returns whether the program has exited.
</p>

				
				
			
				
				<h3 id="ProcessState.Pid">func (*ProcessState) <a href="src/pkg/os/exec_posix.htm#L45">Pid</a></h3>
				<pre>func (p *ProcessState) Pid() int</pre>
				<p>
Pid returns the process id of the exited process.
</p>

				
				
			
				
				<h3 id="ProcessState.String">func (*ProcessState) <a href="src/pkg/os/exec_posix.htm#L92">String</a></h3>
				<pre>func (p *ProcessState) String() string</pre>
				
				
				
			
				
				<h3 id="ProcessState.Success">func (*ProcessState) <a href="src/pkg/os/doc.htm#L58">Success</a></h3>
				<pre>func (p *ProcessState) Success() bool</pre>
				<p>
Success reports whether the program exited successfully,
such as with exit status 0 on Unix.
</p>

				
				
			
				
				<h3 id="ProcessState.Sys">func (*ProcessState) <a href="src/pkg/os/doc.htm#L65">Sys</a></h3>
				<pre>func (p *ProcessState) Sys() interface{}</pre>
				<p>
Sys returns system-dependent exit information about
the process.  Convert it to the appropriate underlying
type, such as syscall.WaitStatus on Unix, to access its contents.
</p>

				
				
			
				
				<h3 id="ProcessState.SysUsage">func (*ProcessState) <a href="src/pkg/os/doc.htm#L72">SysUsage</a></h3>
				<pre>func (p *ProcessState) SysUsage() interface{}</pre>
				<p>
SysUsage returns system-dependent resource usage information about
the exited process.  Convert it to the appropriate underlying
type, such as *syscall.Rusage on Unix, to access its contents.
</p>

				
				
			
				
				<h3 id="ProcessState.SystemTime">func (*ProcessState) <a href="src/pkg/os/doc.htm#L47">SystemTime</a></h3>
				<pre>func (p *ProcessState) SystemTime() time.Duration</pre>
				<p>
SystemTime returns the system CPU time of the exited process and its children.
</p>

				
				
			
				
				<h3 id="ProcessState.UserTime">func (*ProcessState) <a href="src/pkg/os/doc.htm#L42">UserTime</a></h3>
				<pre>func (p *ProcessState) UserTime() time.Duration</pre>
				<p>
UserTime returns the user CPU time of the exited process and its children.
</p>

				
				
			
		
			
			
			<h2 id="Signal">type <a href="src/pkg/os/exec.htm#L42">Signal</a></h2>
			<pre>type Signal interface {
    String() string
    Signal() <span class="comment">// to distinguish from other Stringers</span>
}</pre>
			<p>
A Signal represents an operating system signal.
The usual underlying implementation is operating system-dependent:
on Unix it is syscall.Signal.
</p>


			

			
				<pre>var (
    Interrupt Signal = syscall.SIGINT
    Kill      Signal = syscall.SIGKILL
)</pre>
				<p>
The only signal values guaranteed to be present on all systems
are Interrupt (send the process an interrupt) and
Kill (force the process to exit).
</p>

			

			

			

			
		
			
			
			<h2 id="SyscallError">type <a href="src/pkg/os/error.htm#L19">SyscallError</a></h2>
			<pre>type SyscallError struct {
    Syscall string
    Err     error
}</pre>
			<p>
SyscallError records an error from a specific system call.
</p>


			

			

			

			

			
				
				<h3 id="SyscallError.Error">func (*SyscallError) <a href="src/pkg/os/error.htm#L24">Error</a></h3>
				<pre>func (e *SyscallError) Error() string</pre>
				
				
				
			
		
		</div>
	

	







	
	
		<h2 id="subdirectories">Subdirectories</h2>
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
			<tr>
			<td class="name"><a href="os_exec.htm">exec</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package exec runs external commands.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="os_signal.htm">signal</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package signal implements access to incoming signals.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="os_user.htm">user</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package user allows user account lookups by name or id.</td>
			</tr>
		
	
	</table>
	



</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
