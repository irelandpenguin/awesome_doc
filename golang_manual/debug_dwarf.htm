
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>dwarf - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>


<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package dwarf</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "debug/dwarf"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package dwarf provides access to DWARF debugging information loaded from
executable files, as defined in the DWARF 2.0 Standard at
<a href="http://dwarfstd.org/doc/dwarf-2.0.0.pdf">http://dwarfstd.org/doc/dwarf-2.0.0.pdf</a>
</p>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
			
			
				
				<dd><a href="#AddrType">type AddrType</a></dd>
				
				
			
				
				<dd><a href="#ArrayType">type ArrayType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ArrayType.Size">func (t *ArrayType) Size() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ArrayType.String">func (t *ArrayType) String() string</a></dd>
				
			
				
				<dd><a href="#Attr">type Attr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Attr.GoString">func (a Attr) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Attr.String">func (a Attr) String() string</a></dd>
				
			
				
				<dd><a href="#BasicType">type BasicType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BasicType.Basic">func (b *BasicType) Basic() *BasicType</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BasicType.String">func (t *BasicType) String() string</a></dd>
				
			
				
				<dd><a href="#BoolType">type BoolType</a></dd>
				
				
			
				
				<dd><a href="#CharType">type CharType</a></dd>
				
				
			
				
				<dd><a href="#CommonType">type CommonType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CommonType.Common">func (c *CommonType) Common() *CommonType</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CommonType.Size">func (c *CommonType) Size() int64</a></dd>
				
			
				
				<dd><a href="#ComplexType">type ComplexType</a></dd>
				
				
			
				
				<dd><a href="#Data">type Data</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#New">func New(abbrev, aranges, frame, info, line, pubnames, ranges, str []byte) (*Data, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Data.Reader">func (d *Data) Reader() *Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Data.Type">func (d *Data) Type(off Offset) (Type, error)</a></dd>
				
			
				
				<dd><a href="#DecodeError">type DecodeError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DecodeError.Error">func (e DecodeError) Error() string</a></dd>
				
			
				
				<dd><a href="#DotDotDotType">type DotDotDotType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DotDotDotType.String">func (t *DotDotDotType) String() string</a></dd>
				
			
				
				<dd><a href="#Entry">type Entry</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Entry.Val">func (e *Entry) Val(a Attr) interface{}</a></dd>
				
			
				
				<dd><a href="#EnumType">type EnumType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EnumType.String">func (t *EnumType) String() string</a></dd>
				
			
				
				<dd><a href="#EnumValue">type EnumValue</a></dd>
				
				
			
				
				<dd><a href="#Field">type Field</a></dd>
				
				
			
				
				<dd><a href="#FloatType">type FloatType</a></dd>
				
				
			
				
				<dd><a href="#FuncType">type FuncType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FuncType.String">func (t *FuncType) String() string</a></dd>
				
			
				
				<dd><a href="#IntType">type IntType</a></dd>
				
				
			
				
				<dd><a href="#Offset">type Offset</a></dd>
				
				
			
				
				<dd><a href="#PtrType">type PtrType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PtrType.String">func (t *PtrType) String() string</a></dd>
				
			
				
				<dd><a href="#QualType">type QualType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#QualType.Size">func (t *QualType) Size() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#QualType.String">func (t *QualType) String() string</a></dd>
				
			
				
				<dd><a href="#Reader">type Reader</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Next">func (r *Reader) Next() (*Entry, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Seek">func (r *Reader) Seek(off Offset)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.SkipChildren">func (r *Reader) SkipChildren()</a></dd>
				
			
				
				<dd><a href="#StructField">type StructField</a></dd>
				
				
			
				
				<dd><a href="#StructType">type StructType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#StructType.Defn">func (t *StructType) Defn() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StructType.String">func (t *StructType) String() string</a></dd>
				
			
				
				<dd><a href="#Tag">type Tag</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Tag.GoString">func (t Tag) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Tag.String">func (t Tag) String() string</a></dd>
				
			
				
				<dd><a href="#Type">type Type</a></dd>
				
				
			
				
				<dd><a href="#TypedefType">type TypedefType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TypedefType.Size">func (t *TypedefType) Size() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypedefType.String">func (t *TypedefType) String() string</a></dd>
				
			
				
				<dd><a href="#UcharType">type UcharType</a></dd>
				
				
			
				
				<dd><a href="#UintType">type UintType</a></dd>
				
				
			
				
				<dd><a href="#VoidType">type VoidType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#VoidType.String">func (t *VoidType) String() string</a></dd>
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/debug/dwarf/buf.htm">buf.go</a>
			
				<a href="src/pkg/debug/dwarf/const.htm">const.go</a>
			
				<a href="src/pkg/debug/dwarf/entry.htm">entry.go</a>
			
				<a href="src/pkg/debug/dwarf/open.htm">open.go</a>
			
				<a href="src/pkg/debug/dwarf/type.htm">type.go</a>
			
				<a href="src/pkg/debug/dwarf/unit.htm">unit.go</a>
			
			</span>
			</p>
		
	
		
		
		
		
			
			
			<h2 id="AddrType">type <a href="src/pkg/debug/dwarf/type.htm#L77">AddrType</a></h2>
			<pre>type AddrType struct {
    BasicType
}</pre>
			<p>
An AddrType represents a machine address type.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ArrayType">type <a href="src/pkg/debug/dwarf/type.htm#L95">ArrayType</a></h2>
			<pre>type ArrayType struct {
    CommonType
    Type          Type
    StrideBitSize int64 <span class="comment">// if &gt; 0, number of bits to hold each element</span>
    Count         int64 <span class="comment">// if == -1, an incomplete array, like char x[].</span>
}</pre>
			<p>
An ArrayType represents a fixed size array type.
</p>


			

			

			

			

			
				
				<h3 id="ArrayType.Size">func (*ArrayType) <a href="src/pkg/debug/dwarf/type.htm#L106">Size</a></h3>
				<pre>func (t *ArrayType) Size() int64</pre>
				
				
				
			
				
				<h3 id="ArrayType.String">func (*ArrayType) <a href="src/pkg/debug/dwarf/type.htm#L102">String</a></h3>
				<pre>func (t *ArrayType) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Attr">type <a href="src/pkg/debug/dwarf/const.htm#L2">Attr</a></h2>
			<pre>type Attr uint32</pre>
			<p>
An Attr identifies the attribute type in a DWARF Entry&#39;s Field.
</p>


			
				<pre>const (
    AttrSibling        Attr = 0x01
    AttrLocation       Attr = 0x02
    AttrName           Attr = 0x03
    AttrOrdering       Attr = 0x09
    AttrByteSize       Attr = 0x0B
    AttrBitOffset      Attr = 0x0C
    AttrBitSize        Attr = 0x0D
    AttrStmtList       Attr = 0x10
    AttrLowpc          Attr = 0x11
    AttrHighpc         Attr = 0x12
    AttrLanguage       Attr = 0x13
    AttrDiscr          Attr = 0x15
    AttrDiscrValue     Attr = 0x16
    AttrVisibility     Attr = 0x17
    AttrImport         Attr = 0x18
    AttrStringLength   Attr = 0x19
    AttrCommonRef      Attr = 0x1A
    AttrCompDir        Attr = 0x1B
    AttrConstValue     Attr = 0x1C
    AttrContainingType Attr = 0x1D
    AttrDefaultValue   Attr = 0x1E
    AttrInline         Attr = 0x20
    AttrIsOptional     Attr = 0x21
    AttrLowerBound     Attr = 0x22
    AttrProducer       Attr = 0x25
    AttrPrototyped     Attr = 0x27
    AttrReturnAddr     Attr = 0x2A
    AttrStartScope     Attr = 0x2C
    AttrStrideSize     Attr = 0x2E
    AttrUpperBound     Attr = 0x2F
    AttrAbstractOrigin Attr = 0x31
    AttrAccessibility  Attr = 0x32
    AttrAddrClass      Attr = 0x33
    AttrArtificial     Attr = 0x34
    AttrBaseTypes      Attr = 0x35
    AttrCalling        Attr = 0x36
    AttrCount          Attr = 0x37
    AttrDataMemberLoc  Attr = 0x38
    AttrDeclColumn     Attr = 0x39
    AttrDeclFile       Attr = 0x3A
    AttrDeclLine       Attr = 0x3B
    AttrDeclaration    Attr = 0x3C
    AttrDiscrList      Attr = 0x3D
    AttrEncoding       Attr = 0x3E
    AttrExternal       Attr = 0x3F
    AttrFrameBase      Attr = 0x40
    AttrFriend         Attr = 0x41
    AttrIdentifierCase Attr = 0x42
    AttrMacroInfo      Attr = 0x43
    AttrNamelistItem   Attr = 0x44
    AttrPriority       Attr = 0x45
    AttrSegment        Attr = 0x46
    AttrSpecification  Attr = 0x47
    AttrStaticLink     Attr = 0x48
    AttrType           Attr = 0x49
    AttrUseLocation    Attr = 0x4A
    AttrVarParam       Attr = 0x4B
    AttrVirtuality     Attr = 0x4C
    AttrVtableElemLoc  Attr = 0x4D
    AttrAllocated      Attr = 0x4E
    AttrAssociated     Attr = 0x4F
    AttrDataLocation   Attr = 0x50
    AttrStride         Attr = 0x51
    AttrEntrypc        Attr = 0x52
    AttrUseUTF8        Attr = 0x53
    AttrExtension      Attr = 0x54
    AttrRanges         Attr = 0x55
    AttrTrampoline     Attr = 0x56
    AttrCallColumn     Attr = 0x57
    AttrCallFile       Attr = 0x58
    AttrCallLine       Attr = 0x59
    AttrDescription    Attr = 0x5A
)</pre>
				
			

			

			

			

			
				
				<h3 id="Attr.GoString">func (Attr) <a href="src/pkg/debug/dwarf/const.htm#L164">GoString</a></h3>
				<pre>func (a Attr) GoString() string</pre>
				
				
				
			
				
				<h3 id="Attr.String">func (Attr) <a href="src/pkg/debug/dwarf/const.htm#L154">String</a></h3>
				<pre>func (a Attr) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="BasicType">type <a href="src/pkg/debug/dwarf/type.htm#L26">BasicType</a></h2>
			<pre>type BasicType struct {
    CommonType
    BitSize   int64
    BitOffset int64
}</pre>
			<p>
A BasicType holds fields common to all basic types.
</p>


			

			

			

			

			
				
				<h3 id="BasicType.Basic">func (*BasicType) <a href="src/pkg/debug/dwarf/type.htm#L32">Basic</a></h3>
				<pre>func (b *BasicType) Basic() *BasicType</pre>
				
				
				
			
				
				<h3 id="BasicType.String">func (*BasicType) <a href="src/pkg/debug/dwarf/type.htm#L34">String</a></h3>
				<pre>func (t *BasicType) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="BoolType">type <a href="src/pkg/debug/dwarf/type.htm#L72">BoolType</a></h2>
			<pre>type BoolType struct {
    BasicType
}</pre>
			<p>
A BoolType represents a boolean type.
</p>


			

			

			

			

			
		
			
			
			<h2 id="CharType">type <a href="src/pkg/debug/dwarf/type.htm#L42">CharType</a></h2>
			<pre>type CharType struct {
    BasicType
}</pre>
			<p>
A CharType represents a signed character type.
</p>


			

			

			

			

			
		
			
			
			<h2 id="CommonType">type <a href="src/pkg/debug/dwarf/type.htm#L14">CommonType</a></h2>
			<pre>type CommonType struct {
    ByteSize int64  <span class="comment">// size of value of this type, in bytes</span>
    Name     string <span class="comment">// name that can be used to refer to type</span>
}</pre>
			<p>
A CommonType holds fields common to multiple types.
If a field is not known or not applicable for a given type,
the zero value is used.
</p>


			

			

			

			

			
				
				<h3 id="CommonType.Common">func (*CommonType) <a href="src/pkg/debug/dwarf/type.htm#L19">Common</a></h3>
				<pre>func (c *CommonType) Common() *CommonType</pre>
				
				
				
			
				
				<h3 id="CommonType.Size">func (*CommonType) <a href="src/pkg/debug/dwarf/type.htm#L21">Size</a></h3>
				<pre>func (c *CommonType) Size() int64</pre>
				
				
				
			
		
			
			
			<h2 id="ComplexType">type <a href="src/pkg/debug/dwarf/type.htm#L67">ComplexType</a></h2>
			<pre>type ComplexType struct {
    BasicType
}</pre>
			<p>
A ComplexType represents a complex floating point type.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Data">type <a href="src/pkg/debug/dwarf/open.htm#L4">Data</a></h2>
			<pre>type Data struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Data represents the DWARF debugging information
loaded from an executable file (for example, an ELF or Mach-O executable).
</p>


			

			

			

			
				
				<h3 id="New">func <a href="src/pkg/debug/dwarf/open.htm#L31">New</a></h3>
				<pre>func New(abbrev, aranges, frame, info, line, pubnames, ranges, str []byte) (*Data, error)</pre>
				<p>
New returns a new Data object initialized from the given parameters.
Rather than calling this function directly, clients should typically use
the DWARF method of the File type of the appropriate package debug/elf,
debug/macho, or debug/pe.
</p>
<p>
The []byte arguments are the data from the corresponding debug section
in the object file; for example, for an ELF object, abbrev is the contents of
the &#34;.debug_abbrev&#34; section.
</p>

				
			

			
				
				<h3 id="Data.Reader">func (*Data) <a href="src/pkg/debug/dwarf/entry.htm#L233">Reader</a></h3>
				<pre>func (d *Data) Reader() *Reader</pre>
				<p>
Reader returns a new Reader for Data.
The reader is positioned at byte offset 0 in the DWARF &ldquo;info&rdquo; section.
</p>

				
				
			
				
				<h3 id="Data.Type">func (*Data) <a href="src/pkg/debug/dwarf/type.htm#L244">Type</a></h3>
				<pre>func (d *Data) Type(off Offset) (Type, error)</pre>
				
				
				
			
		
			
			
			<h2 id="DecodeError">type <a href="src/pkg/debug/dwarf/buf.htm#L135">DecodeError</a></h2>
			<pre>type DecodeError struct {
    Name   string
    Offset Offset
    Err    string
}</pre>
			

			

			

			

			

			
				
				<h3 id="DecodeError.Error">func (DecodeError) <a href="src/pkg/debug/dwarf/buf.htm#L141">Error</a></h3>
				<pre>func (e DecodeError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="DotDotDotType">type <a href="src/pkg/debug/dwarf/type.htm#L228">DotDotDotType</a></h2>
			<pre>type DotDotDotType struct {
    CommonType
}</pre>
			<p>
A DotDotDotType represents the variadic ... function parameter.
</p>


			

			

			

			

			
				
				<h3 id="DotDotDotType.String">func (*DotDotDotType) <a href="src/pkg/debug/dwarf/type.htm#L232">String</a></h3>
				<pre>func (t *DotDotDotType) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Entry">type <a href="src/pkg/debug/dwarf/entry.htm#L84">Entry</a></h2>
			<pre>type Entry struct {
    Offset   Offset <span class="comment">// offset of Entry in DWARF info</span>
    Tag      Tag    <span class="comment">// tag (kind of Entry)</span>
    Children bool   <span class="comment">// whether Entry is followed by children</span>
    Field    []Field
}</pre>
			<p>
An entry is a sequence of attribute/value pairs.
</p>


			

			

			

			

			
				
				<h3 id="Entry.Val">func (*Entry) <a href="src/pkg/debug/dwarf/entry.htm#L104">Val</a></h3>
				<pre>func (e *Entry) Val(a Attr) interface{}</pre>
				<p>
Val returns the value associated with attribute Attr in Entry,
or nil if there is no such attribute.
</p>
<p>
A common idiom is to merge the check for nil return with
the check that the value has the expected dynamic type, as in:
</p>
<pre>v, ok := e.Val(AttrSibling).(int64);
</pre>

				
				
			
		
			
			
			<h2 id="EnumType">type <a href="src/pkg/debug/dwarf/type.htm#L177">EnumType</a></h2>
			<pre>type EnumType struct {
    CommonType
    EnumName string
    Val      []*EnumValue
}</pre>
			<p>
An EnumType represents an enumerated type.
The only indication of its native integer type is its ByteSize
(inside CommonType).
</p>


			

			

			

			

			
				
				<h3 id="EnumType.String">func (*EnumType) <a href="src/pkg/debug/dwarf/type.htm#L189">String</a></h3>
				<pre>func (t *EnumType) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="EnumValue">type <a href="src/pkg/debug/dwarf/type.htm#L184">EnumValue</a></h2>
			<pre>type EnumValue struct {
    Name string
    Val  int64
}</pre>
			<p>
An EnumValue represents a single enumeration value.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Field">type <a href="src/pkg/debug/dwarf/entry.htm#L92">Field</a></h2>
			<pre>type Field struct {
    Attr Attr
    Val  interface{}
}</pre>
			<p>
A Field is a single attribute/value pair in an Entry.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FloatType">type <a href="src/pkg/debug/dwarf/type.htm#L62">FloatType</a></h2>
			<pre>type FloatType struct {
    BasicType
}</pre>
			<p>
A FloatType represents a floating point type.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FuncType">type <a href="src/pkg/debug/dwarf/type.htm#L206">FuncType</a></h2>
			<pre>type FuncType struct {
    CommonType
    ReturnType Type
    ParamType  []Type
}</pre>
			<p>
A FuncType represents a function type.
</p>


			

			

			

			

			
				
				<h3 id="FuncType.String">func (*FuncType) <a href="src/pkg/debug/dwarf/type.htm#L212">String</a></h3>
				<pre>func (t *FuncType) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="IntType">type <a href="src/pkg/debug/dwarf/type.htm#L52">IntType</a></h2>
			<pre>type IntType struct {
    BasicType
}</pre>
			<p>
An IntType represents a signed integer type.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Offset">type <a href="src/pkg/debug/dwarf/entry.htm#L115">Offset</a></h2>
			<pre>type Offset uint32</pre>
			<p>
An Offset represents the location of an Entry within the DWARF info.
(See Reader.Seek.)
</p>


			

			

			

			

			
		
			
			
			<h2 id="PtrType">type <a href="src/pkg/debug/dwarf/type.htm#L116">PtrType</a></h2>
			<pre>type PtrType struct {
    CommonType
    Type Type
}</pre>
			<p>
A PtrType represents a pointer type.
</p>


			

			

			

			

			
				
				<h3 id="PtrType.String">func (*PtrType) <a href="src/pkg/debug/dwarf/type.htm#L121">String</a></h3>
				<pre>func (t *PtrType) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="QualType">type <a href="src/pkg/debug/dwarf/type.htm#L84">QualType</a></h2>
			<pre>type QualType struct {
    CommonType
    Qual string
    Type Type
}</pre>
			<p>
A QualType represents a type that has the C/C++ &#34;const&#34;, &#34;restrict&#34;, or &#34;volatile&#34; qualifier.
</p>


			

			

			

			

			
				
				<h3 id="QualType.Size">func (*QualType) <a href="src/pkg/debug/dwarf/type.htm#L92">Size</a></h3>
				<pre>func (t *QualType) Size() int64</pre>
				
				
				
			
				
				<h3 id="QualType.String">func (*QualType) <a href="src/pkg/debug/dwarf/type.htm#L90">String</a></h3>
				<pre>func (t *QualType) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Reader">type <a href="src/pkg/debug/dwarf/entry.htm#L222">Reader</a></h2>
			<pre>type Reader struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Reader allows reading Entry structures from a DWARF &ldquo;info&rdquo; section.
The Entry structures are arranged in a tree.  The Reader&#39;s Next function
return successive entries from a pre-order traversal of the tree.
If an entry has children, its Children field will be true, and the children
follow, terminated by an Entry with Tag 0.
</p>


			

			

			

			

			
				
				<h3 id="Reader.Next">func (*Reader) <a href="src/pkg/debug/dwarf/entry.htm#L282">Next</a></h3>
				<pre>func (r *Reader) Next() (*Entry, error)</pre>
				<p>
Next reads the next entry from the encoded entry stream.
It returns nil, nil when it reaches the end of the section.
It returns an error if the current offset is invalid or the data at the
offset cannot be decoded as a valid Entry.
</p>

				
				
			
				
				<h3 id="Reader.Seek">func (*Reader) <a href="src/pkg/debug/dwarf/entry.htm#L241">Seek</a></h3>
				<pre>func (r *Reader) Seek(off Offset)</pre>
				<p>
Seek positions the Reader at offset off in the encoded entry stream.
Offset 0 can be used to denote the first entry.
</p>

				
				
			
				
				<h3 id="Reader.SkipChildren">func (*Reader) <a href="src/pkg/debug/dwarf/entry.htm#L310">SkipChildren</a></h3>
				<pre>func (r *Reader) SkipChildren()</pre>
				<p>
SkipChildren skips over the child entries associated with
the last Entry returned by Next.  If that Entry did not have
children or Next has not been called, SkipChildren is a no-op.
</p>

				
				
			
		
			
			
			<h2 id="StructField">type <a href="src/pkg/debug/dwarf/type.htm#L133">StructField</a></h2>
			<pre>type StructField struct {
    Name       string
    Type       Type
    ByteOffset int64
    ByteSize   int64
    BitOffset  int64 <span class="comment">// within the ByteSize bytes at ByteOffset</span>
    BitSize    int64 <span class="comment">// zero if not a bit field</span>
}</pre>
			<p>
A StructField represents a field in a struct, union, or C++ class type.
</p>


			

			

			

			

			
		
			
			
			<h2 id="StructType">type <a href="src/pkg/debug/dwarf/type.htm#L124">StructType</a></h2>
			<pre>type StructType struct {
    CommonType
    StructName string
    Kind       string <span class="comment">// &#34;struct&#34;, &#34;union&#34;, or &#34;class&#34;.</span>
    Field      []*StructField
    Incomplete bool <span class="comment">// if true, struct, union, class is declared but not defined</span>
}</pre>
			<p>
A StructType represents a struct, union, or C++ class type.
</p>


			

			

			

			

			
				
				<h3 id="StructType.Defn">func (*StructType) <a href="src/pkg/debug/dwarf/type.htm#L149">Defn</a></h3>
				<pre>func (t *StructType) Defn() string</pre>
				
				
				
			
				
				<h3 id="StructType.String">func (*StructType) <a href="src/pkg/debug/dwarf/type.htm#L142">String</a></h3>
				<pre>func (t *StructType) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Tag">type <a href="src/pkg/debug/dwarf/const.htm#L203">Tag</a></h2>
			<pre>type Tag uint32</pre>
			<p>
A Tag is the classification (the type) of an Entry.
</p>


			
				<pre>const (
    TagArrayType              Tag = 0x01
    TagClassType              Tag = 0x02
    TagEntryPoint             Tag = 0x03
    TagEnumerationType        Tag = 0x04
    TagFormalParameter        Tag = 0x05
    TagImportedDeclaration    Tag = 0x08
    TagLabel                  Tag = 0x0A
    TagLexDwarfBlock          Tag = 0x0B
    TagMember                 Tag = 0x0D
    TagPointerType            Tag = 0x0F
    TagReferenceType          Tag = 0x10
    TagCompileUnit            Tag = 0x11
    TagStringType             Tag = 0x12
    TagStructType             Tag = 0x13
    TagSubroutineType         Tag = 0x15
    TagTypedef                Tag = 0x16
    TagUnionType              Tag = 0x17
    TagUnspecifiedParameters  Tag = 0x18
    TagVariant                Tag = 0x19
    TagCommonDwarfBlock       Tag = 0x1A
    TagCommonInclusion        Tag = 0x1B
    TagInheritance            Tag = 0x1C
    TagInlinedSubroutine      Tag = 0x1D
    TagModule                 Tag = 0x1E
    TagPtrToMemberType        Tag = 0x1F
    TagSetType                Tag = 0x20
    TagSubrangeType           Tag = 0x21
    TagWithStmt               Tag = 0x22
    TagAccessDeclaration      Tag = 0x23
    TagBaseType               Tag = 0x24
    TagCatchDwarfBlock        Tag = 0x25
    TagConstType              Tag = 0x26
    TagConstant               Tag = 0x27
    TagEnumerator             Tag = 0x28
    TagFileType               Tag = 0x29
    TagFriend                 Tag = 0x2A
    TagNamelist               Tag = 0x2B
    TagNamelistItem           Tag = 0x2C
    TagPackedType             Tag = 0x2D
    TagSubprogram             Tag = 0x2E
    TagTemplateTypeParameter  Tag = 0x2F
    TagTemplateValueParameter Tag = 0x30
    TagThrownType             Tag = 0x31
    TagTryDwarfBlock          Tag = 0x32
    TagVariantPart            Tag = 0x33
    TagVariable               Tag = 0x34
    TagVolatileType           Tag = 0x35
    TagDwarfProcedure         Tag = 0x36
    TagRestrictType           Tag = 0x37
    TagInterfaceType          Tag = 0x38
    TagNamespace              Tag = 0x39
    TagImportedModule         Tag = 0x3A
    TagUnspecifiedType        Tag = 0x3B
    TagPartialUnit            Tag = 0x3C
    TagImportedUnit           Tag = 0x3D
    TagMutableType            Tag = 0x3E
)</pre>
				
			

			

			

			

			
				
				<h3 id="Tag.GoString">func (Tag) <a href="src/pkg/debug/dwarf/const.htm#L333">GoString</a></h3>
				<pre>func (t Tag) GoString() string</pre>
				
				
				
			
				
				<h3 id="Tag.String">func (Tag) <a href="src/pkg/debug/dwarf/const.htm#L323">String</a></h3>
				<pre>func (t Tag) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Type">type <a href="src/pkg/debug/dwarf/type.htm#L5">Type</a></h2>
			<pre>type Type interface {
    Common() *CommonType
    String() string
    Size() int64
}</pre>
			<p>
A Type conventionally represents a pointer to any of the
specific Type structures (CharType, StructType, etc.).
</p>


			

			

			

			

			
		
			
			
			<h2 id="TypedefType">type <a href="src/pkg/debug/dwarf/type.htm#L235">TypedefType</a></h2>
			<pre>type TypedefType struct {
    CommonType
    Type Type
}</pre>
			<p>
A TypedefType represents a named type.
</p>


			

			

			

			

			
				
				<h3 id="TypedefType.Size">func (*TypedefType) <a href="src/pkg/debug/dwarf/type.htm#L242">Size</a></h3>
				<pre>func (t *TypedefType) Size() int64</pre>
				
				
				
			
				
				<h3 id="TypedefType.String">func (*TypedefType) <a href="src/pkg/debug/dwarf/type.htm#L240">String</a></h3>
				<pre>func (t *TypedefType) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="UcharType">type <a href="src/pkg/debug/dwarf/type.htm#L47">UcharType</a></h2>
			<pre>type UcharType struct {
    BasicType
}</pre>
			<p>
A UcharType represents an unsigned character type.
</p>


			

			

			

			

			
		
			
			
			<h2 id="UintType">type <a href="src/pkg/debug/dwarf/type.htm#L57">UintType</a></h2>
			<pre>type UintType struct {
    BasicType
}</pre>
			<p>
A UintType represents an unsigned integer type.
</p>


			

			

			

			

			
		
			
			
			<h2 id="VoidType">type <a href="src/pkg/debug/dwarf/type.htm#L109">VoidType</a></h2>
			<pre>type VoidType struct {
    CommonType
}</pre>
			<p>
A VoidType represents the C void type.
</p>


			

			

			

			

			
				
				<h3 id="VoidType.String">func (*VoidType) <a href="src/pkg/debug/dwarf/type.htm#L113">String</a></h3>
				<pre>func (t *VoidType) String() string</pre>
				
				
				
			
		
		</div>
	

	









</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
