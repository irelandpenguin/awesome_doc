
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>time - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package time</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "time"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
				<dd><a href="#examples">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package time provides functionality for measuring and displaying time.
</p>
<p>
The calendrical calculations always assume a Gregorian calendar.
</p>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
				<dd><a href="#constants">Constants</a></dd>
			
			
			
				
				<dd><a href="#After">func After(d Duration) &lt;-chan Time</a></dd>
			
				
				<dd><a href="#Sleep">func Sleep(d Duration)</a></dd>
			
				
				<dd><a href="#Tick">func Tick(d Duration) &lt;-chan Time</a></dd>
			
			
				
				<dd><a href="#Duration">type Duration</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseDuration">func ParseDuration(s string) (Duration, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Since">func Since(t Time) Duration</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Duration.Hours">func (d Duration) Hours() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Duration.Minutes">func (d Duration) Minutes() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Duration.Nanoseconds">func (d Duration) Nanoseconds() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Duration.Seconds">func (d Duration) Seconds() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Duration.String">func (d Duration) String() string</a></dd>
				
			
				
				<dd><a href="#Location">type Location</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FixedZone">func FixedZone(name string, offset int) *Location</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LoadLocation">func LoadLocation(name string) (*Location, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Location.String">func (l *Location) String() string</a></dd>
				
			
				
				<dd><a href="#Month">type Month</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Month.String">func (m Month) String() string</a></dd>
				
			
				
				<dd><a href="#ParseError">type ParseError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseError.Error">func (e *ParseError) Error() string</a></dd>
				
			
				
				<dd><a href="#Ticker">type Ticker</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewTicker">func NewTicker(d Duration) *Ticker</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Ticker.Stop">func (t *Ticker) Stop()</a></dd>
				
			
				
				<dd><a href="#Time">type Time</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Date">func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Now">func Now() Time</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Parse">func Parse(layout, value string) (Time, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Unix">func Unix(sec int64, nsec int64) Time</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Add">func (t Time) Add(d Duration) Time</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.AddDate">func (t Time) AddDate(years int, months int, days int) Time</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.After">func (t Time) After(u Time) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Before">func (t Time) Before(u Time) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Clock">func (t Time) Clock() (hour, min, sec int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Date">func (t Time) Date() (year int, month Month, day int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Day">func (t Time) Day() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Equal">func (t Time) Equal(u Time) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Format">func (t Time) Format(layout string) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.GobDecode">func (t *Time) GobDecode(buf []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.GobEncode">func (t Time) GobEncode() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Hour">func (t Time) Hour() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.ISOWeek">func (t Time) ISOWeek() (year, week int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.In">func (t Time) In(loc *Location) Time</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.IsZero">func (t Time) IsZero() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Local">func (t Time) Local() Time</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Location">func (t Time) Location() *Location</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.MarshalJSON">func (t Time) MarshalJSON() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Minute">func (t Time) Minute() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Month">func (t Time) Month() Month</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Nanosecond">func (t Time) Nanosecond() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Second">func (t Time) Second() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.String">func (t Time) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Sub">func (t Time) Sub(u Time) Duration</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.UTC">func (t Time) UTC() Time</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Unix">func (t Time) Unix() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.UnixNano">func (t Time) UnixNano() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.UnmarshalJSON">func (t *Time) UnmarshalJSON(data []byte) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Weekday">func (t Time) Weekday() Weekday</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Year">func (t Time) Year() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Time.Zone">func (t Time) Zone() (name string, offset int)</a></dd>
				
			
				
				<dd><a href="#Timer">type Timer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AfterFunc">func AfterFunc(d Duration, f func()) *Timer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewTimer">func NewTimer(d Duration) *Timer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Timer.Stop">func (t *Timer) Stop() (ok bool)</a></dd>
				
			
				
				<dd><a href="#Weekday">type Weekday</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Weekday.String">func (d Weekday) String() string</a></dd>
				
			
			
		</dl>

		
			<h4 id="examples">Examples</h4>
			<dl>
			
			<dd><a class="exampleLink" href="#example_After">After</a></dd>
			
			<dd><a class="exampleLink" href="#example_Date">Date</a></dd>
			
			<dd><a class="exampleLink" href="#example_Duration">Duration</a></dd>
			
			<dd><a class="exampleLink" href="#example_Month">Month</a></dd>
			
			<dd><a class="exampleLink" href="#example_Sleep">Sleep</a></dd>
			
			<dd><a class="exampleLink" href="#example_Tick">Tick</a></dd>
			
			</dl>
		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/time/format.htm">format.go</a>
			
				<a href="src/pkg/time/sleep.htm">sleep.go</a>
			
				<a href="src/pkg/time/sys_unix.htm">sys_unix.go</a>
			
				<a href="src/pkg/time/tick.htm">tick.go</a>
			
				<a href="src/pkg/time/time.htm">time.go</a>
			
				<a href="src/pkg/time/zoneinfo.htm">zoneinfo.go</a>
			
				<a href="src/pkg/time/zoneinfo_read.htm">zoneinfo_read.go</a>
			
				<a href="src/pkg/time/zoneinfo_unix.htm">zoneinfo_unix.go</a>
			
			</span>
			</p>
		
	
		
			<h2 id="constants">Constants</h2>
			
				<pre>const (
    ANSIC       = &#34;Mon Jan _2 15:04:05 2006&#34;
    UnixDate    = &#34;Mon Jan _2 15:04:05 MST 2006&#34;
    RubyDate    = &#34;Mon Jan 02 15:04:05 -0700 2006&#34;
    RFC822      = &#34;02 Jan 06 15:04 MST&#34;
    RFC822Z     = &#34;02 Jan 06 15:04 -0700&#34; <span class="comment">// RFC822 with numeric zone</span>
    RFC850      = &#34;Monday, 02-Jan-06 15:04:05 MST&#34;
    RFC1123     = &#34;Mon, 02 Jan 2006 15:04:05 MST&#34;
    RFC1123Z    = &#34;Mon, 02 Jan 2006 15:04:05 -0700&#34; <span class="comment">// RFC1123 with numeric zone</span>
    RFC3339     = &#34;2006-01-02T15:04:05Z07:00&#34;
    RFC3339Nano = &#34;2006-01-02T15:04:05.999999999Z07:00&#34;
    Kitchen     = &#34;3:04PM&#34;
    <span class="comment">// Handy time stamps.</span>
    Stamp      = &#34;Jan _2 15:04:05&#34;
    StampMilli = &#34;Jan _2 15:04:05.000&#34;
    StampMicro = &#34;Jan _2 15:04:05.000000&#34;
    StampNano  = &#34;Jan _2 15:04:05.000000000&#34;
)</pre>
				<p>
These are predefined layouts for use in Time.Format.
The standard time used in the layouts is:
</p>
<pre>Mon Jan 2 15:04:05 MST 2006
</pre>
<p>
which is Unix time 1136243045. Since MST is GMT-0700,
the standard time can be thought of as
</p>
<pre>01/02 03:04:05PM &#39;06 -0700
</pre>
<p>
To define your own format, write down what the standard time would look
like formatted your way; see the values of constants like ANSIC,
StampMicro or Kitchen for examples.
</p>
<p>
Within the format string, an underscore _ represents a space that may be
replaced by a digit if the following number (a day) has two digits; for
compatibility with fixed-width Unix time formats.
</p>
<p>
A decimal point followed by one or more zeros represents a fractional
second, printed to the given number of decimal places.  A decimal point
followed by one or more nines represents a fractional second, printed to
the given number of decimal places, with trailing zeros removed.
When parsing (only), the input may contain a fractional second
field immediately after the seconds field, even if the layout does not
signify its presence. In that case a decimal point followed by a maximal
series of digits is parsed as a fractional second.
</p>
<p>
Numeric time zone offsets format as follows:
</p>
<pre>-0700  hhmm
-07:00 hh:mm
</pre>
<p>
Replacing the sign in the format with a Z triggers
the ISO 8601 behavior of printing Z instead of an
offset for the UTC zone.  Thus:
</p>
<pre>Z0700  Z or hhmm
Z07:00 Z or hh:mm
</pre>

			
		
		
		
			
			
			<h2 id="After">func <a href="src/pkg/time/sleep.htm#L64">After</a></h2>
			<pre>func After(d Duration) &lt;-chan Time</pre>
			<p>
After waits for the duration to elapse and then sends the current time
on the returned channel.
It is equivalent to NewTimer(d).C.
</p>

			<div id="example_After" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">
select {
case m := &lt;-c:
    handle(m)
case &lt;-time.After(5 * time.Minute):
    fmt.Println(&#34;timed out&#34;)
}
</pre>
		
	</div>
</div>

		
			
			
			<h2 id="Sleep">func <a href="src/pkg/time/sleep.htm#L1">Sleep</a></h2>
			<pre>func Sleep(d Duration)</pre>
			<p>
Sleep pauses the current goroutine for the duration d.
</p>

			<div id="example_Sleep" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">
time.Sleep(100 * time.Millisecond)
</pre>
		
	</div>
</div>

		
			
			
			<h2 id="Tick">func <a href="src/pkg/time/tick.htm#L38">Tick</a></h2>
			<pre>func Tick(d Duration) &lt;-chan Time</pre>
			<p>
Tick is a convenience wrapper for NewTicker providing access to the ticking
channel only.  Useful for clients that have no need to shut down the ticker.
</p>

			<div id="example_Tick" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">
c := time.Tick(1 * time.Minute)
for now := range c {
    fmt.Printf(&#34;%v %s\n&#34;, now, statusUpdate())
}
</pre>
		
	</div>
</div>

		
		
			
			
			<h2 id="Duration">type <a href="src/pkg/time/time.htm#L374">Duration</a></h2>
			<pre>type Duration int64</pre>
			<p>
A Duration represents the elapsed time between two instants
as an int64 nanosecond count.  The representation limits the
largest representable duration to approximately 290 years.
</p>


			
				<pre>const (
    Nanosecond  Duration = 1
    Microsecond          = 1000 * Nanosecond
    Millisecond          = 1000 * Microsecond
    Second               = 1000 * Millisecond
    Minute               = 60 * Second
    Hour                 = 60 * Minute
)</pre>
				<p>
Common durations.  There is no definition for units of Day or larger
to avoid confusion across daylight savings time zone transitions.
</p>
<p>
To count the number of units in a Duration, divide:
</p>
<pre>second := time.Second
fmt.Print(int64(second/time.Millisecond)) // prints 1000
</pre>
<p>
To convert an integer number of units to a Duration, multiply:
</p>
<pre>seconds := 10
fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
</pre>

			

			

			<div id="example_Duration" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">
t0 := time.Now()
expensiveCall()
t1 := time.Now()
fmt.Printf(&#34;The call took %v to run.\n&#34;, t1.Sub(t0))
</pre>
		
	</div>
</div>


			
				
				<h3 id="ParseDuration">func <a href="src/pkg/time/format.htm#L942">ParseDuration</a></h3>
				<pre>func ParseDuration(s string) (Duration, error)</pre>
				<p>
ParseDuration parses a duration string.
A duration string is a possibly signed sequence of
decimal numbers, each with optional fraction and a unit suffix,
such as &#34;300ms&#34;, &#34;-1.5h&#34; or &#34;2h45m&#34;.
Valid time units are &#34;ns&#34;, &#34;us&#34; (or &#34;?s&#34;), &#34;ms&#34;, &#34;s&#34;, &#34;m&#34;, &#34;h&#34;.
</p>

				
			
				
				<h3 id="Since">func <a href="src/pkg/time/time.htm#L571">Since</a></h3>
				<pre>func Since(t Time) Duration</pre>
				<p>
Since returns the time elapsed since t.
It is shorthand for time.Now().Sub(t).
</p>

				
			

			
				
				<h3 id="Duration.Hours">func (Duration) <a href="src/pkg/time/time.htm#L543">Hours</a></h3>
				<pre>func (d Duration) Hours() float64</pre>
				<p>
Hours returns the duration as a floating point number of hours.
</p>

				
				
			
				
				<h3 id="Duration.Minutes">func (Duration) <a href="src/pkg/time/time.htm#L536">Minutes</a></h3>
				<pre>func (d Duration) Minutes() float64</pre>
				<p>
Minutes returns the duration as a floating point number of minutes.
</p>

				
				
			
				
				<h3 id="Duration.Nanoseconds">func (Duration) <a href="src/pkg/time/time.htm#L517">Nanoseconds</a></h3>
				<pre>func (d Duration) Nanoseconds() int64</pre>
				<p>
Nanoseconds returns the duration as an integer nanosecond count.
</p>

				
				
			
				
				<h3 id="Duration.Seconds">func (Duration) <a href="src/pkg/time/time.htm#L529">Seconds</a></h3>
				<pre>func (d Duration) Seconds() float64</pre>
				<p>
Seconds returns the duration as a floating point number of seconds.
</p>

				
				
			
				
				<h3 id="Duration.String">func (Duration) <a href="src/pkg/time/time.htm#L401">String</a></h3>
				<pre>func (d Duration) String() string</pre>
				<p>
String returns a string representing the duration in the form &#34;72h3m0.5s&#34;.
Leading zero units are omitted.  As a special case, durations less than one
second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure
that the leading digit is non-zero.  The zero duration formats as 0,
with no unit.
</p>

				
				
			
		
			
			
			<h2 id="Location">type <a href="src/pkg/time/zoneinfo.htm#L5">Location</a></h2>
			<pre>type Location struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Location maps time instants to the zone in use at that time.
Typically, the Location represents the collection of time offsets
in use in a geographical area, such as CEST and CET for central Europe.
</p>


			

			
				<pre>var Local *Location = &amp;localLoc</pre>
				<p>
Local represents the system&#39;s local time zone.
</p>

			
				<pre>var UTC *Location = &amp;utcLoc</pre>
				<p>
UTC represents Universal Coordinated Time (UTC).
</p>

			

			

			
				
				<h3 id="FixedZone">func <a href="src/pkg/time/zoneinfo.htm#L72">FixedZone</a></h3>
				<pre>func FixedZone(name string, offset int) *Location</pre>
				<p>
FixedZone returns a Location that always uses
the given zone name and offset (seconds east of UTC).
</p>

				
			
				
				<h3 id="LoadLocation">func <a href="src/pkg/time/zoneinfo.htm#L180">LoadLocation</a></h3>
				<pre>func LoadLocation(name string) (*Location, error)</pre>
				<p>
LoadLocation returns the Location with the given name.
</p>
<p>
If the name is &#34;&#34; or &#34;UTC&#34;, LoadLocation returns UTC.
If the name is &#34;Local&#34;, LoadLocation returns Local.
</p>
<p>
Otherwise, the name is taken to be a location name corresponding to a file
in the IANA Time Zone database, such as &#34;America/New_York&#34;.
</p>
<p>
The time zone database needed by LoadLocation may not be
present on all systems, especially non-Unix systems.
LoadLocation looks in the directory or uncompressed zip file
named by the ZONEINFO environment variable, if any, then looks in
known installation locations on Unix systems,
and finally looks in $GOROOT/lib/time/zoneinfo.zip.
</p>

				
			

			
				
				<h3 id="Location.String">func (*Location) <a href="src/pkg/time/zoneinfo.htm#L66">String</a></h3>
				<pre>func (l *Location) String() string</pre>
				<p>
String returns a descriptive name for the time zone information,
corresponding to the argument to LoadLocation.
</p>

				
				
			
		
			
			
			<h2 id="Month">type <a href="src/pkg/time/time.htm#L62">Month</a></h2>
			<pre>type Month int</pre>
			<p>
A Month specifies a month of the year (January = 1, ...).
</p>


			
				<pre>const (
    January Month = 1 + iota
    February
    March
    April
    May
    June
    July
    August
    September
    October
    November
    December
)</pre>
				
			

			

			<div id="example_Month" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">
_, month, day := time.Now().Date()
if month == time.November &amp;&amp; day == 10 {
    fmt.Println(&#34;Happy Go day!&#34;)
}
</pre>
		
	</div>
</div>


			

			
				
				<h3 id="Month.String">func (Month) <a href="src/pkg/time/time.htm#L95">String</a></h3>
				<pre>func (m Month) String() string</pre>
				<p>
String returns the English name of the month (&#34;January&#34;, &#34;February&#34;, ...).
</p>

				
				
			
		
			
			
			<h2 id="ParseError">type <a href="src/pkg/time/format.htm#L514">ParseError</a></h2>
			<pre>type ParseError struct {
    Layout     string
    Value      string
    LayoutElem string
    ValueElem  string
    Message    string
}</pre>
			<p>
ParseError describes a problem parsing a time string.
</p>


			

			

			

			

			
				
				<h3 id="ParseError.Error">func (*ParseError) <a href="src/pkg/time/format.htm#L527">Error</a></h3>
				<pre>func (e *ParseError) Error() string</pre>
				<p>
Error returns the string representation of a ParseError.
</p>

				
				
			
		
			
			
			<h2 id="Ticker">type <a href="src/pkg/time/tick.htm#L1">Ticker</a></h2>
			<pre>type Ticker struct {
    C &lt;-chan Time <span class="comment">// The channel on which the ticks are delivered.</span>
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Ticker holds a synchronous channel that delivers `ticks&#39; of a clock
at intervals.
</p>


			

			

			

			
				
				<h3 id="NewTicker">func <a href="src/pkg/time/tick.htm#L10">NewTicker</a></h3>
				<pre>func NewTicker(d Duration) *Ticker</pre>
				<p>
NewTicker returns a new Ticker containing a channel that will send the
time with a period specified by the duration argument.
It adjusts the intervals or drops ticks to make up for slow receivers.
The duration d must be greater than zero; if not, NewTicker will panic.
</p>

				
			

			
				
				<h3 id="Ticker.Stop">func (*Ticker) <a href="src/pkg/time/tick.htm#L32">Stop</a></h3>
				<pre>func (t *Ticker) Stop()</pre>
				<p>
Stop turns off a ticker.  After Stop, no more ticks will be sent.
</p>

				
				
			
		
			
			
			<h2 id="Time">type <a href="src/pkg/time/time.htm#L24">Time</a></h2>
			<pre>type Time struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Time represents an instant in time with nanosecond precision.
</p>
<p>
Programs using times should typically store and pass them as values,
not pointers.  That is, time variables and struct fields should be of
type time.Time, not *time.Time.  A Time value can be used by
multiple goroutines simultaneously.
</p>
<p>
Time instants can be compared using the Before, After, and Equal methods.
The Sub method subtracts two instants, producing a Duration.
The Add method adds a Time and a Duration, producing a Time.
</p>
<p>
The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.
As this time is unlikely to come up in practice, the IsZero method gives
a simple way of detecting a time that has not been initialized explicitly.
</p>
<p>
Each Time has associated with it a Location, consulted when computing the
presentation form of the time, such as in the Format, Hour, and Year methods.
The methods Local, UTC, and In return a Time with a specific location.
Changing the location in this way changes only the presentation; it does not
change the instant in time being denoted and therefore does not affect the
computations described in earlier paragraphs.
</p>


			

			

			

			
				
				<h3 id="Date">func <a href="src/pkg/time/time.htm#L909">Date</a></h3>
				<pre>func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</pre>
				<p>
Date returns the Time corresponding to
</p>
<pre>yyyy-mm-dd hh:mm:ss + nsec nanoseconds
</pre>
<p>
in the appropriate zone for that time in the given location.
</p>
<p>
The month, day, hour, min, sec, and nsec values may be outside
their usual ranges and will be normalized during the conversion.
For example, October 32 converts to November 1.
</p>
<p>
A daylight savings time transition skips or repeats times.
For example, in the United States, March 13, 2011 2:15am never occurred,
while November 6, 2011 1:15am occurred twice.  In such cases, the
choice of time zone, and therefore the time, is not well-defined.
Date returns a time that is correct in one of the two zones involved
in the transition, but it does not guarantee which.
</p>
<p>
Date panics if loc is nil.
</p>

				<div id="example_Date" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">t := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
fmt.Printf(&#34;Go launched at %s\n&#34;, t.Local())
<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">Go launched at 2009-11-10 15:00:00 -0800 PST</pre>
		
	</div>
</div>

			
				
				<h3 id="Now">func <a href="src/pkg/time/time.htm#L705">Now</a></h3>
				<pre>func Now() Time</pre>
				<p>
Now returns the current local time.
</p>

				
			
				
				<h3 id="Parse">func <a href="src/pkg/time/format.htm#L607">Parse</a></h3>
				<pre>func Parse(layout, value string) (Time, error)</pre>
				<p>
Parse parses a formatted string and returns the time value it represents.
The layout defines the format by showing the representation of the
standard time,
</p>
<pre>Mon Jan 2 15:04:05 -0700 MST 2006
</pre>
<p>
which is then used to describe the string to be parsed. Predefined layouts
ANSIC, UnixDate, RFC3339 and others describe standard representations. For
more information about the formats and the definition of the standard
time, see the documentation for ANSIC.
</p>
<p>
Elements omitted from the value are assumed to be zero or, when
zero is impossible, one, so parsing &#34;3:04pm&#34; returns the time
corresponding to Jan 1, year 0, 15:04:00 UTC.
Years must be in the range 0000..9999. The day of the week is checked
for syntax but it is otherwise ignored.
</p>

				
			
				
				<h3 id="Unix">func <a href="src/pkg/time/time.htm#L859">Unix</a></h3>
				<pre>func Unix(sec int64, nsec int64) Time</pre>
				<p>
Unix returns the local Time corresponding to the given Unix time,
sec seconds and nsec nanoseconds since January 1, 1970 UTC.
It is valid to pass nsec outside the range [0, 999999999].
</p>

				
			

			
				
				<h3 id="Time.Add">func (Time) <a href="src/pkg/time/time.htm#L550">Add</a></h3>
				<pre>func (t Time) Add(d Duration) Time</pre>
				<p>
Add returns the time t+d.
</p>

				
				
			
				
				<h3 id="Time.AddDate">func (Time) <a href="src/pkg/time/time.htm#L583">AddDate</a></h3>
				<pre>func (t Time) AddDate(years int, months int, days int) Time</pre>
				<p>
AddDate returns the time corresponding to adding the
given number of years, months, and days to t.
For example, AddDate(-1, 2, 3) applied to January 1, 2011
returns March 4, 2010.
</p>
<p>
AddDate normalizes its result in the same way that Date does,
so, for example, adding one month to October 31 yields
December 1, the normalized form for November 31.
</p>

				
				
			
				
				<h3 id="Time.After">func (Time) <a href="src/pkg/time/time.htm#L43">After</a></h3>
				<pre>func (t Time) After(u Time) bool</pre>
				<p>
After reports whether the time instant t is after u.
</p>

				
				
			
				
				<h3 id="Time.Before">func (Time) <a href="src/pkg/time/time.htm#L48">Before</a></h3>
				<pre>func (t Time) Before(u Time) bool</pre>
				<p>
Before reports whether the time instant t is before u.
</p>

				
				
			
				
				<h3 id="Time.Clock">func (Time) <a href="src/pkg/time/time.htm#L341">Clock</a></h3>
				<pre>func (t Time) Clock() (hour, min, sec int)</pre>
				<p>
Clock returns the hour, minute, and second within the day specified by t.
</p>

				
				
			
				
				<h3 id="Time.Date">func (Time) <a href="src/pkg/time/time.htm#L251">Date</a></h3>
				<pre>func (t Time) Date() (year int, month Month, day int)</pre>
				<p>
Date returns the year, month, and day in which t occurs.
</p>

				
				
			
				
				<h3 id="Time.Day">func (Time) <a href="src/pkg/time/time.htm#L269">Day</a></h3>
				<pre>func (t Time) Day() int</pre>
				<p>
Day returns the day of the month specified by t.
</p>

				
				
			
				
				<h3 id="Time.Equal">func (Time) <a href="src/pkg/time/time.htm#L57">Equal</a></h3>
				<pre>func (t Time) Equal(u Time) bool</pre>
				<p>
Equal reports whether t and u represent the same time instant.
Two times can be equal even if they are in different locations.
For example, 6:00 +0200 CEST and 4:00 UTC are Equal.
This comparison is different from using t == u, which also compares
the locations.
</p>

				
				
			
				
				<h3 id="Time.Format">func (Time) <a href="src/pkg/time/format.htm#L352">Format</a></h3>
				<pre>func (t Time) Format(layout string) string</pre>
				<p>
Format returns a textual representation of the time value formatted
according to layout.  The layout defines the format by showing the
representation of the standard time,
</p>
<pre>Mon Jan 2 15:04:05 -0700 MST 2006
</pre>
<p>
which is then used to describe the time to be formatted. Predefined
layouts ANSIC, UnixDate, RFC3339 and others describe standard
representations. For more information about the formats and the
definition of the standard time, see the documentation for ANSIC.
</p>

				
				
			
				
				<h3 id="Time.GobDecode">func (*Time) <a href="src/pkg/time/time.htm#L805">GobDecode</a></h3>
				<pre>func (t *Time) GobDecode(buf []byte) error</pre>
				<p>
GobDecode implements the gob.GobDecoder interface.
</p>

				
				
			
				
				<h3 id="Time.GobEncode">func (Time) <a href="src/pkg/time/time.htm#L766">GobEncode</a></h3>
				<pre>func (t Time) GobEncode() ([]byte, error)</pre>
				<p>
GobEncode implements the gob.GobEncoder interface.
</p>

				
				
			
				
				<h3 id="Time.Hour">func (Time) <a href="src/pkg/time/time.htm#L351">Hour</a></h3>
				<pre>func (t Time) Hour() int</pre>
				<p>
Hour returns the hour within the day specified by t, in the range [0, 23].
</p>

				
				
			
				
				<h3 id="Time.ISOWeek">func (Time) <a href="src/pkg/time/time.htm#L285">ISOWeek</a></h3>
				<pre>func (t Time) ISOWeek() (year, week int)</pre>
				<p>
ISOWeek returns the ISO 8601 year and week number in which t occurs.
Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to
week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1
of year n+1.
</p>

				
				
			
				
				<h3 id="Time.In">func (Time) <a href="src/pkg/time/time.htm#L725">In</a></h3>
				<pre>func (t Time) In(loc *Location) Time</pre>
				<p>
In returns t with the location information set to loc.
</p>
<p>
In panics if loc is nil.
</p>

				
				
			
				
				<h3 id="Time.IsZero">func (Time) <a href="src/pkg/time/time.htm#L226">IsZero</a></h3>
				<pre>func (t Time) IsZero() bool</pre>
				<p>
IsZero reports whether t represents the zero time instant,
January 1, year 1, 00:00:00 UTC.
</p>

				
				
			
				
				<h3 id="Time.Local">func (Time) <a href="src/pkg/time/time.htm#L717">Local</a></h3>
				<pre>func (t Time) Local() Time</pre>
				<p>
Local returns t with the location set to local time.
</p>

				
				
			
				
				<h3 id="Time.Location">func (Time) <a href="src/pkg/time/time.htm#L734">Location</a></h3>
				<pre>func (t Time) Location() *Location</pre>
				<p>
Location returns the time zone information associated with t.
</p>

				
				
			
				
				<h3 id="Time.MarshalJSON">func (Time) <a href="src/pkg/time/time.htm#L841">MarshalJSON</a></h3>
				<pre>func (t Time) MarshalJSON() ([]byte, error)</pre>
				<p>
MarshalJSON implements the json.Marshaler interface.
Time is formatted as RFC3339.
</p>

				
				
			
				
				<h3 id="Time.Minute">func (Time) <a href="src/pkg/time/time.htm#L356">Minute</a></h3>
				<pre>func (t Time) Minute() int</pre>
				<p>
Minute returns the minute offset within the hour specified by t, in the range [0, 59].
</p>

				
				
			
				
				<h3 id="Time.Month">func (Time) <a href="src/pkg/time/time.htm#L263">Month</a></h3>
				<pre>func (t Time) Month() Month</pre>
				<p>
Month returns the month of the year specified by t.
</p>

				
				
			
				
				<h3 id="Time.Nanosecond">func (Time) <a href="src/pkg/time/time.htm#L367">Nanosecond</a></h3>
				<pre>func (t Time) Nanosecond() int</pre>
				<p>
Nanosecond returns the nanosecond offset within the second specified by t,
in the range [0, 999999999].
</p>

				
				
			
				
				<h3 id="Time.Second">func (Time) <a href="src/pkg/time/time.htm#L361">Second</a></h3>
				<pre>func (t Time) Second() int</pre>
				<p>
Second returns the second offset within the minute specified by t, in the range [0, 59].
</p>

				
				
			
				
				<h3 id="Time.String">func (Time) <a href="src/pkg/time/format.htm#L330">String</a></h3>
				<pre>func (t Time) String() string</pre>
				<p>
String returns the time formatted using the format string
</p>
<pre>&#34;2006-01-02 15:04:05.999999999 -0700 MST&#34;
</pre>

				
				
			
				
				<h3 id="Time.Sub">func (Time) <a href="src/pkg/time/time.htm#L565">Sub</a></h3>
				<pre>func (t Time) Sub(u Time) Duration</pre>
				<p>
Sub returns the duration t-u.
To compute t-d for a duration d, use t.Add(-d).
</p>

				
				
			
				
				<h3 id="Time.UTC">func (Time) <a href="src/pkg/time/time.htm#L711">UTC</a></h3>
				<pre>func (t Time) UTC() Time</pre>
				<p>
UTC returns t with the location set to UTC.
</p>

				
				
			
				
				<h3 id="Time.Unix">func (Time) <a href="src/pkg/time/time.htm#L751">Unix</a></h3>
				<pre>func (t Time) Unix() int64</pre>
				<p>
Unix returns t as a Unix time, the number of seconds elapsed
since January 1, 1970 UTC.
</p>

				
				
			
				
				<h3 id="Time.UnixNano">func (Time) <a href="src/pkg/time/time.htm#L759">UnixNano</a></h3>
				<pre>func (t Time) UnixNano() int64</pre>
				<p>
UnixNano returns t as a Unix time, the number of nanoseconds elapsed
since January 1, 1970 UTC. The result is undefined if the Unix time
in nanoseconds cannot be represented by an int64. Note that this
means the result of calling UnixNano on the zero Time is undefined.
</p>

				
				
			
				
				<h3 id="Time.UnmarshalJSON">func (*Time) <a href="src/pkg/time/time.htm#L850">UnmarshalJSON</a></h3>
				<pre>func (t *Time) UnmarshalJSON(data []byte) (err error)</pre>
				<p>
UnmarshalJSON implements the json.Unmarshaler interface.
Time is expected in RFC3339 format.
</p>

				
				
			
				
				<h3 id="Time.Weekday">func (Time) <a href="src/pkg/time/time.htm#L275">Weekday</a></h3>
				<pre>func (t Time) Weekday() Weekday</pre>
				<p>
Weekday returns the day of the week specified by t.
</p>

				
				
			
				
				<h3 id="Time.Year">func (Time) <a href="src/pkg/time/time.htm#L257">Year</a></h3>
				<pre>func (t Time) Year() int</pre>
				<p>
Year returns the year in which t occurs.
</p>

				
				
			
				
				<h3 id="Time.Zone">func (Time) <a href="src/pkg/time/time.htm#L744">Zone</a></h3>
				<pre>func (t Time) Zone() (name string, offset int)</pre>
				<p>
Zone computes the time zone in effect at time t, returning the abbreviated
name of the zone (such as &#34;CET&#34;) and its offset in seconds east of UTC.
</p>

				
				
			
		
			
			
			<h2 id="Timer">type <a href="src/pkg/time/sleep.htm#L21">Timer</a></h2>
			<pre>type Timer struct {
    C &lt;-chan Time
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
The Timer type represents a single event.
When the Timer expires, the current time will be sent on C,
unless the Timer was created by AfterFunc.
</p>


			

			

			

			
				
				<h3 id="AfterFunc">func <a href="src/pkg/time/sleep.htm#L71">AfterFunc</a></h3>
				<pre>func AfterFunc(d Duration, f func()) *Timer</pre>
				<p>
AfterFunc waits for the duration to elapse and then calls f
in its own goroutine. It returns a Timer that can
be used to cancel the call using its Stop method.
</p>

				
			
				
				<h3 id="NewTimer">func <a href="src/pkg/time/sleep.htm#L35">NewTimer</a></h3>
				<pre>func NewTimer(d Duration) *Timer</pre>
				<p>
NewTimer creates a new Timer that will send
the current time on its channel after at least duration d.
</p>

				
			

			
				
				<h3 id="Timer.Stop">func (*Timer) <a href="src/pkg/time/sleep.htm#L29">Stop</a></h3>
				<pre>func (t *Timer) Stop() (ok bool)</pre>
				<p>
Stop prevents the Timer from firing.
It returns true if the call stops the timer, false if the timer has already
expired or stopped.
</p>

				
				
			
		
			
			
			<h2 id="Weekday">type <a href="src/pkg/time/time.htm#L98">Weekday</a></h2>
			<pre>type Weekday int</pre>
			<p>
A Weekday specifies a day of the week (Sunday = 0, ...).
</p>


			
				<pre>const (
    Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)</pre>
				
			

			

			

			

			
				
				<h3 id="Weekday.String">func (Weekday) <a href="src/pkg/time/time.htm#L121">String</a></h3>
				<pre>func (d Weekday) String() string</pre>
				<p>
String returns the English name of the day (&#34;Sunday&#34;, &#34;Monday&#34;, ...).
</p>

				
				
			
		
		</div>
	

	









</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
