
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>elf - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package elf</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "debug/elf"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package elf implements access to ELF object files.
</p>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
				<dd><a href="#constants">Constants</a></dd>
			
			
			
				
				<dd><a href="#R_INFO">func R_INFO(sym, typ uint32) uint64</a></dd>
			
				
				<dd><a href="#R_INFO32">func R_INFO32(sym, typ uint32) uint32</a></dd>
			
				
				<dd><a href="#R_SYM32">func R_SYM32(info uint32) uint32</a></dd>
			
				
				<dd><a href="#R_SYM64">func R_SYM64(info uint64) uint32</a></dd>
			
				
				<dd><a href="#R_TYPE32">func R_TYPE32(info uint32) uint32</a></dd>
			
				
				<dd><a href="#R_TYPE64">func R_TYPE64(info uint64) uint32</a></dd>
			
				
				<dd><a href="#ST_INFO">func ST_INFO(bind SymBind, typ SymType) uint8</a></dd>
			
			
				
				<dd><a href="#Class">type Class</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Class.GoString">func (i Class) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Class.String">func (i Class) String() string</a></dd>
				
			
				
				<dd><a href="#Data">type Data</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Data.GoString">func (i Data) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Data.String">func (i Data) String() string</a></dd>
				
			
				
				<dd><a href="#Dyn32">type Dyn32</a></dd>
				
				
			
				
				<dd><a href="#Dyn64">type Dyn64</a></dd>
				
				
			
				
				<dd><a href="#DynFlag">type DynFlag</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DynFlag.GoString">func (i DynFlag) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DynFlag.String">func (i DynFlag) String() string</a></dd>
				
			
				
				<dd><a href="#DynTag">type DynTag</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DynTag.GoString">func (i DynTag) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DynTag.String">func (i DynTag) String() string</a></dd>
				
			
				
				<dd><a href="#File">type File</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFile">func NewFile(r io.ReaderAt) (*File, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Open">func Open(name string) (*File, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Close">func (f *File) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.DWARF">func (f *File) DWARF() (*dwarf.Data, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.ImportedLibraries">func (f *File) ImportedLibraries() ([]string, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.ImportedSymbols">func (f *File) ImportedSymbols() ([]ImportedSymbol, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Section">func (f *File) Section(name string) *Section</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.SectionByType">func (f *File) SectionByType(typ SectionType) *Section</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Symbols">func (f *File) Symbols() ([]Symbol, error)</a></dd>
				
			
				
				<dd><a href="#FileHeader">type FileHeader</a></dd>
				
				
			
				
				<dd><a href="#FormatError">type FormatError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FormatError.Error">func (e *FormatError) Error() string</a></dd>
				
			
				
				<dd><a href="#Header32">type Header32</a></dd>
				
				
			
				
				<dd><a href="#Header64">type Header64</a></dd>
				
				
			
				
				<dd><a href="#ImportedSymbol">type ImportedSymbol</a></dd>
				
				
			
				
				<dd><a href="#Machine">type Machine</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Machine.GoString">func (i Machine) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Machine.String">func (i Machine) String() string</a></dd>
				
			
				
				<dd><a href="#NType">type NType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NType.GoString">func (i NType) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NType.String">func (i NType) String() string</a></dd>
				
			
				
				<dd><a href="#OSABI">type OSABI</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#OSABI.GoString">func (i OSABI) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#OSABI.String">func (i OSABI) String() string</a></dd>
				
			
				
				<dd><a href="#Prog">type Prog</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Prog.Open">func (p *Prog) Open() io.ReadSeeker</a></dd>
				
			
				
				<dd><a href="#Prog32">type Prog32</a></dd>
				
				
			
				
				<dd><a href="#Prog64">type Prog64</a></dd>
				
				
			
				
				<dd><a href="#ProgFlag">type ProgFlag</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ProgFlag.GoString">func (i ProgFlag) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ProgFlag.String">func (i ProgFlag) String() string</a></dd>
				
			
				
				<dd><a href="#ProgHeader">type ProgHeader</a></dd>
				
				
			
				
				<dd><a href="#ProgType">type ProgType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ProgType.GoString">func (i ProgType) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ProgType.String">func (i ProgType) String() string</a></dd>
				
			
				
				<dd><a href="#R_386">type R_386</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#R_386.GoString">func (i R_386) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#R_386.String">func (i R_386) String() string</a></dd>
				
			
				
				<dd><a href="#R_ALPHA">type R_ALPHA</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#R_ALPHA.GoString">func (i R_ALPHA) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#R_ALPHA.String">func (i R_ALPHA) String() string</a></dd>
				
			
				
				<dd><a href="#R_ARM">type R_ARM</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#R_ARM.GoString">func (i R_ARM) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#R_ARM.String">func (i R_ARM) String() string</a></dd>
				
			
				
				<dd><a href="#R_PPC">type R_PPC</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#R_PPC.GoString">func (i R_PPC) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#R_PPC.String">func (i R_PPC) String() string</a></dd>
				
			
				
				<dd><a href="#R_SPARC">type R_SPARC</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#R_SPARC.GoString">func (i R_SPARC) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#R_SPARC.String">func (i R_SPARC) String() string</a></dd>
				
			
				
				<dd><a href="#R_X86_64">type R_X86_64</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#R_X86_64.GoString">func (i R_X86_64) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#R_X86_64.String">func (i R_X86_64) String() string</a></dd>
				
			
				
				<dd><a href="#Rel32">type Rel32</a></dd>
				
				
			
				
				<dd><a href="#Rel64">type Rel64</a></dd>
				
				
			
				
				<dd><a href="#Rela32">type Rela32</a></dd>
				
				
			
				
				<dd><a href="#Rela64">type Rela64</a></dd>
				
				
			
				
				<dd><a href="#Section">type Section</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Section.Data">func (s *Section) Data() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Section.Open">func (s *Section) Open() io.ReadSeeker</a></dd>
				
			
				
				<dd><a href="#Section32">type Section32</a></dd>
				
				
			
				
				<dd><a href="#Section64">type Section64</a></dd>
				
				
			
				
				<dd><a href="#SectionFlag">type SectionFlag</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SectionFlag.GoString">func (i SectionFlag) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SectionFlag.String">func (i SectionFlag) String() string</a></dd>
				
			
				
				<dd><a href="#SectionHeader">type SectionHeader</a></dd>
				
				
			
				
				<dd><a href="#SectionIndex">type SectionIndex</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SectionIndex.GoString">func (i SectionIndex) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SectionIndex.String">func (i SectionIndex) String() string</a></dd>
				
			
				
				<dd><a href="#SectionType">type SectionType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SectionType.GoString">func (i SectionType) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SectionType.String">func (i SectionType) String() string</a></dd>
				
			
				
				<dd><a href="#Sym32">type Sym32</a></dd>
				
				
			
				
				<dd><a href="#Sym64">type Sym64</a></dd>
				
				
			
				
				<dd><a href="#SymBind">type SymBind</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ST_BIND">func ST_BIND(info uint8) SymBind</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SymBind.GoString">func (i SymBind) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SymBind.String">func (i SymBind) String() string</a></dd>
				
			
				
				<dd><a href="#SymType">type SymType</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ST_TYPE">func ST_TYPE(info uint8) SymType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SymType.GoString">func (i SymType) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SymType.String">func (i SymType) String() string</a></dd>
				
			
				
				<dd><a href="#SymVis">type SymVis</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ST_VISIBILITY">func ST_VISIBILITY(other uint8) SymVis</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SymVis.GoString">func (i SymVis) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SymVis.String">func (i SymVis) String() string</a></dd>
				
			
				
				<dd><a href="#Symbol">type Symbol</a></dd>
				
				
			
				
				<dd><a href="#Type">type Type</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Type.GoString">func (i Type) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Type.String">func (i Type) String() string</a></dd>
				
			
				
				<dd><a href="#Version">type Version</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Version.GoString">func (i Version) GoString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Version.String">func (i Version) String() string</a></dd>
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/debug/elf/elf.htm">elf.go</a>
			
				<a href="src/pkg/debug/elf/file.htm">file.go</a>
			
			</span>
			</p>
		
	
		
			<h2 id="constants">Constants</h2>
			
				<pre>const (
    EI_CLASS      = 4  <span class="comment">/* Class of machine. */</span>
    EI_DATA       = 5  <span class="comment">/* Data format. */</span>
    EI_VERSION    = 6  <span class="comment">/* ELF format version. */</span>
    EI_OSABI      = 7  <span class="comment">/* Operating system / ABI identification */</span>
    EI_ABIVERSION = 8  <span class="comment">/* ABI version */</span>
    EI_PAD        = 9  <span class="comment">/* Start of padding (per SVR4 ABI). */</span>
    EI_NIDENT     = 16 <span class="comment">/* Size of e_ident array. */</span>
)</pre>
				<p>
Indexes into the Header.Ident array.
</p>

			
				<pre>const ARM_MAGIC_TRAMP_NUMBER = 0x5c000003</pre>
				<p>
Magic number for the elf trampoline, chosen wisely to be an immediate value.
</p>

			
				<pre>const ELFMAG = &#34;\177ELF&#34;</pre>
				<p>
Initial magic number for ELF files.
</p>

			
				<pre>const Sym32Size = 16</pre>
				
			
				<pre>const Sym64Size = 24</pre>
				
			
		
		
		
			
			
			<h2 id="R_INFO">func <a href="src/pkg/debug/elf/elf.htm#L1445">R_INFO</a></h2>
			<pre>func R_INFO(sym, typ uint32) uint64</pre>
			
			
		
			
			
			<h2 id="R_INFO32">func <a href="src/pkg/debug/elf/elf.htm#L1351">R_INFO32</a></h2>
			<pre>func R_INFO32(sym, typ uint32) uint32</pre>
			
			
		
			
			
			<h2 id="R_SYM32">func <a href="src/pkg/debug/elf/elf.htm#L1349">R_SYM32</a></h2>
			<pre>func R_SYM32(info uint32) uint32</pre>
			
			
		
			
			
			<h2 id="R_SYM64">func <a href="src/pkg/debug/elf/elf.htm#L1443">R_SYM64</a></h2>
			<pre>func R_SYM64(info uint64) uint32</pre>
			
			
		
			
			
			<h2 id="R_TYPE32">func <a href="src/pkg/debug/elf/elf.htm#L1350">R_TYPE32</a></h2>
			<pre>func R_TYPE32(info uint32) uint32</pre>
			
			
		
			
			
			<h2 id="R_TYPE64">func <a href="src/pkg/debug/elf/elf.htm#L1444">R_TYPE64</a></h2>
			<pre>func R_TYPE64(info uint64) uint32</pre>
			
			
		
			
			
			<h2 id="ST_INFO">func <a href="src/pkg/debug/elf/elf.htm#L1367">ST_INFO</a></h2>
			<pre>func ST_INFO(bind SymBind, typ SymType) uint8</pre>
			
			
		
		
			
			
			<h2 id="Class">type <a href="src/pkg/debug/elf/elf.htm#L70">Class</a></h2>
			<pre>type Class byte</pre>
			<p>
Class is found in Header.Ident[EI_CLASS] and Header.Class.
</p>


			
				<pre>const (
    ELFCLASSNONE Class = 0 <span class="comment">/* Unknown class. */</span>
    ELFCLASS32   Class = 1 <span class="comment">/* 32-bit architecture. */</span>
    ELFCLASS64   Class = 2 <span class="comment">/* 64-bit architecture. */</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="Class.GoString">func (Class) <a href="src/pkg/debug/elf/elf.htm#L85">GoString</a></h3>
				<pre>func (i Class) GoString() string</pre>
				
				
				
			
				
				<h3 id="Class.String">func (Class) <a href="src/pkg/debug/elf/elf.htm#L84">String</a></h3>
				<pre>func (i Class) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Data">type <a href="src/pkg/debug/elf/elf.htm#L88">Data</a></h2>
			<pre>type Data byte</pre>
			<p>
Data is found in Header.Ident[EI_DATA] and Header.Data.
</p>


			
				<pre>const (
    ELFDATANONE Data = 0 <span class="comment">/* Unknown data format. */</span>
    ELFDATA2LSB Data = 1 <span class="comment">/* 2&#39;s complement little-endian. */</span>
    ELFDATA2MSB Data = 2 <span class="comment">/* 2&#39;s complement big-endian. */</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="Data.GoString">func (Data) <a href="src/pkg/debug/elf/elf.htm#L103">GoString</a></h3>
				<pre>func (i Data) GoString() string</pre>
				
				
				
			
				
				<h3 id="Data.String">func (Data) <a href="src/pkg/debug/elf/elf.htm#L102">String</a></h3>
				<pre>func (i Data) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Dyn32">type <a href="src/pkg/debug/elf/elf.htm#L1327">Dyn32</a></h2>
			<pre>type Dyn32 struct {
    Tag int32  <span class="comment">/* Entry type. */</span>
    Val uint32 <span class="comment">/* Integer/Address value. */</span>
}</pre>
			<p>
ELF32 Dynamic structure.  The &#34;.dynamic&#34; section contains an array of them.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Dyn64">type <a href="src/pkg/debug/elf/elf.htm#L1421">Dyn64</a></h2>
			<pre>type Dyn64 struct {
    Tag int64  <span class="comment">/* Entry type. */</span>
    Val uint64 <span class="comment">/* Integer/address value */</span>
}</pre>
			<p>
ELF64 Dynamic structure.  The &#34;.dynamic&#34; section contains an array of them.
</p>


			

			

			

			

			
		
			
			
			<h2 id="DynFlag">type <a href="src/pkg/debug/elf/elf.htm#L577">DynFlag</a></h2>
			<pre>type DynFlag int</pre>
			<p>
DT_FLAGS values.
</p>


			
				<pre>const (
    DF_ORIGIN DynFlag = 0x0001 <span class="comment">/* Indicates that the object being loaded may
       make reference to the
       $ORIGIN substitution string */</span>
    DF_SYMBOLIC DynFlag = 0x0002 <span class="comment">/* Indicates &#34;symbolic&#34; linking. */</span>
    DF_TEXTREL  DynFlag = 0x0004 <span class="comment">/* Indicates there may be relocations in non-writable segments. */</span>
    DF_BIND_NOW DynFlag = 0x0008 <span class="comment">/* Indicates that the dynamic linker should
       process all relocations for the object
       containing this entry before transferring
       control to the program. */</span>
    DF_STATIC_TLS DynFlag = 0x0010 <span class="comment">/* Indicates that the shared object or
       executable contains code using a static
       thread-local storage scheme. */</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="DynFlag.GoString">func (DynFlag) <a href="src/pkg/debug/elf/elf.htm#L603">GoString</a></h3>
				<pre>func (i DynFlag) GoString() string</pre>
				
				
				
			
				
				<h3 id="DynFlag.String">func (DynFlag) <a href="src/pkg/debug/elf/elf.htm#L602">String</a></h3>
				<pre>func (i DynFlag) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="DynTag">type <a href="src/pkg/debug/elf/elf.htm#L479">DynTag</a></h2>
			<pre>type DynTag int</pre>
			<p>
Dyn.Tag
</p>


			
				<pre>const (
    DT_NULL         DynTag = 0  <span class="comment">/* Terminating entry. */</span>
    DT_NEEDED       DynTag = 1  <span class="comment">/* String table offset of a needed shared library. */</span>
    DT_PLTRELSZ     DynTag = 2  <span class="comment">/* Total size in bytes of PLT relocations. */</span>
    DT_PLTGOT       DynTag = 3  <span class="comment">/* Processor-dependent address. */</span>
    DT_HASH         DynTag = 4  <span class="comment">/* Address of symbol hash table. */</span>
    DT_STRTAB       DynTag = 5  <span class="comment">/* Address of string table. */</span>
    DT_SYMTAB       DynTag = 6  <span class="comment">/* Address of symbol table. */</span>
    DT_RELA         DynTag = 7  <span class="comment">/* Address of ElfNN_Rela relocations. */</span>
    DT_RELASZ       DynTag = 8  <span class="comment">/* Total size of ElfNN_Rela relocations. */</span>
    DT_RELAENT      DynTag = 9  <span class="comment">/* Size of each ElfNN_Rela relocation entry. */</span>
    DT_STRSZ        DynTag = 10 <span class="comment">/* Size of string table. */</span>
    DT_SYMENT       DynTag = 11 <span class="comment">/* Size of each symbol table entry. */</span>
    DT_INIT         DynTag = 12 <span class="comment">/* Address of initialization function. */</span>
    DT_FINI         DynTag = 13 <span class="comment">/* Address of finalization function. */</span>
    DT_SONAME       DynTag = 14 <span class="comment">/* String table offset of shared object name. */</span>
    DT_RPATH        DynTag = 15 <span class="comment">/* String table offset of library path. [sup] */</span>
    DT_SYMBOLIC     DynTag = 16 <span class="comment">/* Indicates &#34;symbolic&#34; linking. [sup] */</span>
    DT_REL          DynTag = 17 <span class="comment">/* Address of ElfNN_Rel relocations. */</span>
    DT_RELSZ        DynTag = 18 <span class="comment">/* Total size of ElfNN_Rel relocations. */</span>
    DT_RELENT       DynTag = 19 <span class="comment">/* Size of each ElfNN_Rel relocation. */</span>
    DT_PLTREL       DynTag = 20 <span class="comment">/* Type of relocation used for PLT. */</span>
    DT_DEBUG        DynTag = 21 <span class="comment">/* Reserved (not used). */</span>
    DT_TEXTREL      DynTag = 22 <span class="comment">/* Indicates there may be relocations in non-writable segments. [sup] */</span>
    DT_JMPREL       DynTag = 23 <span class="comment">/* Address of PLT relocations. */</span>
    DT_BIND_NOW     DynTag = 24 <span class="comment">/* [sup] */</span>
    DT_INIT_ARRAY   DynTag = 25 <span class="comment">/* Address of the array of pointers to initialization functions */</span>
    DT_FINI_ARRAY   DynTag = 26 <span class="comment">/* Address of the array of pointers to termination functions */</span>
    DT_INIT_ARRAYSZ DynTag = 27 <span class="comment">/* Size in bytes of the array of initialization functions. */</span>
    DT_FINI_ARRAYSZ DynTag = 28 <span class="comment">/* Size in bytes of the array of terminationfunctions. */</span>
    DT_RUNPATH      DynTag = 29 <span class="comment">/* String table offset of a null-terminated library search path string. */</span>
    DT_FLAGS        DynTag = 30 <span class="comment">/* Object specific flag values. */</span>
    DT_ENCODING     DynTag = 32 <span class="comment">/* Values greater than or equal to DT_ENCODING
       and less than DT_LOOS follow the rules for
       the interpretation of the d_un union
       as follows: even == &#39;d_ptr&#39;, even == &#39;d_val&#39;
       or none */</span>
    DT_PREINIT_ARRAY   DynTag = 32         <span class="comment">/* Address of the array of pointers to pre-initialization functions. */</span>
    DT_PREINIT_ARRAYSZ DynTag = 33         <span class="comment">/* Size in bytes of the array of pre-initialization functions. */</span>
    DT_LOOS            DynTag = 0x6000000d <span class="comment">/* First OS-specific */</span>
    DT_HIOS            DynTag = 0x6ffff000 <span class="comment">/* Last OS-specific */</span>
    DT_VERSYM          DynTag = 0x6ffffff0
    DT_VERNEED         DynTag = 0x6ffffffe
    DT_VERNEEDNUM      DynTag = 0x6fffffff
    DT_LOPROC          DynTag = 0x70000000 <span class="comment">/* First processor-specific type. */</span>
    DT_HIPROC          DynTag = 0x7fffffff <span class="comment">/* Last processor-specific type. */</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="DynTag.GoString">func (DynTag) <a href="src/pkg/debug/elf/elf.htm#L574">GoString</a></h3>
				<pre>func (i DynTag) GoString() string</pre>
				
				
				
			
				
				<h3 id="DynTag.String">func (DynTag) <a href="src/pkg/debug/elf/elf.htm#L573">String</a></h3>
				<pre>func (i DynTag) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="File">type <a href="src/pkg/debug/elf/file.htm#L27">File</a></h2>
			<pre>type File struct {
    FileHeader
    Sections []*Section
    Progs    []*Prog
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A File represents an open ELF file.
</p>


			

			

			

			
				
				<h3 id="NewFile">func <a href="src/pkg/debug/elf/file.htm#L179">NewFile</a></h3>
				<pre>func NewFile(r io.ReaderAt) (*File, error)</pre>
				<p>
NewFile creates a new File for accessing an ELF binary in an underlying reader.
The ELF binary is expected to start at position 0 in the ReaderAt.
</p>

				
			
				
				<h3 id="Open">func <a href="src/pkg/debug/elf/file.htm#L140">Open</a></h3>
				<pre>func Open(name string) (*File, error)</pre>
				<p>
Open opens the named file using os.Open and prepares it for use as an ELF binary.
</p>

				
			

			
				
				<h3 id="File.Close">func (*File) <a href="src/pkg/debug/elf/file.htm#L157">Close</a></h3>
				<pre>func (f *File) Close() error</pre>
				<p>
Close closes the File.
If the File was created using NewFile directly instead of Open,
Close has no effect.
</p>

				
				
			
				
				<h3 id="File.DWARF">func (*File) <a href="src/pkg/debug/elf/file.htm#L552">DWARF</a></h3>
				<pre>func (f *File) DWARF() (*dwarf.Data, error)</pre>
				
				
				
			
				
				<h3 id="File.ImportedLibraries">func (*File) <a href="src/pkg/debug/elf/file.htm#L715">ImportedLibraries</a></h3>
				<pre>func (f *File) ImportedLibraries() ([]string, error)</pre>
				<p>
ImportedLibraries returns the names of all libraries
referred to by the binary f that are expected to be
linked with the binary at dynamic link time.
</p>

				
				
			
				
				<h3 id="File.ImportedSymbols">func (*File) <a href="src/pkg/debug/elf/file.htm#L605">ImportedSymbols</a></h3>
				<pre>func (f *File) ImportedSymbols() ([]ImportedSymbol, error)</pre>
				<p>
ImportedSymbols returns the names of all symbols
referred to by the binary f that are expected to be
satisfied by other libraries at dynamic load time.
It does not return weak symbols.
</p>

				
				
			
				
				<h3 id="File.Section">func (*File) <a href="src/pkg/debug/elf/file.htm#L489">Section</a></h3>
				<pre>func (f *File) Section(name string) *Section</pre>
				<p>
Section returns a section with the given name, or nil if no such
section exists.
</p>

				
				
			
				
				<h3 id="File.SectionByType">func (*File) <a href="src/pkg/debug/elf/file.htm#L168">SectionByType</a></h3>
				<pre>func (f *File) SectionByType(typ SectionType) *Section</pre>
				<p>
SectionByType returns the first section in f with the
given type, or nil if there is no such section.
</p>

				
				
			
				
				<h3 id="File.Symbols">func (*File) <a href="src/pkg/debug/elf/file.htm#L590">Symbols</a></h3>
				<pre>func (f *File) Symbols() ([]Symbol, error)</pre>
				<p>
Symbols returns the symbol table for f.
</p>

				
				
			
		
			
			
			<h2 id="FileHeader">type <a href="src/pkg/debug/elf/file.htm#L15">FileHeader</a></h2>
			<pre>type FileHeader struct {
    Class      Class
    Data       Data
    Version    Version
    OSABI      OSABI
    ABIVersion uint8
    ByteOrder  binary.ByteOrder
    Type       Type
    Machine    Machine
}</pre>
			<p>
A FileHeader represents an ELF file header.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FormatError">type <a href="src/pkg/debug/elf/file.htm#L124">FormatError</a></h2>
			<pre>type FormatError struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			

			

			

			

			

			
				
				<h3 id="FormatError.Error">func (*FormatError) <a href="src/pkg/debug/elf/file.htm#L130">Error</a></h3>
				<pre>func (e *FormatError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="Header32">type <a href="src/pkg/debug/elf/elf.htm#L1283">Header32</a></h2>
			<pre>type Header32 struct {
    Ident     [EI_NIDENT]byte <span class="comment">/* File identification. */</span>
    Type      uint16          <span class="comment">/* File type. */</span>
    Machine   uint16          <span class="comment">/* Machine architecture. */</span>
    Version   uint32          <span class="comment">/* ELF format version. */</span>
    Entry     uint32          <span class="comment">/* Entry point. */</span>
    Phoff     uint32          <span class="comment">/* Program header file offset. */</span>
    Shoff     uint32          <span class="comment">/* Section header file offset. */</span>
    Flags     uint32          <span class="comment">/* Architecture-specific flags. */</span>
    Ehsize    uint16          <span class="comment">/* Size of ELF header in bytes. */</span>
    Phentsize uint16          <span class="comment">/* Size of program header entry. */</span>
    Phnum     uint16          <span class="comment">/* Number of program header entries. */</span>
    Shentsize uint16          <span class="comment">/* Size of section header entry. */</span>
    Shnum     uint16          <span class="comment">/* Number of section header entries. */</span>
    Shstrndx  uint16          <span class="comment">/* Section name strings section. */</span>
}</pre>
			<p>
ELF32 File header.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Header64">type <a href="src/pkg/debug/elf/elf.htm#L1377">Header64</a></h2>
			<pre>type Header64 struct {
    Ident     [EI_NIDENT]byte <span class="comment">/* File identification. */</span>
    Type      uint16          <span class="comment">/* File type. */</span>
    Machine   uint16          <span class="comment">/* Machine architecture. */</span>
    Version   uint32          <span class="comment">/* ELF format version. */</span>
    Entry     uint64          <span class="comment">/* Entry point. */</span>
    Phoff     uint64          <span class="comment">/* Program header file offset. */</span>
    Shoff     uint64          <span class="comment">/* Section header file offset. */</span>
    Flags     uint32          <span class="comment">/* Architecture-specific flags. */</span>
    Ehsize    uint16          <span class="comment">/* Size of ELF header in bytes. */</span>
    Phentsize uint16          <span class="comment">/* Size of program header entry. */</span>
    Phnum     uint16          <span class="comment">/* Number of program header entries. */</span>
    Shentsize uint16          <span class="comment">/* Size of section header entry. */</span>
    Shnum     uint16          <span class="comment">/* Number of section header entries. */</span>
    Shstrndx  uint16          <span class="comment">/* Section name strings section. */</span>
}</pre>
			<p>
ELF64 file header.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ImportedSymbol">type <a href="src/pkg/debug/elf/file.htm#L595">ImportedSymbol</a></h2>
			<pre>type ImportedSymbol struct {
    Name    string
    Version string
    Library string
}</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="Machine">type <a href="src/pkg/debug/elf/elf.htm#L182">Machine</a></h2>
			<pre>type Machine uint16</pre>
			<p>
Machine is found in Header.Machine.
</p>


			
				<pre>const (
    EM_NONE        Machine = 0  <span class="comment">/* Unknown machine. */</span>
    EM_M32         Machine = 1  <span class="comment">/* AT&amp;T WE32100. */</span>
    EM_SPARC       Machine = 2  <span class="comment">/* Sun SPARC. */</span>
    EM_386         Machine = 3  <span class="comment">/* Intel i386. */</span>
    EM_68K         Machine = 4  <span class="comment">/* Motorola 68000. */</span>
    EM_88K         Machine = 5  <span class="comment">/* Motorola 88000. */</span>
    EM_860         Machine = 7  <span class="comment">/* Intel i860. */</span>
    EM_MIPS        Machine = 8  <span class="comment">/* MIPS R3000 Big-Endian only. */</span>
    EM_S370        Machine = 9  <span class="comment">/* IBM System/370. */</span>
    EM_MIPS_RS3_LE Machine = 10 <span class="comment">/* MIPS R3000 Little-Endian. */</span>
    EM_PARISC      Machine = 15 <span class="comment">/* HP PA-RISC. */</span>
    EM_VPP500      Machine = 17 <span class="comment">/* Fujitsu VPP500. */</span>
    EM_SPARC32PLUS Machine = 18 <span class="comment">/* SPARC v8plus. */</span>
    EM_960         Machine = 19 <span class="comment">/* Intel 80960. */</span>
    EM_PPC         Machine = 20 <span class="comment">/* PowerPC 32-bit. */</span>
    EM_PPC64       Machine = 21 <span class="comment">/* PowerPC 64-bit. */</span>
    EM_S390        Machine = 22 <span class="comment">/* IBM System/390. */</span>
    EM_V800        Machine = 36 <span class="comment">/* NEC V800. */</span>
    EM_FR20        Machine = 37 <span class="comment">/* Fujitsu FR20. */</span>
    EM_RH32        Machine = 38 <span class="comment">/* TRW RH-32. */</span>
    EM_RCE         Machine = 39 <span class="comment">/* Motorola RCE. */</span>
    EM_ARM         Machine = 40 <span class="comment">/* ARM. */</span>
    EM_SH          Machine = 42 <span class="comment">/* Hitachi SH. */</span>
    EM_SPARCV9     Machine = 43 <span class="comment">/* SPARC v9 64-bit. */</span>
    EM_TRICORE     Machine = 44 <span class="comment">/* Siemens TriCore embedded processor. */</span>
    EM_ARC         Machine = 45 <span class="comment">/* Argonaut RISC Core. */</span>
    EM_H8_300      Machine = 46 <span class="comment">/* Hitachi H8/300. */</span>
    EM_H8_300H     Machine = 47 <span class="comment">/* Hitachi H8/300H. */</span>
    EM_H8S         Machine = 48 <span class="comment">/* Hitachi H8S. */</span>
    EM_H8_500      Machine = 49 <span class="comment">/* Hitachi H8/500. */</span>
    EM_IA_64       Machine = 50 <span class="comment">/* Intel IA-64 Processor. */</span>
    EM_MIPS_X      Machine = 51 <span class="comment">/* Stanford MIPS-X. */</span>
    EM_COLDFIRE    Machine = 52 <span class="comment">/* Motorola ColdFire. */</span>
    EM_68HC12      Machine = 53 <span class="comment">/* Motorola M68HC12. */</span>
    EM_MMA         Machine = 54 <span class="comment">/* Fujitsu MMA. */</span>
    EM_PCP         Machine = 55 <span class="comment">/* Siemens PCP. */</span>
    EM_NCPU        Machine = 56 <span class="comment">/* Sony nCPU. */</span>
    EM_NDR1        Machine = 57 <span class="comment">/* Denso NDR1 microprocessor. */</span>
    EM_STARCORE    Machine = 58 <span class="comment">/* Motorola Star*Core processor. */</span>
    EM_ME16        Machine = 59 <span class="comment">/* Toyota ME16 processor. */</span>
    EM_ST100       Machine = 60 <span class="comment">/* STMicroelectronics ST100 processor. */</span>
    EM_TINYJ       Machine = 61 <span class="comment">/* Advanced Logic Corp. TinyJ processor. */</span>
    EM_X86_64      Machine = 62

    <span class="comment">/* Non-standard or deprecated. */</span>
    EM_486         Machine = 6      <span class="comment">/* Intel i486. */</span>
    EM_MIPS_RS4_BE Machine = 10     <span class="comment">/* MIPS R4000 Big-Endian */</span>
    EM_ALPHA_STD   Machine = 41     <span class="comment">/* Digital Alpha (standard value). */</span>
    EM_ALPHA       Machine = 0x9026 <span class="comment">/* Alpha (written in the absence of an ABI) */</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="Machine.GoString">func (Machine) <a href="src/pkg/debug/elf/elf.htm#L289">GoString</a></h3>
				<pre>func (i Machine) GoString() string</pre>
				
				
				
			
				
				<h3 id="Machine.String">func (Machine) <a href="src/pkg/debug/elf/elf.htm#L288">String</a></h3>
				<pre>func (i Machine) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="NType">type <a href="src/pkg/debug/elf/elf.htm#L606">NType</a></h2>
			<pre>type NType int</pre>
			<p>
NType values; used in core files.
</p>


			
				<pre>const (
    NT_PRSTATUS NType = 1 <span class="comment">/* Process status. */</span>
    NT_FPREGSET NType = 2 <span class="comment">/* Floating point registers. */</span>
    NT_PRPSINFO NType = 3 <span class="comment">/* Process state info. */</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="NType.GoString">func (NType) <a href="src/pkg/debug/elf/elf.htm#L621">GoString</a></h3>
				<pre>func (i NType) GoString() string</pre>
				
				
				
			
				
				<h3 id="NType.String">func (NType) <a href="src/pkg/debug/elf/elf.htm#L620">String</a></h3>
				<pre>func (i NType) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="OSABI">type <a href="src/pkg/debug/elf/elf.htm#L106">OSABI</a></h2>
			<pre>type OSABI byte</pre>
			<p>
OSABI is found in Header.Ident[EI_OSABI] and Header.OSABI.
</p>


			
				<pre>const (
    ELFOSABI_NONE       OSABI = 0   <span class="comment">/* UNIX System V ABI */</span>
    ELFOSABI_HPUX       OSABI = 1   <span class="comment">/* HP-UX operating system */</span>
    ELFOSABI_NETBSD     OSABI = 2   <span class="comment">/* NetBSD */</span>
    ELFOSABI_LINUX      OSABI = 3   <span class="comment">/* GNU/Linux */</span>
    ELFOSABI_HURD       OSABI = 4   <span class="comment">/* GNU/Hurd */</span>
    ELFOSABI_86OPEN     OSABI = 5   <span class="comment">/* 86Open common IA32 ABI */</span>
    ELFOSABI_SOLARIS    OSABI = 6   <span class="comment">/* Solaris */</span>
    ELFOSABI_AIX        OSABI = 7   <span class="comment">/* AIX */</span>
    ELFOSABI_IRIX       OSABI = 8   <span class="comment">/* IRIX */</span>
    ELFOSABI_FREEBSD    OSABI = 9   <span class="comment">/* FreeBSD */</span>
    ELFOSABI_TRU64      OSABI = 10  <span class="comment">/* TRU64 UNIX */</span>
    ELFOSABI_MODESTO    OSABI = 11  <span class="comment">/* Novell Modesto */</span>
    ELFOSABI_OPENBSD    OSABI = 12  <span class="comment">/* OpenBSD */</span>
    ELFOSABI_OPENVMS    OSABI = 13  <span class="comment">/* Open VMS */</span>
    ELFOSABI_NSK        OSABI = 14  <span class="comment">/* HP Non-Stop Kernel */</span>
    ELFOSABI_ARM        OSABI = 97  <span class="comment">/* ARM */</span>
    ELFOSABI_STANDALONE OSABI = 255 <span class="comment">/* Standalone (embedded) application */</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="OSABI.GoString">func (OSABI) <a href="src/pkg/debug/elf/elf.htm#L149">GoString</a></h3>
				<pre>func (i OSABI) GoString() string</pre>
				
				
				
			
				
				<h3 id="OSABI.String">func (OSABI) <a href="src/pkg/debug/elf/elf.htm#L148">String</a></h3>
				<pre>func (i OSABI) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Prog">type <a href="src/pkg/debug/elf/file.htm#L96">Prog</a></h2>
			<pre>type Prog struct {
    ProgHeader

    <span class="comment">// Embed ReaderAt for ReadAt method.</span>
    <span class="comment">// Do not embed SectionReader directly</span>
    <span class="comment">// to avoid having Read and Seek.</span>
    <span class="comment">// If a client wants Read and Seek it must use</span>
    <span class="comment">// Open() to avoid fighting over the seek offset</span>
    <span class="comment">// with other clients.</span>
    io.ReaderAt
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Prog represents a single ELF program header in an ELF binary.
</p>


			

			

			

			

			
				
				<h3 id="Prog.Open">func (*Prog) <a href="src/pkg/debug/elf/file.htm#L110">Open</a></h3>
				<pre>func (p *Prog) Open() io.ReadSeeker</pre>
				<p>
Open returns a new ReadSeeker reading the ELF program body.
</p>

				
				
			
		
			
			
			<h2 id="Prog32">type <a href="src/pkg/debug/elf/elf.htm#L1315">Prog32</a></h2>
			<pre>type Prog32 struct {
    Type   uint32 <span class="comment">/* Entry type. */</span>
    Off    uint32 <span class="comment">/* File offset of contents. */</span>
    Vaddr  uint32 <span class="comment">/* Virtual address in memory image. */</span>
    Paddr  uint32 <span class="comment">/* Physical address (not used). */</span>
    Filesz uint32 <span class="comment">/* Size of contents in file. */</span>
    Memsz  uint32 <span class="comment">/* Size of contents in memory. */</span>
    Flags  uint32 <span class="comment">/* Access permission flags. */</span>
    Align  uint32 <span class="comment">/* Alignment in memory and file. */</span>
}</pre>
			<p>
ELF32 Program header.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Prog64">type <a href="src/pkg/debug/elf/elf.htm#L1409">Prog64</a></h2>
			<pre>type Prog64 struct {
    Type   uint32 <span class="comment">/* Entry type. */</span>
    Flags  uint32 <span class="comment">/* Access permission flags. */</span>
    Off    uint64 <span class="comment">/* File offset of contents. */</span>
    Vaddr  uint64 <span class="comment">/* Virtual address in memory image. */</span>
    Paddr  uint64 <span class="comment">/* Physical address (not used). */</span>
    Filesz uint64 <span class="comment">/* Size of contents in file. */</span>
    Memsz  uint64 <span class="comment">/* Size of contents in memory. */</span>
    Align  uint64 <span class="comment">/* Alignment in memory and file. */</span>
}</pre>
			<p>
ELF64 Program header.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ProgFlag">type <a href="src/pkg/debug/elf/elf.htm#L459">ProgFlag</a></h2>
			<pre>type ProgFlag uint32</pre>
			<p>
Prog.Flag
</p>


			
				<pre>const (
    PF_X        ProgFlag = 0x1        <span class="comment">/* Executable. */</span>
    PF_W        ProgFlag = 0x2        <span class="comment">/* Writable. */</span>
    PF_R        ProgFlag = 0x4        <span class="comment">/* Readable. */</span>
    PF_MASKOS   ProgFlag = 0x0ff00000 <span class="comment">/* Operating system-specific. */</span>
    PF_MASKPROC ProgFlag = 0xf0000000 <span class="comment">/* Processor-specific. */</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="ProgFlag.GoString">func (ProgFlag) <a href="src/pkg/debug/elf/elf.htm#L476">GoString</a></h3>
				<pre>func (i ProgFlag) GoString() string</pre>
				
				
				
			
				
				<h3 id="ProgFlag.String">func (ProgFlag) <a href="src/pkg/debug/elf/elf.htm#L475">String</a></h3>
				<pre>func (i ProgFlag) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="ProgHeader">type <a href="src/pkg/debug/elf/file.htm#L84">ProgHeader</a></h2>
			<pre>type ProgHeader struct {
    Type   ProgType
    Flags  ProgFlag
    Off    uint64
    Vaddr  uint64
    Paddr  uint64
    Filesz uint64
    Memsz  uint64
    Align  uint64
}</pre>
			<p>
A ProgHeader represents a single ELF program header.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ProgType">type <a href="src/pkg/debug/elf/elf.htm#L423">ProgType</a></h2>
			<pre>type ProgType int</pre>
			<p>
Prog.Type
</p>


			
				<pre>const (
    PT_NULL    ProgType = 0          <span class="comment">/* Unused entry. */</span>
    PT_LOAD    ProgType = 1          <span class="comment">/* Loadable segment. */</span>
    PT_DYNAMIC ProgType = 2          <span class="comment">/* Dynamic linking information segment. */</span>
    PT_INTERP  ProgType = 3          <span class="comment">/* Pathname of interpreter. */</span>
    PT_NOTE    ProgType = 4          <span class="comment">/* Auxiliary information. */</span>
    PT_SHLIB   ProgType = 5          <span class="comment">/* Reserved (not used). */</span>
    PT_PHDR    ProgType = 6          <span class="comment">/* Location of program header itself. */</span>
    PT_TLS     ProgType = 7          <span class="comment">/* Thread local storage segment */</span>
    PT_LOOS    ProgType = 0x60000000 <span class="comment">/* First OS-specific. */</span>
    PT_HIOS    ProgType = 0x6fffffff <span class="comment">/* Last OS-specific. */</span>
    PT_LOPROC  ProgType = 0x70000000 <span class="comment">/* First processor-specific type. */</span>
    PT_HIPROC  ProgType = 0x7fffffff <span class="comment">/* Last processor-specific type. */</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="ProgType.GoString">func (ProgType) <a href="src/pkg/debug/elf/elf.htm#L456">GoString</a></h3>
				<pre>func (i ProgType) GoString() string</pre>
				
				
				
			
				
				<h3 id="ProgType.String">func (ProgType) <a href="src/pkg/debug/elf/elf.htm#L455">String</a></h3>
				<pre>func (i ProgType) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="R_386">type <a href="src/pkg/debug/elf/elf.htm#L914">R_386</a></h2>
			<pre>type R_386 int</pre>
			<p>
Relocation types for 386.
</p>


			
				<pre>const (
    R_386_NONE         R_386 = 0  <span class="comment">/* No relocation. */</span>
    R_386_32           R_386 = 1  <span class="comment">/* Add symbol value. */</span>
    R_386_PC32         R_386 = 2  <span class="comment">/* Add PC-relative symbol value. */</span>
    R_386_GOT32        R_386 = 3  <span class="comment">/* Add PC-relative GOT offset. */</span>
    R_386_PLT32        R_386 = 4  <span class="comment">/* Add PC-relative PLT offset. */</span>
    R_386_COPY         R_386 = 5  <span class="comment">/* Copy data from shared object. */</span>
    R_386_GLOB_DAT     R_386 = 6  <span class="comment">/* Set GOT entry to data address. */</span>
    R_386_JMP_SLOT     R_386 = 7  <span class="comment">/* Set GOT entry to code address. */</span>
    R_386_RELATIVE     R_386 = 8  <span class="comment">/* Add load address of shared object. */</span>
    R_386_GOTOFF       R_386 = 9  <span class="comment">/* Add GOT-relative symbol address. */</span>
    R_386_GOTPC        R_386 = 10 <span class="comment">/* Add PC-relative GOT table address. */</span>
    R_386_TLS_TPOFF    R_386 = 14 <span class="comment">/* Negative offset in static TLS block */</span>
    R_386_TLS_IE       R_386 = 15 <span class="comment">/* Absolute address of GOT for -ve static TLS */</span>
    R_386_TLS_GOTIE    R_386 = 16 <span class="comment">/* GOT entry for negative static TLS block */</span>
    R_386_TLS_LE       R_386 = 17 <span class="comment">/* Negative offset relative to static TLS */</span>
    R_386_TLS_GD       R_386 = 18 <span class="comment">/* 32 bit offset to GOT (index,off) pair */</span>
    R_386_TLS_LDM      R_386 = 19 <span class="comment">/* 32 bit offset to GOT (index,zero) pair */</span>
    R_386_TLS_GD_32    R_386 = 24 <span class="comment">/* 32 bit offset to GOT (index,off) pair */</span>
    R_386_TLS_GD_PUSH  R_386 = 25 <span class="comment">/* pushl instruction for Sun ABI GD sequence */</span>
    R_386_TLS_GD_CALL  R_386 = 26 <span class="comment">/* call instruction for Sun ABI GD sequence */</span>
    R_386_TLS_GD_POP   R_386 = 27 <span class="comment">/* popl instruction for Sun ABI GD sequence */</span>
    R_386_TLS_LDM_32   R_386 = 28 <span class="comment">/* 32 bit offset to GOT (index,zero) pair */</span>
    R_386_TLS_LDM_PUSH R_386 = 29 <span class="comment">/* pushl instruction for Sun ABI LD sequence */</span>
    R_386_TLS_LDM_CALL R_386 = 30 <span class="comment">/* call instruction for Sun ABI LD sequence */</span>
    R_386_TLS_LDM_POP  R_386 = 31 <span class="comment">/* popl instruction for Sun ABI LD sequence */</span>
    R_386_TLS_LDO_32   R_386 = 32 <span class="comment">/* 32 bit offset from start of TLS block */</span>
    R_386_TLS_IE_32    R_386 = 33 <span class="comment">/* 32 bit offset to GOT static TLS offset entry */</span>
    R_386_TLS_LE_32    R_386 = 34 <span class="comment">/* 32 bit offset within static TLS block */</span>
    R_386_TLS_DTPMOD32 R_386 = 35 <span class="comment">/* GOT entry containing TLS index */</span>
    R_386_TLS_DTPOFF32 R_386 = 36 <span class="comment">/* GOT entry containing TLS offset */</span>
    R_386_TLS_TPOFF32  R_386 = 37 <span class="comment">/* GOT entry of -ve static TLS offset */</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="R_386.GoString">func (R_386) <a href="src/pkg/debug/elf/elf.htm#L985">GoString</a></h3>
				<pre>func (i R_386) GoString() string</pre>
				
				
				
			
				
				<h3 id="R_386.String">func (R_386) <a href="src/pkg/debug/elf/elf.htm#L984">String</a></h3>
				<pre>func (i R_386) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="R_ALPHA">type <a href="src/pkg/debug/elf/elf.htm#L768">R_ALPHA</a></h2>
			<pre>type R_ALPHA int</pre>
			<p>
Relocation types for Alpha.
</p>


			
				<pre>const (
    R_ALPHA_NONE           R_ALPHA = 0  <span class="comment">/* No reloc */</span>
    R_ALPHA_REFLONG        R_ALPHA = 1  <span class="comment">/* Direct 32 bit */</span>
    R_ALPHA_REFQUAD        R_ALPHA = 2  <span class="comment">/* Direct 64 bit */</span>
    R_ALPHA_GPREL32        R_ALPHA = 3  <span class="comment">/* GP relative 32 bit */</span>
    R_ALPHA_LITERAL        R_ALPHA = 4  <span class="comment">/* GP relative 16 bit w/optimization */</span>
    R_ALPHA_LITUSE         R_ALPHA = 5  <span class="comment">/* Optimization hint for LITERAL */</span>
    R_ALPHA_GPDISP         R_ALPHA = 6  <span class="comment">/* Add displacement to GP */</span>
    R_ALPHA_BRADDR         R_ALPHA = 7  <span class="comment">/* PC+4 relative 23 bit shifted */</span>
    R_ALPHA_HINT           R_ALPHA = 8  <span class="comment">/* PC+4 relative 16 bit shifted */</span>
    R_ALPHA_SREL16         R_ALPHA = 9  <span class="comment">/* PC relative 16 bit */</span>
    R_ALPHA_SREL32         R_ALPHA = 10 <span class="comment">/* PC relative 32 bit */</span>
    R_ALPHA_SREL64         R_ALPHA = 11 <span class="comment">/* PC relative 64 bit */</span>
    R_ALPHA_OP_PUSH        R_ALPHA = 12 <span class="comment">/* OP stack push */</span>
    R_ALPHA_OP_STORE       R_ALPHA = 13 <span class="comment">/* OP stack pop and store */</span>
    R_ALPHA_OP_PSUB        R_ALPHA = 14 <span class="comment">/* OP stack subtract */</span>
    R_ALPHA_OP_PRSHIFT     R_ALPHA = 15 <span class="comment">/* OP stack right shift */</span>
    R_ALPHA_GPVALUE        R_ALPHA = 16
    R_ALPHA_GPRELHIGH      R_ALPHA = 17
    R_ALPHA_GPRELLOW       R_ALPHA = 18
    R_ALPHA_IMMED_GP_16    R_ALPHA = 19
    R_ALPHA_IMMED_GP_HI32  R_ALPHA = 20
    R_ALPHA_IMMED_SCN_HI32 R_ALPHA = 21
    R_ALPHA_IMMED_BR_HI32  R_ALPHA = 22
    R_ALPHA_IMMED_LO32     R_ALPHA = 23
    R_ALPHA_COPY           R_ALPHA = 24 <span class="comment">/* Copy symbol at runtime */</span>
    R_ALPHA_GLOB_DAT       R_ALPHA = 25 <span class="comment">/* Create GOT entry */</span>
    R_ALPHA_JMP_SLOT       R_ALPHA = 26 <span class="comment">/* Create PLT entry */</span>
    R_ALPHA_RELATIVE       R_ALPHA = 27 <span class="comment">/* Adjust by program base */</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="R_ALPHA.GoString">func (R_ALPHA) <a href="src/pkg/debug/elf/elf.htm#L833">GoString</a></h3>
				<pre>func (i R_ALPHA) GoString() string</pre>
				
				
				
			
				
				<h3 id="R_ALPHA.String">func (R_ALPHA) <a href="src/pkg/debug/elf/elf.htm#L832">String</a></h3>
				<pre>func (i R_ALPHA) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="R_ARM">type <a href="src/pkg/debug/elf/elf.htm#L836">R_ARM</a></h2>
			<pre>type R_ARM int</pre>
			<p>
Relocation types for ARM.
</p>


			
				<pre>const (
    R_ARM_NONE          R_ARM = 0 <span class="comment">/* No relocation. */</span>
    R_ARM_PC24          R_ARM = 1
    R_ARM_ABS32         R_ARM = 2
    R_ARM_REL32         R_ARM = 3
    R_ARM_PC13          R_ARM = 4
    R_ARM_ABS16         R_ARM = 5
    R_ARM_ABS12         R_ARM = 6
    R_ARM_THM_ABS5      R_ARM = 7
    R_ARM_ABS8          R_ARM = 8
    R_ARM_SBREL32       R_ARM = 9
    R_ARM_THM_PC22      R_ARM = 10
    R_ARM_THM_PC8       R_ARM = 11
    R_ARM_AMP_VCALL9    R_ARM = 12
    R_ARM_SWI24         R_ARM = 13
    R_ARM_THM_SWI8      R_ARM = 14
    R_ARM_XPC25         R_ARM = 15
    R_ARM_THM_XPC22     R_ARM = 16
    R_ARM_COPY          R_ARM = 20 <span class="comment">/* Copy data from shared object. */</span>
    R_ARM_GLOB_DAT      R_ARM = 21 <span class="comment">/* Set GOT entry to data address. */</span>
    R_ARM_JUMP_SLOT     R_ARM = 22 <span class="comment">/* Set GOT entry to code address. */</span>
    R_ARM_RELATIVE      R_ARM = 23 <span class="comment">/* Add load address of shared object. */</span>
    R_ARM_GOTOFF        R_ARM = 24 <span class="comment">/* Add GOT-relative symbol address. */</span>
    R_ARM_GOTPC         R_ARM = 25 <span class="comment">/* Add PC-relative GOT table address. */</span>
    R_ARM_GOT32         R_ARM = 26 <span class="comment">/* Add PC-relative GOT offset. */</span>
    R_ARM_PLT32         R_ARM = 27 <span class="comment">/* Add PC-relative PLT offset. */</span>
    R_ARM_GNU_VTENTRY   R_ARM = 100
    R_ARM_GNU_VTINHERIT R_ARM = 101
    R_ARM_RSBREL32      R_ARM = 250
    R_ARM_THM_RPC22     R_ARM = 251
    R_ARM_RREL32        R_ARM = 252
    R_ARM_RABS32        R_ARM = 253
    R_ARM_RPC24         R_ARM = 254
    R_ARM_RBASE         R_ARM = 255
)</pre>
				
			

			

			

			

			
				
				<h3 id="R_ARM.GoString">func (R_ARM) <a href="src/pkg/debug/elf/elf.htm#L911">GoString</a></h3>
				<pre>func (i R_ARM) GoString() string</pre>
				
				
				
			
				
				<h3 id="R_ARM.String">func (R_ARM) <a href="src/pkg/debug/elf/elf.htm#L910">String</a></h3>
				<pre>func (i R_ARM) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="R_PPC">type <a href="src/pkg/debug/elf/elf.htm#L988">R_PPC</a></h2>
			<pre>type R_PPC int</pre>
			<p>
Relocation types for PowerPC.
</p>


			
				<pre>const (
    R_PPC_NONE            R_PPC = 0 <span class="comment">/* No relocation. */</span>
    R_PPC_ADDR32          R_PPC = 1
    R_PPC_ADDR24          R_PPC = 2
    R_PPC_ADDR16          R_PPC = 3
    R_PPC_ADDR16_LO       R_PPC = 4
    R_PPC_ADDR16_HI       R_PPC = 5
    R_PPC_ADDR16_HA       R_PPC = 6
    R_PPC_ADDR14          R_PPC = 7
    R_PPC_ADDR14_BRTAKEN  R_PPC = 8
    R_PPC_ADDR14_BRNTAKEN R_PPC = 9
    R_PPC_REL24           R_PPC = 10
    R_PPC_REL14           R_PPC = 11
    R_PPC_REL14_BRTAKEN   R_PPC = 12
    R_PPC_REL14_BRNTAKEN  R_PPC = 13
    R_PPC_GOT16           R_PPC = 14
    R_PPC_GOT16_LO        R_PPC = 15
    R_PPC_GOT16_HI        R_PPC = 16
    R_PPC_GOT16_HA        R_PPC = 17
    R_PPC_PLTREL24        R_PPC = 18
    R_PPC_COPY            R_PPC = 19
    R_PPC_GLOB_DAT        R_PPC = 20
    R_PPC_JMP_SLOT        R_PPC = 21
    R_PPC_RELATIVE        R_PPC = 22
    R_PPC_LOCAL24PC       R_PPC = 23
    R_PPC_UADDR32         R_PPC = 24
    R_PPC_UADDR16         R_PPC = 25
    R_PPC_REL32           R_PPC = 26
    R_PPC_PLT32           R_PPC = 27
    R_PPC_PLTREL32        R_PPC = 28
    R_PPC_PLT16_LO        R_PPC = 29
    R_PPC_PLT16_HI        R_PPC = 30
    R_PPC_PLT16_HA        R_PPC = 31
    R_PPC_SDAREL16        R_PPC = 32
    R_PPC_SECTOFF         R_PPC = 33
    R_PPC_SECTOFF_LO      R_PPC = 34
    R_PPC_SECTOFF_HI      R_PPC = 35
    R_PPC_SECTOFF_HA      R_PPC = 36
    R_PPC_TLS             R_PPC = 67
    R_PPC_DTPMOD32        R_PPC = 68
    R_PPC_TPREL16         R_PPC = 69
    R_PPC_TPREL16_LO      R_PPC = 70
    R_PPC_TPREL16_HI      R_PPC = 71
    R_PPC_TPREL16_HA      R_PPC = 72
    R_PPC_TPREL32         R_PPC = 73
    R_PPC_DTPREL16        R_PPC = 74
    R_PPC_DTPREL16_LO     R_PPC = 75
    R_PPC_DTPREL16_HI     R_PPC = 76
    R_PPC_DTPREL16_HA     R_PPC = 77
    R_PPC_DTPREL32        R_PPC = 78
    R_PPC_GOT_TLSGD16     R_PPC = 79
    R_PPC_GOT_TLSGD16_LO  R_PPC = 80
    R_PPC_GOT_TLSGD16_HI  R_PPC = 81
    R_PPC_GOT_TLSGD16_HA  R_PPC = 82
    R_PPC_GOT_TLSLD16     R_PPC = 83
    R_PPC_GOT_TLSLD16_LO  R_PPC = 84
    R_PPC_GOT_TLSLD16_HI  R_PPC = 85
    R_PPC_GOT_TLSLD16_HA  R_PPC = 86
    R_PPC_GOT_TPREL16     R_PPC = 87
    R_PPC_GOT_TPREL16_LO  R_PPC = 88
    R_PPC_GOT_TPREL16_HI  R_PPC = 89
    R_PPC_GOT_TPREL16_HA  R_PPC = 90
    R_PPC_EMB_NADDR32     R_PPC = 101
    R_PPC_EMB_NADDR16     R_PPC = 102
    R_PPC_EMB_NADDR16_LO  R_PPC = 103
    R_PPC_EMB_NADDR16_HI  R_PPC = 104
    R_PPC_EMB_NADDR16_HA  R_PPC = 105
    R_PPC_EMB_SDAI16      R_PPC = 106
    R_PPC_EMB_SDA2I16     R_PPC = 107
    R_PPC_EMB_SDA2REL     R_PPC = 108
    R_PPC_EMB_SDA21       R_PPC = 109
    R_PPC_EMB_MRKREF      R_PPC = 110
    R_PPC_EMB_RELSEC16    R_PPC = 111
    R_PPC_EMB_RELST_LO    R_PPC = 112
    R_PPC_EMB_RELST_HI    R_PPC = 113
    R_PPC_EMB_RELST_HA    R_PPC = 114
    R_PPC_EMB_BIT_FLD     R_PPC = 115
    R_PPC_EMB_RELSDA      R_PPC = 116
)</pre>
				
			

			

			

			

			
				
				<h3 id="R_PPC.GoString">func (R_PPC) <a href="src/pkg/debug/elf/elf.htm#L1153">GoString</a></h3>
				<pre>func (i R_PPC) GoString() string</pre>
				
				
				
			
				
				<h3 id="R_PPC.String">func (R_PPC) <a href="src/pkg/debug/elf/elf.htm#L1152">String</a></h3>
				<pre>func (i R_PPC) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="R_SPARC">type <a href="src/pkg/debug/elf/elf.htm#L1156">R_SPARC</a></h2>
			<pre>type R_SPARC int</pre>
			<p>
Relocation types for SPARC.
</p>


			
				<pre>const (
    R_SPARC_NONE     R_SPARC = 0
    R_SPARC_8        R_SPARC = 1
    R_SPARC_16       R_SPARC = 2
    R_SPARC_32       R_SPARC = 3
    R_SPARC_DISP8    R_SPARC = 4
    R_SPARC_DISP16   R_SPARC = 5
    R_SPARC_DISP32   R_SPARC = 6
    R_SPARC_WDISP30  R_SPARC = 7
    R_SPARC_WDISP22  R_SPARC = 8
    R_SPARC_HI22     R_SPARC = 9
    R_SPARC_22       R_SPARC = 10
    R_SPARC_13       R_SPARC = 11
    R_SPARC_LO10     R_SPARC = 12
    R_SPARC_GOT10    R_SPARC = 13
    R_SPARC_GOT13    R_SPARC = 14
    R_SPARC_GOT22    R_SPARC = 15
    R_SPARC_PC10     R_SPARC = 16
    R_SPARC_PC22     R_SPARC = 17
    R_SPARC_WPLT30   R_SPARC = 18
    R_SPARC_COPY     R_SPARC = 19
    R_SPARC_GLOB_DAT R_SPARC = 20
    R_SPARC_JMP_SLOT R_SPARC = 21
    R_SPARC_RELATIVE R_SPARC = 22
    R_SPARC_UA32     R_SPARC = 23
    R_SPARC_PLT32    R_SPARC = 24
    R_SPARC_HIPLT22  R_SPARC = 25
    R_SPARC_LOPLT10  R_SPARC = 26
    R_SPARC_PCPLT32  R_SPARC = 27
    R_SPARC_PCPLT22  R_SPARC = 28
    R_SPARC_PCPLT10  R_SPARC = 29
    R_SPARC_10       R_SPARC = 30
    R_SPARC_11       R_SPARC = 31
    R_SPARC_64       R_SPARC = 32
    R_SPARC_OLO10    R_SPARC = 33
    R_SPARC_HH22     R_SPARC = 34
    R_SPARC_HM10     R_SPARC = 35
    R_SPARC_LM22     R_SPARC = 36
    R_SPARC_PC_HH22  R_SPARC = 37
    R_SPARC_PC_HM10  R_SPARC = 38
    R_SPARC_PC_LM22  R_SPARC = 39
    R_SPARC_WDISP16  R_SPARC = 40
    R_SPARC_WDISP19  R_SPARC = 41
    R_SPARC_GLOB_JMP R_SPARC = 42
    R_SPARC_7        R_SPARC = 43
    R_SPARC_5        R_SPARC = 44
    R_SPARC_6        R_SPARC = 45
    R_SPARC_DISP64   R_SPARC = 46
    R_SPARC_PLT64    R_SPARC = 47
    R_SPARC_HIX22    R_SPARC = 48
    R_SPARC_LOX10    R_SPARC = 49
    R_SPARC_H44      R_SPARC = 50
    R_SPARC_M44      R_SPARC = 51
    R_SPARC_L44      R_SPARC = 52
    R_SPARC_REGISTER R_SPARC = 53
    R_SPARC_UA64     R_SPARC = 54
    R_SPARC_UA16     R_SPARC = 55
)</pre>
				
			

			

			

			

			
				
				<h3 id="R_SPARC.GoString">func (R_SPARC) <a href="src/pkg/debug/elf/elf.htm#L1277">GoString</a></h3>
				<pre>func (i R_SPARC) GoString() string</pre>
				
				
				
			
				
				<h3 id="R_SPARC.String">func (R_SPARC) <a href="src/pkg/debug/elf/elf.htm#L1276">String</a></h3>
				<pre>func (i R_SPARC) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="R_X86_64">type <a href="src/pkg/debug/elf/elf.htm#L708">R_X86_64</a></h2>
			<pre>type R_X86_64 int</pre>
			<p>
Relocation types for x86-64.
</p>


			
				<pre>const (
    R_X86_64_NONE     R_X86_64 = 0  <span class="comment">/* No relocation. */</span>
    R_X86_64_64       R_X86_64 = 1  <span class="comment">/* Add 64 bit symbol value. */</span>
    R_X86_64_PC32     R_X86_64 = 2  <span class="comment">/* PC-relative 32 bit signed sym value. */</span>
    R_X86_64_GOT32    R_X86_64 = 3  <span class="comment">/* PC-relative 32 bit GOT offset. */</span>
    R_X86_64_PLT32    R_X86_64 = 4  <span class="comment">/* PC-relative 32 bit PLT offset. */</span>
    R_X86_64_COPY     R_X86_64 = 5  <span class="comment">/* Copy data from shared object. */</span>
    R_X86_64_GLOB_DAT R_X86_64 = 6  <span class="comment">/* Set GOT entry to data address. */</span>
    R_X86_64_JMP_SLOT R_X86_64 = 7  <span class="comment">/* Set GOT entry to code address. */</span>
    R_X86_64_RELATIVE R_X86_64 = 8  <span class="comment">/* Add load address of shared object. */</span>
    R_X86_64_GOTPCREL R_X86_64 = 9  <span class="comment">/* Add 32 bit signed pcrel offset to GOT. */</span>
    R_X86_64_32       R_X86_64 = 10 <span class="comment">/* Add 32 bit zero extended symbol value */</span>
    R_X86_64_32S      R_X86_64 = 11 <span class="comment">/* Add 32 bit sign extended symbol value */</span>
    R_X86_64_16       R_X86_64 = 12 <span class="comment">/* Add 16 bit zero extended symbol value */</span>
    R_X86_64_PC16     R_X86_64 = 13 <span class="comment">/* Add 16 bit signed extended pc relative symbol value */</span>
    R_X86_64_8        R_X86_64 = 14 <span class="comment">/* Add 8 bit zero extended symbol value */</span>
    R_X86_64_PC8      R_X86_64 = 15 <span class="comment">/* Add 8 bit signed extended pc relative symbol value */</span>
    R_X86_64_DTPMOD64 R_X86_64 = 16 <span class="comment">/* ID of module containing symbol */</span>
    R_X86_64_DTPOFF64 R_X86_64 = 17 <span class="comment">/* Offset in TLS block */</span>
    R_X86_64_TPOFF64  R_X86_64 = 18 <span class="comment">/* Offset in static TLS block */</span>
    R_X86_64_TLSGD    R_X86_64 = 19 <span class="comment">/* PC relative offset to GD GOT entry */</span>
    R_X86_64_TLSLD    R_X86_64 = 20 <span class="comment">/* PC relative offset to LD GOT entry */</span>
    R_X86_64_DTPOFF32 R_X86_64 = 21 <span class="comment">/* Offset in TLS block */</span>
    R_X86_64_GOTTPOFF R_X86_64 = 22 <span class="comment">/* PC relative offset to IE GOT entry */</span>
    R_X86_64_TPOFF32  R_X86_64 = 23 <span class="comment">/* Offset in static TLS block */</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="R_X86_64.GoString">func (R_X86_64) <a href="src/pkg/debug/elf/elf.htm#L765">GoString</a></h3>
				<pre>func (i R_X86_64) GoString() string</pre>
				
				
				
			
				
				<h3 id="R_X86_64.String">func (R_X86_64) <a href="src/pkg/debug/elf/elf.htm#L764">String</a></h3>
				<pre>func (i R_X86_64) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Rel32">type <a href="src/pkg/debug/elf/elf.htm#L1337">Rel32</a></h2>
			<pre>type Rel32 struct {
    Off  uint32 <span class="comment">/* Location to be relocated. */</span>
    Info uint32 <span class="comment">/* Relocation type and symbol index. */</span>
}</pre>
			<p>
ELF32 Relocations that don&#39;t need an addend field.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Rel64">type <a href="src/pkg/debug/elf/elf.htm#L1431">Rel64</a></h2>
			<pre>type Rel64 struct {
    Off  uint64 <span class="comment">/* Location to be relocated. */</span>
    Info uint64 <span class="comment">/* Relocation type and symbol index. */</span>
}</pre>
			<p>
ELF64 relocations that don&#39;t need an addend field.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Rela32">type <a href="src/pkg/debug/elf/elf.htm#L1343">Rela32</a></h2>
			<pre>type Rela32 struct {
    Off    uint32 <span class="comment">/* Location to be relocated. */</span>
    Info   uint32 <span class="comment">/* Relocation type and symbol index. */</span>
    Addend int32  <span class="comment">/* Addend. */</span>
}</pre>
			<p>
ELF32 Relocations that need an addend field.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Rela64">type <a href="src/pkg/debug/elf/elf.htm#L1437">Rela64</a></h2>
			<pre>type Rela64 struct {
    Off    uint64 <span class="comment">/* Location to be relocated. */</span>
    Info   uint64 <span class="comment">/* Relocation type and symbol index. */</span>
    Addend int64  <span class="comment">/* Addend. */</span>
}</pre>
			<p>
ELF64 relocations that need an addend field.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Section">type <a href="src/pkg/debug/elf/file.htm#L51">Section</a></h2>
			<pre>type Section struct {
    SectionHeader

    <span class="comment">// Embed ReaderAt for ReadAt method.</span>
    <span class="comment">// Do not embed SectionReader directly</span>
    <span class="comment">// to avoid having Read and Seek.</span>
    <span class="comment">// If a client wants Read and Seek it must use</span>
    <span class="comment">// Open() to avoid fighting over the seek offset</span>
    <span class="comment">// with other clients.</span>
    io.ReaderAt
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
A Section represents a single section in an ELF file.
</p>


			

			

			

			

			
				
				<h3 id="Section.Data">func (*Section) <a href="src/pkg/debug/elf/file.htm#L65">Data</a></h3>
				<pre>func (s *Section) Data() ([]byte, error)</pre>
				<p>
Data reads and returns the contents of the ELF section.
</p>

				
				
			
				
				<h3 id="Section.Open">func (*Section) <a href="src/pkg/debug/elf/file.htm#L81">Open</a></h3>
				<pre>func (s *Section) Open() io.ReadSeeker</pre>
				<p>
Open returns a new ReadSeeker reading the ELF section.
</p>

				
				
			
		
			
			
			<h2 id="Section32">type <a href="src/pkg/debug/elf/elf.htm#L1301">Section32</a></h2>
			<pre>type Section32 struct {
    Name      uint32 <span class="comment">/* Section name (index into the section header string table). */</span>
    Type      uint32 <span class="comment">/* Section type. */</span>
    Flags     uint32 <span class="comment">/* Section flags. */</span>
    Addr      uint32 <span class="comment">/* Address in memory image. */</span>
    Off       uint32 <span class="comment">/* Offset in file. */</span>
    Size      uint32 <span class="comment">/* Size in bytes. */</span>
    Link      uint32 <span class="comment">/* Index of a related section. */</span>
    Info      uint32 <span class="comment">/* Depends on section type. */</span>
    Addralign uint32 <span class="comment">/* Alignment in bytes. */</span>
    Entsize   uint32 <span class="comment">/* Size of each entry in section. */</span>
}</pre>
			<p>
ELF32 Section header.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Section64">type <a href="src/pkg/debug/elf/elf.htm#L1395">Section64</a></h2>
			<pre>type Section64 struct {
    Name      uint32 <span class="comment">/* Section name (index into the section header string table). */</span>
    Type      uint32 <span class="comment">/* Section type. */</span>
    Flags     uint64 <span class="comment">/* Section flags. */</span>
    Addr      uint64 <span class="comment">/* Address in memory image. */</span>
    Off       uint64 <span class="comment">/* Offset in file. */</span>
    Size      uint64 <span class="comment">/* Size in bytes. */</span>
    Link      uint32 <span class="comment">/* Index of a related section. */</span>
    Info      uint32 <span class="comment">/* Depends on section type. */</span>
    Addralign uint64 <span class="comment">/* Alignment in bytes. */</span>
    Entsize   uint64 <span class="comment">/* Size of each entry in section. */</span>
}</pre>
			<p>
ELF64 Section header.
</p>


			

			

			

			

			
		
			
			
			<h2 id="SectionFlag">type <a href="src/pkg/debug/elf/elf.htm#L389">SectionFlag</a></h2>
			<pre>type SectionFlag uint32</pre>
			<p>
Section flags.
</p>


			
				<pre>const (
    SHF_WRITE            SectionFlag = 0x1        <span class="comment">/* Section contains writable data. */</span>
    SHF_ALLOC            SectionFlag = 0x2        <span class="comment">/* Section occupies memory. */</span>
    SHF_EXECINSTR        SectionFlag = 0x4        <span class="comment">/* Section contains instructions. */</span>
    SHF_MERGE            SectionFlag = 0x10       <span class="comment">/* Section may be merged. */</span>
    SHF_STRINGS          SectionFlag = 0x20       <span class="comment">/* Section contains strings. */</span>
    SHF_INFO_LINK        SectionFlag = 0x40       <span class="comment">/* sh_info holds section index. */</span>
    SHF_LINK_ORDER       SectionFlag = 0x80       <span class="comment">/* Special ordering requirements. */</span>
    SHF_OS_NONCONFORMING SectionFlag = 0x100      <span class="comment">/* OS-specific processing required. */</span>
    SHF_GROUP            SectionFlag = 0x200      <span class="comment">/* Member of section group. */</span>
    SHF_TLS              SectionFlag = 0x400      <span class="comment">/* Section contains TLS data. */</span>
    SHF_MASKOS           SectionFlag = 0x0ff00000 <span class="comment">/* OS-specific semantics. */</span>
    SHF_MASKPROC         SectionFlag = 0xf0000000 <span class="comment">/* Processor-specific semantics. */</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="SectionFlag.GoString">func (SectionFlag) <a href="src/pkg/debug/elf/elf.htm#L420">GoString</a></h3>
				<pre>func (i SectionFlag) GoString() string</pre>
				
				
				
			
				
				<h3 id="SectionFlag.String">func (SectionFlag) <a href="src/pkg/debug/elf/elf.htm#L419">String</a></h3>
				<pre>func (i SectionFlag) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="SectionHeader">type <a href="src/pkg/debug/elf/file.htm#L37">SectionHeader</a></h2>
			<pre>type SectionHeader struct {
    Name      string
    Type      SectionType
    Flags     SectionFlag
    Addr      uint64
    Offset    uint64
    Size      uint64
    Link      uint32
    Info      uint32
    Addralign uint64
    Entsize   uint64
}</pre>
			<p>
A SectionHeader represents a single ELF section header.
</p>


			

			

			

			

			
		
			
			
			<h2 id="SectionIndex">type <a href="src/pkg/debug/elf/elf.htm#L292">SectionIndex</a></h2>
			<pre>type SectionIndex int</pre>
			<p>
Special section indices.
</p>


			
				<pre>const (
    SHN_UNDEF     SectionIndex = 0      <span class="comment">/* Undefined, missing, irrelevant. */</span>
    SHN_LORESERVE SectionIndex = 0xff00 <span class="comment">/* First of reserved range. */</span>
    SHN_LOPROC    SectionIndex = 0xff00 <span class="comment">/* First processor-specific. */</span>
    SHN_HIPROC    SectionIndex = 0xff1f <span class="comment">/* Last processor-specific. */</span>
    SHN_LOOS      SectionIndex = 0xff20 <span class="comment">/* First operating system-specific. */</span>
    SHN_HIOS      SectionIndex = 0xff3f <span class="comment">/* Last operating system-specific. */</span>
    SHN_ABS       SectionIndex = 0xfff1 <span class="comment">/* Absolute values. */</span>
    SHN_COMMON    SectionIndex = 0xfff2 <span class="comment">/* Common data. */</span>
    SHN_XINDEX    SectionIndex = 0xffff <span class="comment">/* Escape -- index stored elsewhere. */</span>
    SHN_HIRESERVE SectionIndex = 0xffff <span class="comment">/* Last of reserved range. */</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="SectionIndex.GoString">func (SectionIndex) <a href="src/pkg/debug/elf/elf.htm#L317">GoString</a></h3>
				<pre>func (i SectionIndex) GoString() string</pre>
				
				
				
			
				
				<h3 id="SectionIndex.String">func (SectionIndex) <a href="src/pkg/debug/elf/elf.htm#L316">String</a></h3>
				<pre>func (i SectionIndex) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="SectionType">type <a href="src/pkg/debug/elf/elf.htm#L320">SectionType</a></h2>
			<pre>type SectionType uint32</pre>
			<p>
Section type.
</p>


			
				<pre>const (
    SHT_NULL           SectionType = 0          <span class="comment">/* inactive */</span>
    SHT_PROGBITS       SectionType = 1          <span class="comment">/* program defined information */</span>
    SHT_SYMTAB         SectionType = 2          <span class="comment">/* symbol table section */</span>
    SHT_STRTAB         SectionType = 3          <span class="comment">/* string table section */</span>
    SHT_RELA           SectionType = 4          <span class="comment">/* relocation section with addends */</span>
    SHT_HASH           SectionType = 5          <span class="comment">/* symbol hash table section */</span>
    SHT_DYNAMIC        SectionType = 6          <span class="comment">/* dynamic section */</span>
    SHT_NOTE           SectionType = 7          <span class="comment">/* note section */</span>
    SHT_NOBITS         SectionType = 8          <span class="comment">/* no space section */</span>
    SHT_REL            SectionType = 9          <span class="comment">/* relocation section - no addends */</span>
    SHT_SHLIB          SectionType = 10         <span class="comment">/* reserved - purpose unknown */</span>
    SHT_DYNSYM         SectionType = 11         <span class="comment">/* dynamic symbol table section */</span>
    SHT_INIT_ARRAY     SectionType = 14         <span class="comment">/* Initialization function pointers. */</span>
    SHT_FINI_ARRAY     SectionType = 15         <span class="comment">/* Termination function pointers. */</span>
    SHT_PREINIT_ARRAY  SectionType = 16         <span class="comment">/* Pre-initialization function ptrs. */</span>
    SHT_GROUP          SectionType = 17         <span class="comment">/* Section group. */</span>
    SHT_SYMTAB_SHNDX   SectionType = 18         <span class="comment">/* Section indexes (see SHN_XINDEX). */</span>
    SHT_LOOS           SectionType = 0x60000000 <span class="comment">/* First of OS specific semantics */</span>
    SHT_GNU_ATTRIBUTES SectionType = 0x6ffffff5 <span class="comment">/* GNU object attributes */</span>
    SHT_GNU_HASH       SectionType = 0x6ffffff6 <span class="comment">/* GNU hash table */</span>
    SHT_GNU_LIBLIST    SectionType = 0x6ffffff7 <span class="comment">/* GNU prelink library list */</span>
    SHT_GNU_VERDEF     SectionType = 0x6ffffffd <span class="comment">/* GNU version definition section */</span>
    SHT_GNU_VERNEED    SectionType = 0x6ffffffe <span class="comment">/* GNU version needs section */</span>
    SHT_GNU_VERSYM     SectionType = 0x6fffffff <span class="comment">/* GNU version symbol table */</span>
    SHT_HIOS           SectionType = 0x6fffffff <span class="comment">/* Last of OS specific semantics */</span>
    SHT_LOPROC         SectionType = 0x70000000 <span class="comment">/* reserved range for processor */</span>
    SHT_HIPROC         SectionType = 0x7fffffff <span class="comment">/* specific section header types */</span>
    SHT_LOUSER         SectionType = 0x80000000 <span class="comment">/* reserved range for application */</span>
    SHT_HIUSER         SectionType = 0xffffffff <span class="comment">/* specific indexes */</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="SectionType.GoString">func (SectionType) <a href="src/pkg/debug/elf/elf.htm#L386">GoString</a></h3>
				<pre>func (i SectionType) GoString() string</pre>
				
				
				
			
				
				<h3 id="SectionType.String">func (SectionType) <a href="src/pkg/debug/elf/elf.htm#L385">String</a></h3>
				<pre>func (i SectionType) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Sym32">type <a href="src/pkg/debug/elf/elf.htm#L1354">Sym32</a></h2>
			<pre>type Sym32 struct {
    Name  uint32
    Value uint32
    Size  uint32
    Info  uint8
    Other uint8
    Shndx uint16
}</pre>
			<p>
ELF32 Symbol.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Sym64">type <a href="src/pkg/debug/elf/elf.htm#L1448">Sym64</a></h2>
			<pre>type Sym64 struct {
    Name  uint32 <span class="comment">/* String table index of name. */</span>
    Info  uint8  <span class="comment">/* Type and binding information. */</span>
    Other uint8  <span class="comment">/* Reserved (not used). */</span>
    Shndx uint16 <span class="comment">/* Section index of symbol. */</span>
    Value uint64 <span class="comment">/* Symbol value. */</span>
    Size  uint64 <span class="comment">/* Size of associated object. */</span>
}</pre>
			<p>
ELF64 symbol table entries.
</p>


			

			

			

			

			
		
			
			
			<h2 id="SymBind">type <a href="src/pkg/debug/elf/elf.htm#L624">SymBind</a></h2>
			<pre>type SymBind int</pre>
			<p>
Symbol Binding - ELFNN_ST_BIND - st_info
</p>


			
				<pre>const (
    STB_LOCAL  SymBind = 0  <span class="comment">/* Local symbol */</span>
    STB_GLOBAL SymBind = 1  <span class="comment">/* Global symbol */</span>
    STB_WEAK   SymBind = 2  <span class="comment">/* like global - lower precedence */</span>
    STB_LOOS   SymBind = 10 <span class="comment">/* Reserved range for operating system */</span>
    STB_HIOS   SymBind = 12 <span class="comment">/*   specific semantics. */</span>
    STB_LOPROC SymBind = 13 <span class="comment">/* reserved range for processor */</span>
    STB_HIPROC SymBind = 15 <span class="comment">/*   specific semantics. */</span>
)</pre>
				
			

			

			

			
				
				<h3 id="ST_BIND">func <a href="src/pkg/debug/elf/elf.htm#L1365">ST_BIND</a></h3>
				<pre>func ST_BIND(info uint8) SymBind</pre>
				
				
			

			
				
				<h3 id="SymBind.GoString">func (SymBind) <a href="src/pkg/debug/elf/elf.htm#L647">GoString</a></h3>
				<pre>func (i SymBind) GoString() string</pre>
				
				
				
			
				
				<h3 id="SymBind.String">func (SymBind) <a href="src/pkg/debug/elf/elf.htm#L646">String</a></h3>
				<pre>func (i SymBind) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="SymType">type <a href="src/pkg/debug/elf/elf.htm#L650">SymType</a></h2>
			<pre>type SymType int</pre>
			<p>
Symbol type - ELFNN_ST_TYPE - st_info
</p>


			
				<pre>const (
    STT_NOTYPE  SymType = 0  <span class="comment">/* Unspecified type. */</span>
    STT_OBJECT  SymType = 1  <span class="comment">/* Data object. */</span>
    STT_FUNC    SymType = 2  <span class="comment">/* Function. */</span>
    STT_SECTION SymType = 3  <span class="comment">/* Section. */</span>
    STT_FILE    SymType = 4  <span class="comment">/* Source file. */</span>
    STT_COMMON  SymType = 5  <span class="comment">/* Uninitialized common block. */</span>
    STT_TLS     SymType = 6  <span class="comment">/* TLS object. */</span>
    STT_LOOS    SymType = 10 <span class="comment">/* Reserved range for operating system */</span>
    STT_HIOS    SymType = 12 <span class="comment">/*   specific semantics. */</span>
    STT_LOPROC  SymType = 13 <span class="comment">/* reserved range for processor */</span>
    STT_HIPROC  SymType = 15 <span class="comment">/*   specific semantics. */</span>
)</pre>
				
			

			

			

			
				
				<h3 id="ST_TYPE">func <a href="src/pkg/debug/elf/elf.htm#L1366">ST_TYPE</a></h3>
				<pre>func ST_TYPE(info uint8) SymType</pre>
				
				
			

			
				
				<h3 id="SymType.GoString">func (SymType) <a href="src/pkg/debug/elf/elf.htm#L681">GoString</a></h3>
				<pre>func (i SymType) GoString() string</pre>
				
				
				
			
				
				<h3 id="SymType.String">func (SymType) <a href="src/pkg/debug/elf/elf.htm#L680">String</a></h3>
				<pre>func (i SymType) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="SymVis">type <a href="src/pkg/debug/elf/elf.htm#L684">SymVis</a></h2>
			<pre>type SymVis int</pre>
			<p>
Symbol visibility - ELFNN_ST_VISIBILITY - st_other
</p>


			
				<pre>const (
    STV_DEFAULT   SymVis = 0x0 <span class="comment">/* Default visibility (see binding). */</span>
    STV_INTERNAL  SymVis = 0x1 <span class="comment">/* Special meaning in relocatable objects. */</span>
    STV_HIDDEN    SymVis = 0x2 <span class="comment">/* Not visible. */</span>
    STV_PROTECTED SymVis = 0x3 <span class="comment">/* Visible but not preemptible. */</span>
)</pre>
				
			

			

			

			
				
				<h3 id="ST_VISIBILITY">func <a href="src/pkg/debug/elf/elf.htm#L1370">ST_VISIBILITY</a></h3>
				<pre>func ST_VISIBILITY(other uint8) SymVis</pre>
				
				
			

			
				
				<h3 id="SymVis.GoString">func (SymVis) <a href="src/pkg/debug/elf/elf.htm#L701">GoString</a></h3>
				<pre>func (i SymVis) GoString() string</pre>
				
				
				
			
				
				<h3 id="SymVis.String">func (SymVis) <a href="src/pkg/debug/elf/elf.htm#L700">String</a></h3>
				<pre>func (i SymVis) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Symbol">type <a href="src/pkg/debug/elf/file.htm#L113">Symbol</a></h2>
			<pre>type Symbol struct {
    Name        string
    Info, Other byte
    Section     SectionIndex
    Value, Size uint64
}</pre>
			<p>
A Symbol represents an entry in an ELF symbol table section.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Type">type <a href="src/pkg/debug/elf/elf.htm#L152">Type</a></h2>
			<pre>type Type uint16</pre>
			<p>
Type is found in Header.Type.
</p>


			
				<pre>const (
    ET_NONE   Type = 0      <span class="comment">/* Unknown type. */</span>
    ET_REL    Type = 1      <span class="comment">/* Relocatable. */</span>
    ET_EXEC   Type = 2      <span class="comment">/* Executable. */</span>
    ET_DYN    Type = 3      <span class="comment">/* Shared object. */</span>
    ET_CORE   Type = 4      <span class="comment">/* Core file. */</span>
    ET_LOOS   Type = 0xfe00 <span class="comment">/* First operating system specific. */</span>
    ET_HIOS   Type = 0xfeff <span class="comment">/* Last operating system-specific. */</span>
    ET_LOPROC Type = 0xff00 <span class="comment">/* First processor-specific. */</span>
    ET_HIPROC Type = 0xffff <span class="comment">/* Last processor-specific. */</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="Type.GoString">func (Type) <a href="src/pkg/debug/elf/elf.htm#L179">GoString</a></h3>
				<pre>func (i Type) GoString() string</pre>
				
				
				
			
				
				<h3 id="Type.String">func (Type) <a href="src/pkg/debug/elf/elf.htm#L178">String</a></h3>
				<pre>func (i Type) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Version">type <a href="src/pkg/debug/elf/elf.htm#L54">Version</a></h2>
			<pre>type Version byte</pre>
			<p>
Version is found in Header.Ident[EI_VERSION] and Header.Version.
</p>


			
				<pre>const (
    EV_NONE    Version = 0
    EV_CURRENT Version = 1
)</pre>
				
			

			

			

			

			
				
				<h3 id="Version.GoString">func (Version) <a href="src/pkg/debug/elf/elf.htm#L67">GoString</a></h3>
				<pre>func (i Version) GoString() string</pre>
				
				
				
			
				
				<h3 id="Version.String">func (Version) <a href="src/pkg/debug/elf/elf.htm#L66">String</a></h3>
				<pre>func (i Version) String() string</pre>
				
				
				
			
		
		</div>
	

	









</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
