
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>net - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package net</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "net"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
				<dd><a href="#examples">Examples</a></dd>
			
			
				<dd><a href="#subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package net provides a portable interface for network I/O, including
TCP/IP, UDP, domain name resolution, and Unix domain sockets.
</p>
<p>
Although the package provides access to low-level networking
primitives, most clients will need only the basic interface provided
by the Dial, Listen, and Accept functions and the associated
Conn and Listener interfaces. The crypto/tls package uses
the same interfaces and similar Dial and Listen functions.
</p>
<p>
The Dial function connects to a server:
</p>
<pre>conn, err := net.Dial(&#34;tcp&#34;, &#34;google.com:80&#34;)
if err != nil {
	// handle error
}
fmt.Fprintf(conn, &#34;GET / HTTP/1.0\r\n\r\n&#34;)
status, err := bufio.NewReader(conn).ReadString(&#39;\n&#39;)
// ...
</pre>
<p>
The Listen function creates servers:
</p>
<pre>ln, err := net.Listen(&#34;tcp&#34;, &#34;:8080&#34;)
if err != nil {
	// handle error
}
for {
	conn, err := ln.Accept()
	if err != nil {
		// handle error
		continue
	}
	go handleConnection(conn)
}
</pre>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
				<dd><a href="#constants">Constants</a></dd>
			
			
				<dd><a href="#variables">Variables</a></dd>
			
			
				
				<dd><a href="#InterfaceAddrs">func InterfaceAddrs() ([]Addr, error)</a></dd>
			
				
				<dd><a href="#Interfaces">func Interfaces() ([]Interface, error)</a></dd>
			
				
				<dd><a href="#JoinHostPort">func JoinHostPort(host, port string) string</a></dd>
			
				
				<dd><a href="#LookupAddr">func LookupAddr(addr string) (name []string, err error)</a></dd>
			
				
				<dd><a href="#LookupCNAME">func LookupCNAME(name string) (cname string, err error)</a></dd>
			
				
				<dd><a href="#LookupHost">func LookupHost(host string) (addrs []string, err error)</a></dd>
			
				
				<dd><a href="#LookupIP">func LookupIP(host string) (addrs []IP, err error)</a></dd>
			
				
				<dd><a href="#LookupMX">func LookupMX(name string) (mx []*MX, err error)</a></dd>
			
				
				<dd><a href="#LookupPort">func LookupPort(network, service string) (port int, err error)</a></dd>
			
				
				<dd><a href="#LookupSRV">func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)</a></dd>
			
				
				<dd><a href="#LookupTXT">func LookupTXT(name string) (txt []string, err error)</a></dd>
			
				
				<dd><a href="#SplitHostPort">func SplitHostPort(hostport string) (host, port string, err error)</a></dd>
			
			
				
				<dd><a href="#Addr">type Addr</a></dd>
				
				
			
				
				<dd><a href="#AddrError">type AddrError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AddrError.Error">func (e *AddrError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AddrError.Temporary">func (e *AddrError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AddrError.Timeout">func (e *AddrError) Timeout() bool</a></dd>
				
			
				
				<dd><a href="#Conn">type Conn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Dial">func Dial(net, addr string) (Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DialTimeout">func DialTimeout(net, addr string, timeout time.Duration) (Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FileConn">func FileConn(f *os.File) (c Conn, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Pipe">func Pipe() (Conn, Conn)</a></dd>
				
				
			
				
				<dd><a href="#DNSConfigError">type DNSConfigError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSConfigError.Error">func (e *DNSConfigError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSConfigError.Temporary">func (e *DNSConfigError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSConfigError.Timeout">func (e *DNSConfigError) Timeout() bool</a></dd>
				
			
				
				<dd><a href="#DNSError">type DNSError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSError.Error">func (e *DNSError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSError.Temporary">func (e *DNSError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSError.Timeout">func (e *DNSError) Timeout() bool</a></dd>
				
			
				
				<dd><a href="#Error">type Error</a></dd>
				
				
			
				
				<dd><a href="#Flags">type Flags</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Flags.String">func (f Flags) String() string</a></dd>
				
			
				
				<dd><a href="#HardwareAddr">type HardwareAddr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseMAC">func ParseMAC(s string) (hw HardwareAddr, err error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#HardwareAddr.String">func (a HardwareAddr) String() string</a></dd>
				
			
				
				<dd><a href="#IP">type IP</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPv4">func IPv4(a, b, c, d byte) IP</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseCIDR">func ParseCIDR(s string) (IP, *IPNet, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseIP">func ParseIP(s string) IP</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.DefaultMask">func (ip IP) DefaultMask() IPMask</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.Equal">func (ip IP) Equal(x IP) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsGlobalUnicast">func (ip IP) IsGlobalUnicast() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsInterfaceLocalMulticast">func (ip IP) IsInterfaceLocalMulticast() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsLinkLocalMulticast">func (ip IP) IsLinkLocalMulticast() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsLinkLocalUnicast">func (ip IP) IsLinkLocalUnicast() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsLoopback">func (ip IP) IsLoopback() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsMulticast">func (ip IP) IsMulticast() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsUnspecified">func (ip IP) IsUnspecified() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.Mask">func (ip IP) Mask(mask IPMask) IP</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.String">func (ip IP) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.To16">func (ip IP) To16() IP</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.To4">func (ip IP) To4() IP</a></dd>
				
			
				
				<dd><a href="#IPAddr">type IPAddr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ResolveIPAddr">func ResolveIPAddr(net, addr string) (*IPAddr, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IPAddr.Network">func (a *IPAddr) Network() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPAddr.String">func (a *IPAddr) String() string</a></dd>
				
			
				
				<dd><a href="#IPConn">type IPConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DialIP">func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenIP">func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.Close">func (c *IPConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.File">func (c *IPConn) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.LocalAddr">func (c *IPConn) LocalAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.Read">func (c *IPConn) Read(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.ReadFrom">func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.ReadFromIP">func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.RemoteAddr">func (c *IPConn) RemoteAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.SetDeadline">func (c *IPConn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.SetReadBuffer">func (c *IPConn) SetReadBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.SetReadDeadline">func (c *IPConn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.SetWriteBuffer">func (c *IPConn) SetWriteBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.SetWriteDeadline">func (c *IPConn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.Write">func (c *IPConn) Write(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.WriteTo">func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.WriteToIP">func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)</a></dd>
				
			
				
				<dd><a href="#IPMask">type IPMask</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CIDRMask">func CIDRMask(ones, bits int) IPMask</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPv4Mask">func IPv4Mask(a, b, c, d byte) IPMask</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IPMask.Size">func (m IPMask) Size() (ones, bits int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPMask.String">func (m IPMask) String() string</a></dd>
				
			
				
				<dd><a href="#IPNet">type IPNet</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IPNet.Contains">func (n *IPNet) Contains(ip IP) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPNet.Network">func (n *IPNet) Network() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPNet.String">func (n *IPNet) String() string</a></dd>
				
			
				
				<dd><a href="#Interface">type Interface</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#InterfaceByIndex">func InterfaceByIndex(index int) (*Interface, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#InterfaceByName">func InterfaceByName(name string) (*Interface, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.Addrs">func (ifi *Interface) Addrs() ([]Addr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.MulticastAddrs">func (ifi *Interface) MulticastAddrs() ([]Addr, error)</a></dd>
				
			
				
				<dd><a href="#InvalidAddrError">type InvalidAddrError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#InvalidAddrError.Error">func (e InvalidAddrError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#InvalidAddrError.Temporary">func (e InvalidAddrError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#InvalidAddrError.Timeout">func (e InvalidAddrError) Timeout() bool</a></dd>
				
			
				
				<dd><a href="#Listener">type Listener</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FileListener">func FileListener(f *os.File) (l Listener, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Listen">func Listen(net, laddr string) (Listener, error)</a></dd>
				
				
			
				
				<dd><a href="#MX">type MX</a></dd>
				
				
			
				
				<dd><a href="#OpError">type OpError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#OpError.Error">func (e *OpError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#OpError.Temporary">func (e *OpError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#OpError.Timeout">func (e *OpError) Timeout() bool</a></dd>
				
			
				
				<dd><a href="#PacketConn">type PacketConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FilePacketConn">func FilePacketConn(f *os.File) (c PacketConn, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenPacket">func ListenPacket(net, addr string) (PacketConn, error)</a></dd>
				
				
			
				
				<dd><a href="#ParseError">type ParseError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseError.Error">func (e *ParseError) Error() string</a></dd>
				
			
				
				<dd><a href="#SRV">type SRV</a></dd>
				
				
			
				
				<dd><a href="#TCPAddr">type TCPAddr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ResolveTCPAddr">func ResolveTCPAddr(net, addr string) (*TCPAddr, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPAddr.Network">func (a *TCPAddr) Network() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPAddr.String">func (a *TCPAddr) String() string</a></dd>
				
			
				
				<dd><a href="#TCPConn">type TCPConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DialTCP">func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.Close">func (c *TCPConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.CloseRead">func (c *TCPConn) CloseRead() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.CloseWrite">func (c *TCPConn) CloseWrite() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.File">func (c *TCPConn) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.LocalAddr">func (c *TCPConn) LocalAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.Read">func (c *TCPConn) Read(b []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.ReadFrom">func (c *TCPConn) ReadFrom(r io.Reader) (int64, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.RemoteAddr">func (c *TCPConn) RemoteAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetDeadline">func (c *TCPConn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetKeepAlive">func (c *TCPConn) SetKeepAlive(keepalive bool) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetLinger">func (c *TCPConn) SetLinger(sec int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetNoDelay">func (c *TCPConn) SetNoDelay(noDelay bool) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetReadBuffer">func (c *TCPConn) SetReadBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetReadDeadline">func (c *TCPConn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetWriteBuffer">func (c *TCPConn) SetWriteBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetWriteDeadline">func (c *TCPConn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.Write">func (c *TCPConn) Write(b []byte) (n int, err error)</a></dd>
				
			
				
				<dd><a href="#TCPListener">type TCPListener</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenTCP">func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.Accept">func (l *TCPListener) Accept() (c Conn, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.AcceptTCP">func (l *TCPListener) AcceptTCP() (c *TCPConn, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.Addr">func (l *TCPListener) Addr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.Close">func (l *TCPListener) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.File">func (l *TCPListener) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.SetDeadline">func (l *TCPListener) SetDeadline(t time.Time) error</a></dd>
				
			
				
				<dd><a href="#UDPAddr">type UDPAddr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ResolveUDPAddr">func ResolveUDPAddr(net, addr string) (*UDPAddr, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPAddr.Network">func (a *UDPAddr) Network() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPAddr.String">func (a *UDPAddr) String() string</a></dd>
				
			
				
				<dd><a href="#UDPConn">type UDPConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DialUDP">func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenMulticastUDP">func ListenMulticastUDP(net string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenUDP">func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenUnixgram">func ListenUnixgram(net string, laddr *UnixAddr) (*UDPConn, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.Close">func (c *UDPConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.File">func (c *UDPConn) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.LocalAddr">func (c *UDPConn) LocalAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.Read">func (c *UDPConn) Read(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.ReadFrom">func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.ReadFromUDP">func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.RemoteAddr">func (c *UDPConn) RemoteAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.SetDeadline">func (c *UDPConn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.SetReadBuffer">func (c *UDPConn) SetReadBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.SetReadDeadline">func (c *UDPConn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.SetWriteBuffer">func (c *UDPConn) SetWriteBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.SetWriteDeadline">func (c *UDPConn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.Write">func (c *UDPConn) Write(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.WriteTo">func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.WriteToUDP">func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)</a></dd>
				
			
				
				<dd><a href="#UnixAddr">type UnixAddr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ResolveUnixAddr">func ResolveUnixAddr(net, addr string) (*UnixAddr, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixAddr.Network">func (a *UnixAddr) Network() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixAddr.String">func (a *UnixAddr) String() string</a></dd>
				
			
				
				<dd><a href="#UnixConn">type UnixConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DialUnix">func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.Close">func (c *UnixConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.File">func (c *UnixConn) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.LocalAddr">func (c *UnixConn) LocalAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.Read">func (c *UnixConn) Read(b []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.ReadFrom">func (c *UnixConn) ReadFrom(b []byte) (n int, addr Addr, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.ReadFromUnix">func (c *UnixConn) ReadFromUnix(b []byte) (n int, addr *UnixAddr, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.ReadMsgUnix">func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.RemoteAddr">func (c *UnixConn) RemoteAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.SetDeadline">func (c *UnixConn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.SetReadBuffer">func (c *UnixConn) SetReadBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.SetReadDeadline">func (c *UnixConn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.SetWriteBuffer">func (c *UnixConn) SetWriteBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.SetWriteDeadline">func (c *UnixConn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.Write">func (c *UnixConn) Write(b []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.WriteMsgUnix">func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.WriteTo">func (c *UnixConn) WriteTo(b []byte, addr Addr) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.WriteToUnix">func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (n int, err error)</a></dd>
				
			
				
				<dd><a href="#UnixListener">type UnixListener</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenUnix">func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.Accept">func (l *UnixListener) Accept() (c Conn, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.AcceptUnix">func (l *UnixListener) AcceptUnix() (*UnixConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.Addr">func (l *UnixListener) Addr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.Close">func (l *UnixListener) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.File">func (l *UnixListener) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.SetDeadline">func (l *UnixListener) SetDeadline(t time.Time) (err error)</a></dd>
				
			
				
				<dd><a href="#UnknownNetworkError">type UnknownNetworkError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnknownNetworkError.Error">func (e UnknownNetworkError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnknownNetworkError.Temporary">func (e UnknownNetworkError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnknownNetworkError.Timeout">func (e UnknownNetworkError) Timeout() bool</a></dd>
				
			
			
				<dd><a href="#bugs">Bugs</a></dd>
			
		</dl>

		
			<h4 id="examples">Examples</h4>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Listener">Listener</a></dd>
			
			</dl>
		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/net/cgo_linux.htm">cgo_linux.go</a>
			
				<a href="src/pkg/net/cgo_unix.htm">cgo_unix.go</a>
			
				<a href="src/pkg/net/dial.htm">dial.go</a>
			
				<a href="src/pkg/net/dnsclient.htm">dnsclient.go</a>
			
				<a href="src/pkg/net/dnsclient_unix.htm">dnsclient_unix.go</a>
			
				<a href="src/pkg/net/dnsconfig.htm">dnsconfig.go</a>
			
				<a href="src/pkg/net/dnsmsg.htm">dnsmsg.go</a>
			
				<a href="src/pkg/net/doc.htm">doc.go</a>
			
				<a href="src/pkg/net/fd.htm">fd.go</a>
			
				<a href="src/pkg/net/fd_linux.htm">fd_linux.go</a>
			
				<a href="src/pkg/net/file.htm">file.go</a>
			
				<a href="src/pkg/net/hosts.htm">hosts.go</a>
			
				<a href="src/pkg/net/interface.htm">interface.go</a>
			
				<a href="src/pkg/net/interface_linux.htm">interface_linux.go</a>
			
				<a href="src/pkg/net/ip.htm">ip.go</a>
			
				<a href="src/pkg/net/iprawsock.htm">iprawsock.go</a>
			
				<a href="src/pkg/net/iprawsock_posix.htm">iprawsock_posix.go</a>
			
				<a href="src/pkg/net/ipsock.htm">ipsock.go</a>
			
				<a href="src/pkg/net/ipsock_posix.htm">ipsock_posix.go</a>
			
				<a href="src/pkg/net/lookup_unix.htm">lookup_unix.go</a>
			
				<a href="src/pkg/net/mac.htm">mac.go</a>
			
				<a href="src/pkg/net/net.htm">net.go</a>
			
				<a href="src/pkg/net/newpollserver.htm">newpollserver.go</a>
			
				<a href="src/pkg/net/parse.htm">parse.go</a>
			
				<a href="src/pkg/net/pipe.htm">pipe.go</a>
			
				<a href="src/pkg/net/port.htm">port.go</a>
			
				<a href="src/pkg/net/sendfile_linux.htm">sendfile_linux.go</a>
			
				<a href="src/pkg/net/sock.htm">sock.go</a>
			
				<a href="src/pkg/net/sock_linux.htm">sock_linux.go</a>
			
				<a href="src/pkg/net/sockopt.htm">sockopt.go</a>
			
				<a href="src/pkg/net/sockopt_linux.htm">sockopt_linux.go</a>
			
				<a href="src/pkg/net/sockoptip.htm">sockoptip.go</a>
			
				<a href="src/pkg/net/sockoptip_linux.htm">sockoptip_linux.go</a>
			
				<a href="src/pkg/net/tcpsock.htm">tcpsock.go</a>
			
				<a href="src/pkg/net/tcpsock_posix.htm">tcpsock_posix.go</a>
			
				<a href="src/pkg/net/udpsock.htm">udpsock.go</a>
			
				<a href="src/pkg/net/udpsock_posix.htm">udpsock_posix.go</a>
			
				<a href="src/pkg/net/unixsock.htm">unixsock.go</a>
			
				<a href="src/pkg/net/unixsock_posix.htm">unixsock_posix.go</a>
			
			</span>
			</p>
		
	
		
			<h2 id="constants">Constants</h2>
			
				<pre>const (
    IPv4len = 4
    IPv6len = 16
)</pre>
				<p>
IP address lengths (bytes).
</p>

			
		
		
			<h2 id="variables">Variables</h2>
			
				<pre>var (
    IPv4bcast     = IPv4(255, 255, 255, 255) <span class="comment">// broadcast</span>
    IPv4allsys    = IPv4(224, 0, 0, 1)       <span class="comment">// all systems</span>
    IPv4allrouter = IPv4(224, 0, 0, 2)       <span class="comment">// all routers</span>
    IPv4zero      = IPv4(0, 0, 0, 0)         <span class="comment">// all zeros</span>
)</pre>
				<p>
Well-known IPv4 addresses
</p>

			
				<pre>var (
    IPv6zero                   = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    IPv6unspecified            = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    IPv6loopback               = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}
    IPv6interfacelocalallnodes = IP{0xff, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}
    IPv6linklocalallnodes      = IP{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}
    IPv6linklocalallrouters    = IP{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x02}
)</pre>
				<p>
Well-known IPv6 addresses
</p>

			
				<pre>var ErrWriteToConnected = errors.New(&#34;use of WriteTo with pre-connected UDP&#34;)</pre>
				
			
		
		
			
			
			<h2 id="InterfaceAddrs">func <a href="src/pkg/net/interface.htm#L78">InterfaceAddrs</a></h2>
			<pre>func InterfaceAddrs() ([]Addr, error)</pre>
			<p>
InterfaceAddrs returns a list of the system&#39;s network interface
addresses.
</p>

			
		
			
			
			<h2 id="Interfaces">func <a href="src/pkg/net/interface.htm#L72">Interfaces</a></h2>
			<pre>func Interfaces() ([]Interface, error)</pre>
			<p>
Interfaces returns a list of the system&#39;s network interfaces.
</p>

			
		
			
			
			<h2 id="JoinHostPort">func <a href="src/pkg/net/ipsock.htm#L82">JoinHostPort</a></h2>
			<pre>func JoinHostPort(host, port string) string</pre>
			<p>
JoinHostPort combines host and port into a network address
of the form &#34;host:port&#34; or, if host contains a colon, &#34;[host]:port&#34;.
</p>

			
		
			
			
			<h2 id="LookupAddr">func <a href="src/pkg/net/doc.htm#L47">LookupAddr</a></h2>
			<pre>func LookupAddr(addr string) (name []string, err error)</pre>
			<p>
LookupAddr performs a reverse lookup for the given address, returning a list
of names mapping to that address.
</p>

			
		
			
			
			<h2 id="LookupCNAME">func <a href="src/pkg/net/doc.htm#L18">LookupCNAME</a></h2>
			<pre>func LookupCNAME(name string) (cname string, err error)</pre>
			<p>
LookupCNAME returns the canonical DNS host for the given name.
Callers that do not care about the canonical name can call
LookupHost or LookupIP directly; both take care of resolving
the canonical name as part of the lookup.
</p>

			
		
			
			
			<h2 id="LookupHost">func <a href="src/pkg/net/doc.htm#L1">LookupHost</a></h2>
			<pre>func LookupHost(host string) (addrs []string, err error)</pre>
			<p>
LookupHost looks up the given host using the local resolver.
It returns an array of that host&#39;s addresses.
</p>

			
		
			
			
			<h2 id="LookupIP">func <a href="src/pkg/net/doc.htm#L5">LookupIP</a></h2>
			<pre>func LookupIP(host string) (addrs []IP, err error)</pre>
			<p>
LookupIP looks up host using the local resolver.
It returns an array of that host&#39;s IPv4 and IPv6 addresses.
</p>

			
		
			
			
			<h2 id="LookupMX">func <a href="src/pkg/net/doc.htm#L36">LookupMX</a></h2>
			<pre>func LookupMX(name string) (mx []*MX, err error)</pre>
			<p>
LookupMX returns the DNS MX records for the given domain name sorted by preference.
</p>

			
		
			
			
			<h2 id="LookupPort">func <a href="src/pkg/net/doc.htm#L10">LookupPort</a></h2>
			<pre>func LookupPort(network, service string) (port int, err error)</pre>
			<p>
LookupPort looks up the port for the given network and service.
</p>

			
		
			
			
			<h2 id="LookupSRV">func <a href="src/pkg/net/doc.htm#L31">LookupSRV</a></h2>
			<pre>func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)</pre>
			<p>
LookupSRV tries to resolve an SRV query of the given service,
protocol, and domain name.  The proto is &#34;tcp&#34; or &#34;udp&#34;.
The returned records are sorted by priority and randomized
by weight within a priority.
</p>
<p>
LookupSRV constructs the DNS name to look up following RFC 2782.
That is, it looks up _service._proto.name.  To accommodate services
publishing SRV records under non-standard names, if both service
and proto are empty strings, LookupSRV looks up name directly.
</p>

			
		
			
			
			<h2 id="LookupTXT">func <a href="src/pkg/net/doc.htm#L41">LookupTXT</a></h2>
			<pre>func LookupTXT(name string) (txt []string, err error)</pre>
			<p>
LookupTXT returns the DNS TXT records for the given domain name.
</p>

			
		
			
			
			<h2 id="SplitHostPort">func <a href="src/pkg/net/ipsock.htm#L57">SplitHostPort</a></h2>
			<pre>func SplitHostPort(hostport string) (host, port string, err error)</pre>
			<p>
SplitHostPort splits a network address of the form
&#34;host:port&#34; or &#34;[host]:port&#34; into host and port.
The latter form must be used when host contains a colon.
</p>

			
		
		
			
			
			<h2 id="Addr">type <a href="src/pkg/net/net.htm#L41">Addr</a></h2>
			<pre>type Addr interface {
    Network() string <span class="comment">// name of the network</span>
    String() string  <span class="comment">// string form of address</span>
}</pre>
			<p>
Addr represents a network end point address.
</p>


			

			

			

			

			
		
			
			
			<h2 id="AddrError">type <a href="src/pkg/net/net.htm#L214">AddrError</a></h2>
			<pre>type AddrError struct {
    Err  string
    Addr string
}</pre>
			

			

			

			

			

			
				
				<h3 id="AddrError.Error">func (*AddrError) <a href="src/pkg/net/net.htm#L219">Error</a></h3>
				<pre>func (e *AddrError) Error() string</pre>
				
				
				
			
				
				<h3 id="AddrError.Temporary">func (*AddrError) <a href="src/pkg/net/net.htm#L230">Temporary</a></h3>
				<pre>func (e *AddrError) Temporary() bool</pre>
				
				
				
			
				
				<h3 id="AddrError.Timeout">func (*AddrError) <a href="src/pkg/net/net.htm#L234">Timeout</a></h3>
				<pre>func (e *AddrError) Timeout() bool</pre>
				
				
				
			
		
			
			
			<h2 id="Conn">type <a href="src/pkg/net/net.htm#L49">Conn</a></h2>
			<pre>type Conn interface {
    <span class="comment">// Read reads data from the connection.</span>
    <span class="comment">// Read can be made to time out and return a Error with Timeout() == true</span>
    <span class="comment">// after a fixed time limit; see SetDeadline and SetReadDeadline.</span>
    Read(b []byte) (n int, err error)

    <span class="comment">// Write writes data to the connection.</span>
    <span class="comment">// Write can be made to time out and return a Error with Timeout() == true</span>
    <span class="comment">// after a fixed time limit; see SetDeadline and SetWriteDeadline.</span>
    Write(b []byte) (n int, err error)

    <span class="comment">// Close closes the connection.</span>
    <span class="comment">// Any blocked Read or Write operations will be unblocked and return errors.</span>
    Close() error

    <span class="comment">// LocalAddr returns the local network address.</span>
    LocalAddr() Addr

    <span class="comment">// RemoteAddr returns the remote network address.</span>
    RemoteAddr() Addr

    <span class="comment">// SetDeadline sets the read and write deadlines associated</span>
    <span class="comment">// with the connection. It is equivalent to calling both</span>
    <span class="comment">// SetReadDeadline and SetWriteDeadline.</span>
    <span class="comment">//</span>
    <span class="comment">// A deadline is an absolute time after which I/O operations</span>
    <span class="comment">// fail with a timeout (see type Error) instead of</span>
    <span class="comment">// blocking. The deadline applies to all future I/O, not just</span>
    <span class="comment">// the immediately following call to Read or Write.</span>
    <span class="comment">//</span>
    <span class="comment">// An idle timeout can be implemented by repeatedly extending</span>
    <span class="comment">// the deadline after successful Read or Write calls.</span>
    <span class="comment">//</span>
    <span class="comment">// A zero value for t means I/O operations will not time out.</span>
    SetDeadline(t time.Time) error

    <span class="comment">// SetReadDeadline sets the deadline for future Read calls.</span>
    <span class="comment">// A zero value for t means Read will not time out.</span>
    SetReadDeadline(t time.Time) error

    <span class="comment">// SetWriteDeadline sets the deadline for future Write calls.</span>
    <span class="comment">// Even if write times out, it may return n &gt; 0, indicating that</span>
    <span class="comment">// some of the data was successfully written.</span>
    <span class="comment">// A zero value for t means Write will not time out.</span>
    SetWriteDeadline(t time.Time) error
}</pre>
			<p>
Conn is a generic stream-oriented network connection.
</p>
<p>
Multiple goroutines may invoke methods on a Conn simultaneously.
</p>


			

			

			

			
				
				<h3 id="Dial">func <a href="src/pkg/net/dial.htm#L81">Dial</a></h3>
				<pre>func Dial(net, addr string) (Conn, error)</pre>
				<p>
Dial connects to the address addr on the network net.
</p>
<p>
Known networks are &#34;tcp&#34;, &#34;tcp4&#34; (IPv4-only), &#34;tcp6&#34; (IPv6-only),
&#34;udp&#34;, &#34;udp4&#34; (IPv4-only), &#34;udp6&#34; (IPv6-only), &#34;ip&#34;, &#34;ip4&#34;
(IPv4-only), &#34;ip6&#34; (IPv6-only), &#34;unix&#34; and &#34;unixpacket&#34;.
</p>
<p>
For TCP and UDP networks, addresses have the form host:port.
If host is a literal IPv6 address, it must be enclosed
in square brackets.  The functions JoinHostPort and SplitHostPort
manipulate addresses in this form.
</p>
<p>
Examples:
</p>
<pre>Dial(&#34;tcp&#34;, &#34;12.34.56.78:80&#34;)
Dial(&#34;tcp&#34;, &#34;google.com:80&#34;)
Dial(&#34;tcp&#34;, &#34;[de:ad:be:ef::ca:fe]:80&#34;)
</pre>
<p>
For IP networks, addr must be &#34;ip&#34;, &#34;ip4&#34; or &#34;ip6&#34; followed
by a colon and a protocol number or name.
</p>
<p>
Examples:
</p>
<pre>Dial(&#34;ip4:1&#34;, &#34;127.0.0.1&#34;)
Dial(&#34;ip6:ospf&#34;, &#34;::1&#34;)
</pre>

				
			
				
				<h3 id="DialTimeout">func <a href="src/pkg/net/dial.htm#L110">DialTimeout</a></h3>
				<pre>func DialTimeout(net, addr string, timeout time.Duration) (Conn, error)</pre>
				<p>
DialTimeout acts like Dial but takes a timeout.
The timeout includes name resolution, if required.
</p>

				
			
				
				<h3 id="FileConn">func <a href="src/pkg/net/file.htm#L61">FileConn</a></h3>
				<pre>func FileConn(f *os.File) (c Conn, err error)</pre>
				<p>
FileConn returns a copy of the network connection corresponding to
the open file f.  It is the caller&#39;s responsibility to close f when
finished.  Closing c does not affect f, and closing f does not
affect c.
</p>

				
			
				
				<h3 id="Pipe">func <a href="src/pkg/net/pipe.htm#L8">Pipe</a></h3>
				<pre>func Pipe() (Conn, Conn)</pre>
				<p>
Pipe creates a synchronous, in-memory, full duplex
network connection; both ends implement the Conn interface.
Reads on one end are matched with writes on the other,
copying data directly between the two; there is no internal
buffering.
</p>

				
			

			
		
			
			
			<h2 id="DNSConfigError">type <a href="src/pkg/net/net.htm#L245">DNSConfigError</a></h2>
			<pre>type DNSConfigError struct {
    Err error
}</pre>
			<p>
DNSConfigError represents an error reading the machine&#39;s DNS configuration.
</p>


			

			

			

			

			
				
				<h3 id="DNSConfigError.Error">func (*DNSConfigError) <a href="src/pkg/net/net.htm#L249">Error</a></h3>
				<pre>func (e *DNSConfigError) Error() string</pre>
				
				
				
			
				
				<h3 id="DNSConfigError.Temporary">func (*DNSConfigError) <a href="src/pkg/net/net.htm#L254">Temporary</a></h3>
				<pre>func (e *DNSConfigError) Temporary() bool</pre>
				
				
				
			
				
				<h3 id="DNSConfigError.Timeout">func (*DNSConfigError) <a href="src/pkg/net/net.htm#L253">Timeout</a></h3>
				<pre>func (e *DNSConfigError) Timeout() bool</pre>
				
				
				
			
		
			
			
			<h2 id="DNSError">type <a href="src/pkg/net/dnsclient.htm#L3">DNSError</a></h2>
			<pre>type DNSError struct {
    Err       string <span class="comment">// description of the error</span>
    Name      string <span class="comment">// name looked for</span>
    Server    string <span class="comment">// server used</span>
    IsTimeout bool
}</pre>
			<p>
DNSError represents a DNS lookup error.
</p>


			

			

			

			

			
				
				<h3 id="DNSError.Error">func (*DNSError) <a href="src/pkg/net/dnsclient.htm#L10">Error</a></h3>
				<pre>func (e *DNSError) Error() string</pre>
				
				
				
			
				
				<h3 id="DNSError.Temporary">func (*DNSError) <a href="src/pkg/net/dnsclient.htm#L23">Temporary</a></h3>
				<pre>func (e *DNSError) Temporary() bool</pre>
				
				
				
			
				
				<h3 id="DNSError.Timeout">func (*DNSError) <a href="src/pkg/net/dnsclient.htm#L22">Timeout</a></h3>
				<pre>func (e *DNSError) Timeout() bool</pre>
				
				
				
			
		
			
			
			<h2 id="Error">type <a href="src/pkg/net/net.htm#L97">Error</a></h2>
			<pre>type Error interface {
    error
    Timeout() bool   <span class="comment">// Is the error a timeout?</span>
    Temporary() bool <span class="comment">// Is the error temporary?</span>
}</pre>
			<p>
An Error represents a network error.
</p>


			

			

			

			

			
		
			
			
			<h2 id="Flags">type <a href="src/pkg/net/interface.htm#L20">Flags</a></h2>
			<pre>type Flags uint</pre>
			

			
				<pre>const (
    FlagUp           Flags = 1 &lt;&lt; iota <span class="comment">// interface is up</span>
    FlagBroadcast                      <span class="comment">// interface supports broadcast access capability</span>
    FlagLoopback                       <span class="comment">// interface is a loopback interface</span>
    FlagPointToPoint                   <span class="comment">// interface belongs to a point-to-point link</span>
    FlagMulticast                      <span class="comment">// interface supports multicast access capability</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="Flags.String">func (Flags) <a href="src/pkg/net/interface.htm#L38">String</a></h3>
				<pre>func (f Flags) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="HardwareAddr">type <a href="src/pkg/net/mac.htm#L4">HardwareAddr</a></h2>
			<pre>type HardwareAddr []byte</pre>
			<p>
A HardwareAddr represents a physical hardware address.
</p>


			

			

			

			
				
				<h3 id="ParseMAC">func <a href="src/pkg/net/mac.htm#L29">ParseMAC</a></h3>
				<pre>func ParseMAC(s string) (hw HardwareAddr, err error)</pre>
				<p>
ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, or EUI-64 using one of the
following formats:
</p>
<pre>01:23:45:67:89:ab
01:23:45:67:89:ab:cd:ef
01-23-45-67-89-ab
01-23-45-67-89-ab-cd-ef
0123.4567.89ab
0123.4567.89ab.cdef
</pre>

				
			

			
				
				<h3 id="HardwareAddr.String">func (HardwareAddr) <a href="src/pkg/net/mac.htm#L6">String</a></h3>
				<pre>func (a HardwareAddr) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="IP">type <a href="src/pkg/net/ip.htm#L20">IP</a></h2>
			<pre>type IP []byte</pre>
			<p>
An IP is a single IP address, an array of bytes.
Functions in this package accept either 4-byte (IPv4)
or 16-byte (IPv6) arrays as input.
</p>
<p>
Note that in this documentation, referring to an
IP address as an IPv4 address or an IPv6 address
is a semantic property of the address, not just the
length of the byte array: a 16-byte array can still
be an IPv4 address.
</p>


			

			

			

			
				
				<h3 id="IPv4">func <a href="src/pkg/net/ip.htm#L33">IPv4</a></h3>
				<pre>func IPv4(a, b, c, d byte) IP</pre>
				<p>
IPv4 returns the IP address (in 16-byte form) of the
IPv4 address a.b.c.d.
</p>

				
			
				
				<h3 id="ParseCIDR">func <a href="src/pkg/net/ip.htm#L621">ParseCIDR</a></h3>
				<pre>func ParseCIDR(s string) (IP, *IPNet, error)</pre>
				<p>
ParseCIDR parses s as a CIDR notation IP address and mask,
like &#34;192.168.100.1/24&#34; or &#34;2001:DB8::/48&#34;, as defined in
RFC 4632 and RFC 4291.
</p>
<p>
It returns the IP address and the network implied by the IP
and mask.  For example, ParseCIDR(&#34;192.168.100.1/16&#34;) returns
the IP address 192.168.100.1 and the network 192.168.0.0/16.
</p>

				
			
				
				<h3 id="ParseIP">func <a href="src/pkg/net/ip.htm#L607">ParseIP</a></h3>
				<pre>func ParseIP(s string) IP</pre>
				<p>
ParseIP parses s as an IP address, returning the result.
The string s can be in dotted decimal (&#34;74.125.19.99&#34;)
or IPv6 (&#34;2001:4860:0:2001::68&#34;) form.
If s is not a valid textual representation of an IP address,
ParseIP returns nil.
</p>

				
			

			
				
				<h3 id="IP.DefaultMask">func (IP) <a href="src/pkg/net/ip.htm#L203">DefaultMask</a></h3>
				<pre>func (ip IP) DefaultMask() IPMask</pre>
				<p>
DefaultMask returns the default IP mask for the IP address ip.
Only IPv4 addresses have default masks; DefaultMask returns
nil if ip is not a valid IPv4 address.
</p>

				
				
			
				
				<h3 id="IP.Equal">func (IP) <a href="src/pkg/net/ip.htm#L307">Equal</a></h3>
				<pre>func (ip IP) Equal(x IP) bool</pre>
				<p>
Equal returns true if ip and x are the same IP address.
An IPv4 address and that same address in IPv6 form are
considered to be equal.
</p>

				
				
			
				
				<h3 id="IP.IsGlobalUnicast">func (IP) <a href="src/pkg/net/ip.htm#L149">IsGlobalUnicast</a></h3>
				<pre>func (ip IP) IsGlobalUnicast() bool</pre>
				<p>
IsGlobalUnicast returns true if ip is a global unicast
address.
</p>

				
				
			
				
				<h3 id="IP.IsInterfaceLocalMulticast">func (IP) <a href="src/pkg/net/ip.htm#L125">IsInterfaceLocalMulticast</a></h3>
				<pre>func (ip IP) IsInterfaceLocalMulticast() bool</pre>
				<p>
IsInterfaceLinkLocalMulticast returns true if ip is
an interface-local multicast address.
</p>

				
				
			
				
				<h3 id="IP.IsLinkLocalMulticast">func (IP) <a href="src/pkg/net/ip.htm#L131">IsLinkLocalMulticast</a></h3>
				<pre>func (ip IP) IsLinkLocalMulticast() bool</pre>
				<p>
IsLinkLocalMulticast returns true if ip is a link-local
multicast address.
</p>

				
				
			
				
				<h3 id="IP.IsLinkLocalUnicast">func (IP) <a href="src/pkg/net/ip.htm#L140">IsLinkLocalUnicast</a></h3>
				<pre>func (ip IP) IsLinkLocalUnicast() bool</pre>
				<p>
IsLinkLocalUnicast returns true if ip is a link-local
unicast address.
</p>

				
				
			
				
				<h3 id="IP.IsLoopback">func (IP) <a href="src/pkg/net/ip.htm#L108">IsLoopback</a></h3>
				<pre>func (ip IP) IsLoopback() bool</pre>
				<p>
IsLoopback returns true if ip is a loopback address.
</p>

				
				
			
				
				<h3 id="IP.IsMulticast">func (IP) <a href="src/pkg/net/ip.htm#L116">IsMulticast</a></h3>
				<pre>func (ip IP) IsMulticast() bool</pre>
				<p>
IsMulticast returns true if ip is a multicast address.
</p>

				
				
			
				
				<h3 id="IP.IsUnspecified">func (IP) <a href="src/pkg/net/ip.htm#L100">IsUnspecified</a></h3>
				<pre>func (ip IP) IsUnspecified() bool</pre>
				<p>
IsUnspecified returns true if ip is an unspecified address.
</p>

				
				
			
				
				<h3 id="IP.Mask">func (IP) <a href="src/pkg/net/ip.htm#L228">Mask</a></h3>
				<pre>func (ip IP) Mask(mask IPMask) IP</pre>
				<p>
Mask returns the result of masking the IP address ip with mask.
</p>

				
				
			
				
				<h3 id="IP.String">func (IP) <a href="src/pkg/net/ip.htm#L250">String</a></h3>
				<pre>func (ip IP) String() string</pre>
				<p>
String returns the string form of the IP address ip.
If the address is an IPv4 address, the string representation
is dotted decimal (&#34;74.125.19.99&#34;).  Otherwise the representation
is IPv6 (&#34;2001:4860:0:2001::68&#34;).
</p>

				
				
			
				
				<h3 id="IP.To16">func (IP) <a href="src/pkg/net/ip.htm#L183">To16</a></h3>
				<pre>func (ip IP) To16() IP</pre>
				<p>
To16 converts the IP address ip to a 16-byte representation.
If ip is not an IP address (it is the wrong length), To16 returns nil.
</p>

				
				
			
				
				<h3 id="IP.To4">func (IP) <a href="src/pkg/net/ip.htm#L168">To4</a></h3>
				<pre>func (ip IP) To4() IP</pre>
				<p>
To4 converts the IPv4 address ip to a 4-byte representation.
If ip is not an IPv4 address, To4 returns nil.
</p>

				
				
			
		
			
			
			<h2 id="IPAddr">type <a href="src/pkg/net/iprawsock.htm#L1">IPAddr</a></h2>
			<pre>type IPAddr struct {
    IP IP
}</pre>
			<p>
IPAddr represents the address of a IP end point.
</p>


			

			

			

			
				
				<h3 id="ResolveIPAddr">func <a href="src/pkg/net/iprawsock.htm#L18">ResolveIPAddr</a></h3>
				<pre>func ResolveIPAddr(net, addr string) (*IPAddr, error)</pre>
				<p>
ResolveIPAddr parses addr as a IP address and resolves domain
names to numeric addresses on the network net, which must be
&#34;ip&#34;, &#34;ip4&#34; or &#34;ip6&#34;.  A literal IPv6 host address must be
enclosed in square brackets, as in &#34;[::]&#34;.
</p>

				
			

			
				
				<h3 id="IPAddr.Network">func (*IPAddr) <a href="src/pkg/net/iprawsock.htm#L5">Network</a></h3>
				<pre>func (a *IPAddr) Network() string</pre>
				<p>
Network returns the address&#39;s network name, &#34;ip&#34;.
</p>

				
				
			
				
				<h3 id="IPAddr.String">func (*IPAddr) <a href="src/pkg/net/iprawsock.htm#L7">String</a></h3>
				<pre>func (a *IPAddr) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="IPConn">type <a href="src/pkg/net/iprawsock_posix.htm#L47">IPConn</a></h2>
			<pre>type IPConn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
IPConn is the implementation of the Conn and PacketConn
interfaces for IP network connections.
</p>


			

			

			

			
				
				<h3 id="DialIP">func <a href="src/pkg/net/iprawsock_posix.htm#L208">DialIP</a></h3>
				<pre>func DialIP(netProto string, laddr, raddr *IPAddr) (*IPConn, error)</pre>
				<p>
DialIP connects to the remote address raddr on the network protocol netProto,
which must be &#34;ip&#34;, &#34;ip4&#34;, or &#34;ip6&#34; followed by a colon and a protocol number or name.
</p>

				
			
				
				<h3 id="ListenIP">func <a href="src/pkg/net/iprawsock_posix.htm#L232">ListenIP</a></h3>
				<pre>func ListenIP(netProto string, laddr *IPAddr) (*IPConn, error)</pre>
				<p>
ListenIP listens for incoming IP packets addressed to the
local address laddr.  The returned connection c&#39;s ReadFrom
and WriteTo methods can be used to receive and send IP
packets with per-packet addressing.
</p>

				
			

			
				
				<h3 id="IPConn.Close">func (*IPConn) <a href="src/pkg/net/iprawsock_posix.htm#L72">Close</a></h3>
				<pre>func (c *IPConn) Close() error</pre>
				<p>
Close closes the IP connection.
</p>

				
				
			
				
				<h3 id="IPConn.File">func (*IPConn) <a href="src/pkg/net/iprawsock_posix.htm#L252">File</a></h3>
				<pre>func (c *IPConn) File() (f *os.File, err error)</pre>
				<p>
File returns a copy of the underlying os.File, set to blocking mode.
It is the caller&#39;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
</p>

				
				
			
				
				<h3 id="IPConn.LocalAddr">func (*IPConn) <a href="src/pkg/net/iprawsock_posix.htm#L80">LocalAddr</a></h3>
				<pre>func (c *IPConn) LocalAddr() Addr</pre>
				<p>
LocalAddr returns the local network address.
</p>

				
				
			
				
				<h3 id="IPConn.Read">func (*IPConn) <a href="src/pkg/net/iprawsock_posix.htm#L58">Read</a></h3>
				<pre>func (c *IPConn) Read(b []byte) (int, error)</pre>
				<p>
Read implements the Conn Read method.
</p>

				
				
			
				
				<h3 id="IPConn.ReadFrom">func (*IPConn) <a href="src/pkg/net/iprawsock_posix.htm#L169">ReadFrom</a></h3>
				<pre>func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)</pre>
				<p>
ReadFrom implements the PacketConn ReadFrom method.
</p>

				
				
			
				
				<h3 id="IPConn.ReadFromIP">func (*IPConn) <a href="src/pkg/net/iprawsock_posix.htm#L146">ReadFromIP</a></h3>
				<pre>func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)</pre>
				<p>
ReadFromIP reads a IP packet from c, copying the payload into b.
It returns the number of bytes copied into b and the return address
that was on the packet.
</p>
<p>
ReadFromIP can be made to time out and return an error with
Timeout() == true after a fixed time limit; see SetDeadline and
SetReadDeadline.
</p>

				
				
			
				
				<h3 id="IPConn.RemoteAddr">func (*IPConn) <a href="src/pkg/net/iprawsock_posix.htm#L88">RemoteAddr</a></h3>
				<pre>func (c *IPConn) RemoteAddr() Addr</pre>
				<p>
RemoteAddr returns the remote network address, a *IPAddr.
</p>

				
				
			
				
				<h3 id="IPConn.SetDeadline">func (*IPConn) <a href="src/pkg/net/iprawsock_posix.htm#L96">SetDeadline</a></h3>
				<pre>func (c *IPConn) SetDeadline(t time.Time) error</pre>
				<p>
SetDeadline implements the Conn SetDeadline method.
</p>

				
				
			
				
				<h3 id="IPConn.SetReadBuffer">func (*IPConn) <a href="src/pkg/net/iprawsock_posix.htm#L121">SetReadBuffer</a></h3>
				<pre>func (c *IPConn) SetReadBuffer(bytes int) error</pre>
				<p>
SetReadBuffer sets the size of the operating system&#39;s
receive buffer associated with the connection.
</p>

				
				
			
				
				<h3 id="IPConn.SetReadDeadline">func (*IPConn) <a href="src/pkg/net/iprawsock_posix.htm#L104">SetReadDeadline</a></h3>
				<pre>func (c *IPConn) SetReadDeadline(t time.Time) error</pre>
				<p>
SetReadDeadline implements the Conn SetReadDeadline method.
</p>

				
				
			
				
				<h3 id="IPConn.SetWriteBuffer">func (*IPConn) <a href="src/pkg/net/iprawsock_posix.htm#L130">SetWriteBuffer</a></h3>
				<pre>func (c *IPConn) SetWriteBuffer(bytes int) error</pre>
				<p>
SetWriteBuffer sets the size of the operating system&#39;s
transmit buffer associated with the connection.
</p>

				
				
			
				
				<h3 id="IPConn.SetWriteDeadline">func (*IPConn) <a href="src/pkg/net/iprawsock_posix.htm#L112">SetWriteDeadline</a></h3>
				<pre>func (c *IPConn) SetWriteDeadline(t time.Time) error</pre>
				<p>
SetWriteDeadline implements the Conn SetWriteDeadline method.
</p>

				
				
			
				
				<h3 id="IPConn.Write">func (*IPConn) <a href="src/pkg/net/iprawsock_posix.htm#L64">Write</a></h3>
				<pre>func (c *IPConn) Write(b []byte) (int, error)</pre>
				<p>
Write implements the Conn Write method.
</p>

				
				
			
				
				<h3 id="IPConn.WriteTo">func (*IPConn) <a href="src/pkg/net/iprawsock_posix.htm#L195">WriteTo</a></h3>
				<pre>func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)</pre>
				<p>
WriteTo implements the PacketConn WriteTo method.
</p>

				
				
			
				
				<h3 id="IPConn.WriteToIP">func (*IPConn) <a href="src/pkg/net/iprawsock_posix.htm#L183">WriteToIP</a></h3>
				<pre>func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)</pre>
				<p>
WriteToIP writes a IP packet to addr via c, copying the payload from b.
</p>
<p>
WriteToIP can be made to time out and return
an error with Timeout() == true after a fixed time limit;
see SetDeadline and SetWriteDeadline.
On packet-oriented connections, write timeouts are rare.
</p>

				
				
			
		
			
			
			<h2 id="IPMask">type <a href="src/pkg/net/ip.htm#L23">IPMask</a></h2>
			<pre>type IPMask []byte</pre>
			<p>
An IP mask is an IP address.
</p>


			

			

			

			
				
				<h3 id="CIDRMask">func <a href="src/pkg/net/ip.htm#L59">CIDRMask</a></h3>
				<pre>func CIDRMask(ones, bits int) IPMask</pre>
				<p>
CIDRMask returns an IPMask consisting of `ones&#39; 1 bits
followed by 0s up to a total length of `bits&#39; bits.
For a mask of this form, CIDRMask is the inverse of IPMask.Size.
</p>

				
			
				
				<h3 id="IPv4Mask">func <a href="src/pkg/net/ip.htm#L47">IPv4Mask</a></h3>
				<pre>func IPv4Mask(a, b, c, d byte) IPMask</pre>
				<p>
IPv4Mask returns the IP mask (in 4-byte form) of the
IPv4 mask a.b.c.d.
</p>

				
			

			
				
				<h3 id="IPMask.Size">func (IPMask) <a href="src/pkg/net/ip.htm#L364">Size</a></h3>
				<pre>func (m IPMask) Size() (ones, bits int)</pre>
				<p>
Size returns the number of leading ones and total bits in the mask.
If the mask is not in the canonical form--ones followed by zeros--then
Size returns 0, 0.
</p>

				
				
			
				
				<h3 id="IPMask.String">func (IPMask) <a href="src/pkg/net/ip.htm#L373">String</a></h3>
				<pre>func (m IPMask) String() string</pre>
				<p>
String returns the hexadecimal form of m, with no punctuation.
</p>

				
				
			
		
			
			
			<h2 id="IPNet">type <a href="src/pkg/net/ip.htm#L26">IPNet</a></h2>
			<pre>type IPNet struct {
    IP   IP     <span class="comment">// network number</span>
    Mask IPMask <span class="comment">// network mask</span>
}</pre>
			<p>
An IPNet represents an IP network.
</p>


			

			

			

			

			
				
				<h3 id="IPNet.Contains">func (*IPNet) <a href="src/pkg/net/ip.htm#L408">Contains</a></h3>
				<pre>func (n *IPNet) Contains(ip IP) bool</pre>
				<p>
Contains reports whether the network includes ip.
</p>

				
				
			
				
				<h3 id="IPNet.Network">func (*IPNet) <a href="src/pkg/net/ip.htm#L444">Network</a></h3>
				<pre>func (n *IPNet) Network() string</pre>
				<p>
Network returns the address&#39;s network name, &#34;ip+net&#34;.
</p>

				
				
			
				
				<h3 id="IPNet.String">func (*IPNet) <a href="src/pkg/net/ip.htm#L431">String</a></h3>
				<pre>func (n *IPNet) String() string</pre>
				<p>
String returns the CIDR notation of n like &#34;192.168.100.1/24&#34;
or &#34;2001:DB8::/48&#34; as defined in RFC 4632 and RFC 4291.
If the mask is not in the canonical form, it returns the
string which consists of an IP address, followed by a slash
character and a mask expressed as hexadecimal form with no
punctuation like &#34;192.168.100.1/c000ff00&#34;.
</p>

				
				
			
		
			
			
			<h2 id="Interface">type <a href="src/pkg/net/interface.htm#L12">Interface</a></h2>
			<pre>type Interface struct {
    Index        int          <span class="comment">// positive integer that starts at one, zero is never used</span>
    MTU          int          <span class="comment">// maximum transmission unit</span>
    Name         string       <span class="comment">// e.g., &#34;en0&#34;, &#34;lo0&#34;, &#34;eth0.100&#34;</span>
    HardwareAddr HardwareAddr <span class="comment">// IEEE MAC-48, EUI-48 and EUI-64 form</span>
    Flags        Flags        <span class="comment">// e.g., FlagUp, FlagLoopback, FlagMulticast</span>
}</pre>
			<p>
Interface represents a mapping between network interface name
and index.  It also represents network interface facility
information.
</p>


			

			

			

			
				
				<h3 id="InterfaceByIndex">func <a href="src/pkg/net/interface.htm#L83">InterfaceByIndex</a></h3>
				<pre>func InterfaceByIndex(index int) (*Interface, error)</pre>
				<p>
InterfaceByIndex returns the interface specified by index.
</p>

				
			
				
				<h3 id="InterfaceByName">func <a href="src/pkg/net/interface.htm#L98">InterfaceByName</a></h3>
				<pre>func InterfaceByName(name string) (*Interface, error)</pre>
				<p>
InterfaceByName returns the interface specified by name.
</p>

				
			

			
				
				<h3 id="Interface.Addrs">func (*Interface) <a href="src/pkg/net/interface.htm#L55">Addrs</a></h3>
				<pre>func (ifi *Interface) Addrs() ([]Addr, error)</pre>
				<p>
Addrs returns interface addresses for a specific interface.
</p>

				
				
			
				
				<h3 id="Interface.MulticastAddrs">func (*Interface) <a href="src/pkg/net/interface.htm#L64">MulticastAddrs</a></h3>
				<pre>func (ifi *Interface) MulticastAddrs() ([]Addr, error)</pre>
				<p>
MulticastAddrs returns multicast, joined group addresses for
a specific interface.
</p>

				
				
			
		
			
			
			<h2 id="InvalidAddrError">type <a href="src/pkg/net/ipsock.htm#L48">InvalidAddrError</a></h2>
			<pre>type InvalidAddrError string</pre>
			

			

			

			

			

			
				
				<h3 id="InvalidAddrError.Error">func (InvalidAddrError) <a href="src/pkg/net/ipsock.htm#L50">Error</a></h3>
				<pre>func (e InvalidAddrError) Error() string</pre>
				
				
				
			
				
				<h3 id="InvalidAddrError.Temporary">func (InvalidAddrError) <a href="src/pkg/net/ipsock.htm#L52">Temporary</a></h3>
				<pre>func (e InvalidAddrError) Temporary() bool</pre>
				
				
				
			
				
				<h3 id="InvalidAddrError.Timeout">func (InvalidAddrError) <a href="src/pkg/net/ipsock.htm#L51">Timeout</a></h3>
				<pre>func (e InvalidAddrError) Timeout() bool</pre>
				
				
				
			
		
			
			
			<h2 id="Listener">type <a href="src/pkg/net/net.htm#L152">Listener</a></h2>
			<pre>type Listener interface {
    <span class="comment">// Accept waits for and returns the next connection to the listener.</span>
    Accept() (c Conn, err error)

    <span class="comment">// Close closes the listener.</span>
    <span class="comment">// Any blocked Accept operations will be unblocked and return errors.</span>
    Close() error

    <span class="comment">// Addr returns the listener&#39;s network address.</span>
    Addr() Addr
}</pre>
			<p>
A Listener is a generic network listener for stream-oriented protocols.
</p>
<p>
Multiple goroutines may invoke methods on a Listener simultaneously.
</p>


			

			

			<div id="example_Listener" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		
		<p>Code:</p>
		<pre class="code">
<span class="comment">// Listen on TCP port 2000 on all interfaces.</span>
l, err := net.Listen(&#34;tcp&#34;, &#34;:2000&#34;)
if err != nil {
    log.Fatal(err)
}
for {
    <span class="comment">// Wait for a connection. </span>
    conn, err := l.Accept()
    if err != nil {
        log.Fatal(err)
    }
    <span class="comment">// Handle the connection in a new goroutine.</span>
    <span class="comment">// The loop then returns to accepting, so that</span>
    <span class="comment">// multiple connections may be served concurrently.</span>
    go func(c net.Conn) {
        <span class="comment">// Echo all incoming data.</span>
        io.Copy(c, c)
        <span class="comment">// Shut down the connection.</span>
        c.Close()
    }(conn)
}
</pre>
		
	</div>
</div>


			
				
				<h3 id="FileListener">func <a href="src/pkg/net/file.htm#L84">FileListener</a></h3>
				<pre>func FileListener(f *os.File) (l Listener, err error)</pre>
				<p>
FileListener returns a copy of the network listener corresponding
to the open file f.  It is the caller&#39;s responsibility to close l
when finished.  Closing c does not affect l, and closing l does not
affect c.
</p>

				
			
				
				<h3 id="Listen">func <a href="src/pkg/net/dial.htm#L167">Listen</a></h3>
				<pre>func Listen(net, laddr string) (Listener, error)</pre>
				<p>
Listen announces on the local network address laddr.
The network string net must be a stream-oriented network:
&#34;tcp&#34;, &#34;tcp4&#34;, &#34;tcp6&#34;, or &#34;unix&#34;, or &#34;unixpacket&#34;.
</p>

				
			

			
		
			
			
			<h2 id="MX">type <a href="src/pkg/net/dnsclient.htm#L215">MX</a></h2>
			<pre>type MX struct {
    Host string
    Pref uint16
}</pre>
			<p>
An MX represents a single DNS MX record.
</p>


			

			

			

			

			
		
			
			
			<h2 id="OpError">type <a href="src/pkg/net/net.htm#L166">OpError</a></h2>
			<pre>type OpError struct {
    Op   string
    Net  string
    Addr Addr
    Err  error
}</pre>
			

			

			

			

			

			
				
				<h3 id="OpError.Error">func (*OpError) <a href="src/pkg/net/net.htm#L173">Error</a></h3>
				<pre>func (e *OpError) Error() string</pre>
				
				
				
			
				
				<h3 id="OpError.Temporary">func (*OpError) <a href="src/pkg/net/net.htm#L192">Temporary</a></h3>
				<pre>func (e *OpError) Temporary() bool</pre>
				
				
				
			
				
				<h3 id="OpError.Timeout">func (*OpError) <a href="src/pkg/net/net.htm#L201">Timeout</a></h3>
				<pre>func (e *OpError) Timeout() bool</pre>
				
				
				
			
		
			
			
			<h2 id="PacketConn">type <a href="src/pkg/net/net.htm#L106">PacketConn</a></h2>
			<pre>type PacketConn interface {
    <span class="comment">// ReadFrom reads a packet from the connection,</span>
    <span class="comment">// copying the payload into b.  It returns the number of</span>
    <span class="comment">// bytes copied into b and the return address that</span>
    <span class="comment">// was on the packet.</span>
    <span class="comment">// ReadFrom can be made to time out and return</span>
    <span class="comment">// an error with Timeout() == true after a fixed time limit;</span>
    <span class="comment">// see SetDeadline and SetReadDeadline.</span>
    ReadFrom(b []byte) (n int, addr Addr, err error)

    <span class="comment">// WriteTo writes a packet with payload b to addr.</span>
    <span class="comment">// WriteTo can be made to time out and return</span>
    <span class="comment">// an error with Timeout() == true after a fixed time limit;</span>
    <span class="comment">// see SetDeadline and SetWriteDeadline.</span>
    <span class="comment">// On packet-oriented connections, write timeouts are rare.</span>
    WriteTo(b []byte, addr Addr) (n int, err error)

    <span class="comment">// Close closes the connection.</span>
    <span class="comment">// Any blocked ReadFrom or WriteTo operations will be unblocked and return errors.</span>
    Close() error

    <span class="comment">// LocalAddr returns the local network address.</span>
    LocalAddr() Addr

    <span class="comment">// SetDeadline sets the read and write deadlines associated</span>
    <span class="comment">// with the connection.</span>
    SetDeadline(t time.Time) error

    <span class="comment">// SetReadDeadline sets the deadline for future Read calls.</span>
    <span class="comment">// If the deadline is reached, Read will fail with a timeout</span>
    <span class="comment">// (see type Error) instead of blocking.</span>
    <span class="comment">// A zero value for t means Read will not time out.</span>
    SetReadDeadline(t time.Time) error

    <span class="comment">// SetWriteDeadline sets the deadline for future Write calls.</span>
    <span class="comment">// If the deadline is reached, Write will fail with a timeout</span>
    <span class="comment">// (see type Error) instead of blocking.</span>
    <span class="comment">// A zero value for t means Write will not time out.</span>
    <span class="comment">// Even if write times out, it may return n &gt; 0, indicating that</span>
    <span class="comment">// some of the data was successfully written.</span>
    SetWriteDeadline(t time.Time) error
}</pre>
			<p>
PacketConn is a generic packet-oriented network connection.
</p>
<p>
Multiple goroutines may invoke methods on a PacketConn simultaneously.
</p>


			

			

			

			
				
				<h3 id="FilePacketConn">func <a href="src/pkg/net/file.htm#L103">FilePacketConn</a></h3>
				<pre>func FilePacketConn(f *os.File) (c PacketConn, err error)</pre>
				<p>
FilePacketConn returns a copy of the packet network connection
corresponding to the open file f.  It is the caller&#39;s
responsibility to close f when finished.  Closing c does not affect
f, and closing f does not affect c.
</p>

				
			
				
				<h3 id="ListenPacket">func <a href="src/pkg/net/dial.htm#L192">ListenPacket</a></h3>
				<pre>func ListenPacket(net, addr string) (PacketConn, error)</pre>
				<p>
ListenPacket announces on the local network address laddr.
The network string net must be a packet-oriented network:
&#34;udp&#34;, &#34;udp4&#34;, &#34;udp6&#34;, &#34;ip&#34;, &#34;ip4&#34;, &#34;ip6&#34; or &#34;unixgram&#34;.
</p>

				
			

			
		
			
			
			<h2 id="ParseError">type <a href="src/pkg/net/ip.htm#L583">ParseError</a></h2>
			<pre>type ParseError struct {
    Type string
    Text string
}</pre>
			<p>
A ParseError represents a malformed text string and the type of string that was expected.
</p>


			

			

			

			

			
				
				<h3 id="ParseError.Error">func (*ParseError) <a href="src/pkg/net/ip.htm#L588">Error</a></h3>
				<pre>func (e *ParseError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="SRV">type <a href="src/pkg/net/dnsclient.htm#L156">SRV</a></h2>
			<pre>type SRV struct {
    Target   string
    Port     uint16
    Priority uint16
    Weight   uint16
}</pre>
			<p>
An SRV represents a single DNS SRV record.
</p>


			

			

			

			

			
		
			
			
			<h2 id="TCPAddr">type <a href="src/pkg/net/tcpsock.htm#L1">TCPAddr</a></h2>
			<pre>type TCPAddr struct {
    IP   IP
    Port int
}</pre>
			<p>
TCPAddr represents the address of a TCP end point.
</p>


			

			

			

			
				
				<h3 id="ResolveTCPAddr">func <a href="src/pkg/net/tcpsock.htm#L20">ResolveTCPAddr</a></h3>
				<pre>func ResolveTCPAddr(net, addr string) (*TCPAddr, error)</pre>
				<p>
ResolveTCPAddr parses addr as a TCP address of the form
host:port and resolves domain names or port names to
numeric addresses on the network net, which must be &#34;tcp&#34;,
&#34;tcp4&#34; or &#34;tcp6&#34;.  A literal IPv6 host address must be
enclosed in square brackets, as in &#34;[::]:80&#34;.
</p>

				
			

			
				
				<h3 id="TCPAddr.Network">func (*TCPAddr) <a href="src/pkg/net/tcpsock.htm#L6">Network</a></h3>
				<pre>func (a *TCPAddr) Network() string</pre>
				<p>
Network returns the address&#39;s network name, &#34;tcp&#34;.
</p>

				
				
			
				
				<h3 id="TCPAddr.String">func (*TCPAddr) <a href="src/pkg/net/tcpsock.htm#L8">String</a></h3>
				<pre>func (a *TCPAddr) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="TCPConn">type <a href="src/pkg/net/tcpsock_posix.htm#L58">TCPConn</a></h2>
			<pre>type TCPConn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
TCPConn is an implementation of the Conn interface
for TCP network connections.
</p>


			

			

			

			
				
				<h3 id="DialTCP">func <a href="src/pkg/net/tcpsock_posix.htm#L226">DialTCP</a></h3>
				<pre>func DialTCP(net string, laddr, raddr *TCPAddr) (*TCPConn, error)</pre>
				<p>
DialTCP connects to the remote address raddr on the network net,
which must be &#34;tcp&#34;, &#34;tcp4&#34;, or &#34;tcp6&#34;.  If laddr is not nil, it is used
as the local address for the connection.
</p>

				
			

			
				
				<h3 id="TCPConn.Close">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L97">Close</a></h3>
				<pre>func (c *TCPConn) Close() error</pre>
				<p>
Close closes the TCP connection.
</p>

				
				
			
				
				<h3 id="TCPConn.CloseRead">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L106">CloseRead</a></h3>
				<pre>func (c *TCPConn) CloseRead() error</pre>
				<p>
CloseRead shuts down the reading side of the TCP connection.
Most callers should just use Close.
</p>

				
				
			
				
				<h3 id="TCPConn.CloseWrite">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L115">CloseWrite</a></h3>
				<pre>func (c *TCPConn) CloseWrite() error</pre>
				<p>
CloseWrite shuts down the writing side of the TCP connection.
Most callers should just use Close.
</p>

				
				
			
				
				<h3 id="TCPConn.File">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L221">File</a></h3>
				<pre>func (c *TCPConn) File() (f *os.File, err error)</pre>
				<p>
File returns a copy of the underlying os.File, set to blocking mode.
It is the caller&#39;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
</p>

				
				
			
				
				<h3 id="TCPConn.LocalAddr">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L123">LocalAddr</a></h3>
				<pre>func (c *TCPConn) LocalAddr() Addr</pre>
				<p>
LocalAddr returns the local network address, a *TCPAddr.
</p>

				
				
			
				
				<h3 id="TCPConn.Read">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L73">Read</a></h3>
				<pre>func (c *TCPConn) Read(b []byte) (n int, err error)</pre>
				<p>
Read implements the Conn Read method.
</p>

				
				
			
				
				<h3 id="TCPConn.ReadFrom">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L81">ReadFrom</a></h3>
				<pre>func (c *TCPConn) ReadFrom(r io.Reader) (int64, error)</pre>
				<p>
ReadFrom implements the io.ReaderFrom ReadFrom method.
</p>

				
				
			
				
				<h3 id="TCPConn.RemoteAddr">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L131">RemoteAddr</a></h3>
				<pre>func (c *TCPConn) RemoteAddr() Addr</pre>
				<p>
RemoteAddr returns the remote network address, a *TCPAddr.
</p>

				
				
			
				
				<h3 id="TCPConn.SetDeadline">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L139">SetDeadline</a></h3>
				<pre>func (c *TCPConn) SetDeadline(t time.Time) error</pre>
				<p>
SetDeadline implements the Conn SetDeadline method.
</p>

				
				
			
				
				<h3 id="TCPConn.SetKeepAlive">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L200">SetKeepAlive</a></h3>
				<pre>func (c *TCPConn) SetKeepAlive(keepalive bool) error</pre>
				<p>
SetKeepAlive sets whether the operating system should send
keepalive messages on the connection.
</p>

				
				
			
				
				<h3 id="TCPConn.SetLinger">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L191">SetLinger</a></h3>
				<pre>func (c *TCPConn) SetLinger(sec int) error</pre>
				<p>
SetLinger sets the behavior of Close() on a connection
which still has data waiting to be sent or to be acknowledged.
</p>
<p>
If sec &lt; 0 (the default), Close returns immediately and
the operating system finishes sending the data in the background.
</p>
<p>
If sec == 0, Close returns immediately and the operating system
discards any unsent or unacknowledged data.
</p>
<p>
If sec &gt; 0, Close blocks for at most sec seconds waiting for
data to be sent and acknowledged.
</p>

				
				
			
				
				<h3 id="TCPConn.SetNoDelay">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L211">SetNoDelay</a></h3>
				<pre>func (c *TCPConn) SetNoDelay(noDelay bool) error</pre>
				<p>
SetNoDelay controls whether the operating system should delay
packet transmission in hopes of sending fewer packets
(Nagle&#39;s algorithm).  The default is true (no delay), meaning
that data is sent as soon as possible after a Write.
</p>

				
				
			
				
				<h3 id="TCPConn.SetReadBuffer">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L164">SetReadBuffer</a></h3>
				<pre>func (c *TCPConn) SetReadBuffer(bytes int) error</pre>
				<p>
SetReadBuffer sets the size of the operating system&#39;s
receive buffer associated with the connection.
</p>

				
				
			
				
				<h3 id="TCPConn.SetReadDeadline">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L147">SetReadDeadline</a></h3>
				<pre>func (c *TCPConn) SetReadDeadline(t time.Time) error</pre>
				<p>
SetReadDeadline implements the Conn SetReadDeadline method.
</p>

				
				
			
				
				<h3 id="TCPConn.SetWriteBuffer">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L173">SetWriteBuffer</a></h3>
				<pre>func (c *TCPConn) SetWriteBuffer(bytes int) error</pre>
				<p>
SetWriteBuffer sets the size of the operating system&#39;s
transmit buffer associated with the connection.
</p>

				
				
			
				
				<h3 id="TCPConn.SetWriteDeadline">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L155">SetWriteDeadline</a></h3>
				<pre>func (c *TCPConn) SetWriteDeadline(t time.Time) error</pre>
				<p>
SetWriteDeadline implements the Conn SetWriteDeadline method.
</p>

				
				
			
				
				<h3 id="TCPConn.Write">func (*TCPConn) <a href="src/pkg/net/tcpsock_posix.htm#L89">Write</a></h3>
				<pre>func (c *TCPConn) Write(b []byte) (n int, err error)</pre>
				<p>
Write implements the Conn Write method.
</p>

				
				
			
		
			
			
			<h2 id="TCPListener">type <a href="src/pkg/net/tcpsock_posix.htm#L281">TCPListener</a></h2>
			<pre>type TCPListener struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
TCPListener is a TCP network listener.
Clients should typically use variables of type Listener
instead of assuming TCP.
</p>


			

			

			

			
				
				<h3 id="ListenTCP">func <a href="src/pkg/net/tcpsock_posix.htm#L289">ListenTCP</a></h3>
				<pre>func ListenTCP(net string, laddr *TCPAddr) (*TCPListener, error)</pre>
				<p>
ListenTCP announces on the TCP address laddr and returns a TCP listener.
Net must be &#34;tcp&#34;, &#34;tcp4&#34;, or &#34;tcp6&#34;.
If laddr has a port of 0, it means to listen on some available port.
The caller can use l.Addr() to retrieve the chosen address.
</p>

				
			

			
				
				<h3 id="TCPListener.Accept">func (*TCPListener) <a href="src/pkg/net/tcpsock_posix.htm#L319">Accept</a></h3>
				<pre>func (l *TCPListener) Accept() (c Conn, err error)</pre>
				<p>
Accept implements the Accept method in the Listener interface;
it waits for the next call and returns a generic Conn.
</p>

				
				
			
				
				<h3 id="TCPListener.AcceptTCP">func (*TCPListener) <a href="src/pkg/net/tcpsock_posix.htm#L306">AcceptTCP</a></h3>
				<pre>func (l *TCPListener) AcceptTCP() (c *TCPConn, err error)</pre>
				<p>
AcceptTCP accepts the next incoming call and returns the new connection
and the remote address.
</p>

				
				
			
				
				<h3 id="TCPListener.Addr">func (*TCPListener) <a href="src/pkg/net/tcpsock_posix.htm#L337">Addr</a></h3>
				<pre>func (l *TCPListener) Addr() Addr</pre>
				<p>
Addr returns the listener&#39;s network address, a *TCPAddr.
</p>

				
				
			
				
				<h3 id="TCPListener.Close">func (*TCPListener) <a href="src/pkg/net/tcpsock_posix.htm#L329">Close</a></h3>
				<pre>func (l *TCPListener) Close() error</pre>
				<p>
Close stops listening on the TCP address.
Already Accepted connections are not closed.
</p>

				
				
			
				
				<h3 id="TCPListener.File">func (*TCPListener) <a href="src/pkg/net/tcpsock_posix.htm#L351">File</a></h3>
				<pre>func (l *TCPListener) File() (f *os.File, err error)</pre>
				<p>
File returns a copy of the underlying os.File, set to blocking mode.
It is the caller&#39;s responsibility to close f when finished.
Closing l does not affect f, and closing f does not affect l.
</p>

				
				
			
				
				<h3 id="TCPListener.SetDeadline">func (*TCPListener) <a href="src/pkg/net/tcpsock_posix.htm#L341">SetDeadline</a></h3>
				<pre>func (l *TCPListener) SetDeadline(t time.Time) error</pre>
				<p>
SetDeadline sets the deadline associated with the listener.
A zero time value disables the deadline.
</p>

				
				
			
		
			
			
			<h2 id="UDPAddr">type <a href="src/pkg/net/udpsock.htm#L1">UDPAddr</a></h2>
			<pre>type UDPAddr struct {
    IP   IP
    Port int
}</pre>
			<p>
UDPAddr represents the address of a UDP end point.
</p>


			

			

			

			
				
				<h3 id="ResolveUDPAddr">func <a href="src/pkg/net/udpsock.htm#L20">ResolveUDPAddr</a></h3>
				<pre>func ResolveUDPAddr(net, addr string) (*UDPAddr, error)</pre>
				<p>
ResolveUDPAddr parses addr as a UDP address of the form
host:port and resolves domain names or port names to
numeric addresses on the network net, which must be &#34;udp&#34;,
&#34;udp4&#34; or &#34;udp6&#34;.  A literal IPv6 host address must be
enclosed in square brackets, as in &#34;[::]:80&#34;.
</p>

				
			

			
				
				<h3 id="UDPAddr.Network">func (*UDPAddr) <a href="src/pkg/net/udpsock.htm#L6">Network</a></h3>
				<pre>func (a *UDPAddr) Network() string</pre>
				<p>
Network returns the address&#39;s network name, &#34;udp&#34;.
</p>

				
				
			
				
				<h3 id="UDPAddr.String">func (*UDPAddr) <a href="src/pkg/net/udpsock.htm#L8">String</a></h3>
				<pre>func (a *UDPAddr) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="UDPConn">type <a href="src/pkg/net/udpsock_posix.htm#L50">UDPConn</a></h2>
			<pre>type UDPConn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
UDPConn is the implementation of the Conn and PacketConn
interfaces for UDP network connections.
</p>


			

			

			

			
				
				<h3 id="DialUDP">func <a href="src/pkg/net/udpsock_posix.htm#L213">DialUDP</a></h3>
				<pre>func DialUDP(net string, laddr, raddr *UDPAddr) (*UDPConn, error)</pre>
				<p>
DialUDP connects to the remote address raddr on the network net,
which must be &#34;udp&#34;, &#34;udp4&#34;, or &#34;udp6&#34;.  If laddr is not nil, it is used
as the local address for the connection.
</p>

				
			
				
				<h3 id="ListenMulticastUDP">func <a href="src/pkg/net/udpsock_posix.htm#L253">ListenMulticastUDP</a></h3>
				<pre>func ListenMulticastUDP(net string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)</pre>
				<p>
ListenMulticastUDP listens for incoming multicast UDP packets
addressed to the group address gaddr on ifi, which specifies
the interface to join.  ListenMulticastUDP uses default
multicast interface if ifi is nil.
</p>

				
			
				
				<h3 id="ListenUDP">func <a href="src/pkg/net/udpsock_posix.htm#L233">ListenUDP</a></h3>
				<pre>func ListenUDP(net string, laddr *UDPAddr) (*UDPConn, error)</pre>
				<p>
ListenUDP listens for incoming UDP packets addressed to the
local address laddr.  The returned connection c&#39;s ReadFrom
and WriteTo methods can be used to receive and send UDP
packets with per-packet addressing.
</p>

				
			
				
				<h3 id="ListenUnixgram">func <a href="src/pkg/net/unixsock_posix.htm#L404">ListenUnixgram</a></h3>
				<pre>func ListenUnixgram(net string, laddr *UnixAddr) (*UDPConn, error)</pre>
				<p>
ListenUnixgram listens for incoming Unix datagram packets addressed to the
local address laddr.  The returned connection c&#39;s ReadFrom
and WriteTo methods can be used to receive and send UDP
packets with per-packet addressing.  The network net must be &#34;unixgram&#34;.
</p>

				
			

			
				
				<h3 id="UDPConn.Close">func (*UDPConn) <a href="src/pkg/net/udpsock_posix.htm#L77">Close</a></h3>
				<pre>func (c *UDPConn) Close() error</pre>
				<p>
Close closes the UDP connection.
</p>

				
				
			
				
				<h3 id="UDPConn.File">func (*UDPConn) <a href="src/pkg/net/udpsock_posix.htm#L208">File</a></h3>
				<pre>func (c *UDPConn) File() (f *os.File, err error)</pre>
				<p>
File returns a copy of the underlying os.File, set to blocking mode.
It is the caller&#39;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
</p>

				
				
			
				
				<h3 id="UDPConn.LocalAddr">func (*UDPConn) <a href="src/pkg/net/udpsock_posix.htm#L85">LocalAddr</a></h3>
				<pre>func (c *UDPConn) LocalAddr() Addr</pre>
				<p>
LocalAddr returns the local network address.
</p>

				
				
			
				
				<h3 id="UDPConn.Read">func (*UDPConn) <a href="src/pkg/net/udpsock_posix.htm#L61">Read</a></h3>
				<pre>func (c *UDPConn) Read(b []byte) (int, error)</pre>
				<p>
Read implements the Conn Read method.
</p>

				
				
			
				
				<h3 id="UDPConn.ReadFrom">func (*UDPConn) <a href="src/pkg/net/udpsock_posix.htm#L165">ReadFrom</a></h3>
				<pre>func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)</pre>
				<p>
ReadFrom implements the PacketConn ReadFrom method.
</p>

				
				
			
				
				<h3 id="UDPConn.ReadFromUDP">func (*UDPConn) <a href="src/pkg/net/udpsock_posix.htm#L150">ReadFromUDP</a></h3>
				<pre>func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error)</pre>
				<p>
ReadFromUDP reads a UDP packet from c, copying the payload into b.
It returns the number of bytes copied into b and the return address
that was on the packet.
</p>
<p>
ReadFromUDP can be made to time out and return an error with Timeout() == true
after a fixed time limit; see SetDeadline and SetReadDeadline.
</p>

				
				
			
				
				<h3 id="UDPConn.RemoteAddr">func (*UDPConn) <a href="src/pkg/net/udpsock_posix.htm#L93">RemoteAddr</a></h3>
				<pre>func (c *UDPConn) RemoteAddr() Addr</pre>
				<p>
RemoteAddr returns the remote network address, a *UDPAddr.
</p>

				
				
			
				
				<h3 id="UDPConn.SetDeadline">func (*UDPConn) <a href="src/pkg/net/udpsock_posix.htm#L101">SetDeadline</a></h3>
				<pre>func (c *UDPConn) SetDeadline(t time.Time) error</pre>
				<p>
SetDeadline implements the Conn SetDeadline method.
</p>

				
				
			
				
				<h3 id="UDPConn.SetReadBuffer">func (*UDPConn) <a href="src/pkg/net/udpsock_posix.htm#L126">SetReadBuffer</a></h3>
				<pre>func (c *UDPConn) SetReadBuffer(bytes int) error</pre>
				<p>
SetReadBuffer sets the size of the operating system&#39;s
receive buffer associated with the connection.
</p>

				
				
			
				
				<h3 id="UDPConn.SetReadDeadline">func (*UDPConn) <a href="src/pkg/net/udpsock_posix.htm#L109">SetReadDeadline</a></h3>
				<pre>func (c *UDPConn) SetReadDeadline(t time.Time) error</pre>
				<p>
SetReadDeadline implements the Conn SetReadDeadline method.
</p>

				
				
			
				
				<h3 id="UDPConn.SetWriteBuffer">func (*UDPConn) <a href="src/pkg/net/udpsock_posix.htm#L135">SetWriteBuffer</a></h3>
				<pre>func (c *UDPConn) SetWriteBuffer(bytes int) error</pre>
				<p>
SetWriteBuffer sets the size of the operating system&#39;s
transmit buffer associated with the connection.
</p>

				
				
			
				
				<h3 id="UDPConn.SetWriteDeadline">func (*UDPConn) <a href="src/pkg/net/udpsock_posix.htm#L117">SetWriteDeadline</a></h3>
				<pre>func (c *UDPConn) SetWriteDeadline(t time.Time) error</pre>
				<p>
SetWriteDeadline implements the Conn SetWriteDeadline method.
</p>

				
				
			
				
				<h3 id="UDPConn.Write">func (*UDPConn) <a href="src/pkg/net/udpsock_posix.htm#L69">Write</a></h3>
				<pre>func (c *UDPConn) Write(b []byte) (int, error)</pre>
				<p>
Write implements the Conn Write method.
</p>

				
				
			
				
				<h3 id="UDPConn.WriteTo">func (*UDPConn) <a href="src/pkg/net/udpsock_posix.htm#L194">WriteTo</a></h3>
				<pre>func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)</pre>
				<p>
WriteTo implements the PacketConn WriteTo method.
</p>

				
				
			
				
				<h3 id="UDPConn.WriteToUDP">func (*UDPConn) <a href="src/pkg/net/udpsock_posix.htm#L179">WriteToUDP</a></h3>
				<pre>func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)</pre>
				<p>
WriteToUDP writes a UDP packet to addr via c, copying the payload from b.
</p>
<p>
WriteToUDP can be made to time out and return
an error with Timeout() == true after a fixed time limit;
see SetDeadline and SetWriteDeadline.
On packet-oriented connections, write timeouts are rare.
</p>

				
				
			
		
			
			
			<h2 id="UnixAddr">type <a href="src/pkg/net/unixsock.htm#L1">UnixAddr</a></h2>
			<pre>type UnixAddr struct {
    Name string
    Net  string
}</pre>
			<p>
UnixAddr represents the address of a Unix domain socket end point.
</p>


			

			

			

			
				
				<h3 id="ResolveUnixAddr">func <a href="src/pkg/net/unixsock.htm#L27">ResolveUnixAddr</a></h3>
				<pre>func ResolveUnixAddr(net, addr string) (*UnixAddr, error)</pre>
				<p>
ResolveUnixAddr parses addr as a Unix domain socket address.
The string net gives the network name, &#34;unix&#34;, &#34;unixgram&#34; or
&#34;unixpacket&#34;.
</p>

				
			

			
				
				<h3 id="UnixAddr.Network">func (*UnixAddr) <a href="src/pkg/net/unixsock.htm#L6">Network</a></h3>
				<pre>func (a *UnixAddr) Network() string</pre>
				<p>
Network returns the address&#39;s network name, &#34;unix&#34; or &#34;unixgram&#34;.
</p>

				
				
			
				
				<h3 id="UnixAddr.String">func (*UnixAddr) <a href="src/pkg/net/unixsock.htm#L10">String</a></h3>
				<pre>func (a *UnixAddr) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="UnixConn">type <a href="src/pkg/net/unixsock_posix.htm#L103">UnixConn</a></h2>
			<pre>type UnixConn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
UnixConn is an implementation of the Conn interface
for connections to Unix domain sockets.
</p>


			

			

			

			
				
				<h3 id="DialUnix">func <a href="src/pkg/net/unixsock_posix.htm#L297">DialUnix</a></h3>
				<pre>func DialUnix(net string, laddr, raddr *UnixAddr) (*UnixConn, error)</pre>
				<p>
DialUnix connects to the remote address raddr on the network net,
which must be &#34;unix&#34; or &#34;unixgram&#34;.  If laddr is not nil, it is used
as the local address for the connection.
</p>

				
			

			
				
				<h3 id="UnixConn.Close">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L130">Close</a></h3>
				<pre>func (c *UnixConn) Close() error</pre>
				<p>
Close closes the Unix domain connection.
</p>

				
				
			
				
				<h3 id="UnixConn.File">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L292">File</a></h3>
				<pre>func (c *UnixConn) File() (f *os.File, err error)</pre>
				<p>
File returns a copy of the underlying os.File, set to blocking mode.
It is the caller&#39;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
</p>

				
				
			
				
				<h3 id="UnixConn.LocalAddr">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L139">LocalAddr</a></h3>
				<pre>func (c *UnixConn) LocalAddr() Addr</pre>
				<p>
LocalAddr returns the local network address, a *UnixAddr.
Unlike in other protocols, LocalAddr is usually nil for dialed connections.
</p>

				
				
			
				
				<h3 id="UnixConn.Read">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L114">Read</a></h3>
				<pre>func (c *UnixConn) Read(b []byte) (n int, err error)</pre>
				<p>
Read implements the Conn Read method.
</p>

				
				
			
				
				<h3 id="UnixConn.ReadFrom">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L218">ReadFrom</a></h3>
				<pre>func (c *UnixConn) ReadFrom(b []byte) (n int, addr Addr, err error)</pre>
				<p>
ReadFrom implements the PacketConn ReadFrom method.
</p>

				
				
			
				
				<h3 id="UnixConn.ReadFromUnix">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L205">ReadFromUnix</a></h3>
				<pre>func (c *UnixConn) ReadFromUnix(b []byte) (n int, addr *UnixAddr, err error)</pre>
				<p>
ReadFromUnix reads a packet from c, copying the payload into b.
It returns the number of bytes copied into b and the source address
of the packet.
</p>
<p>
ReadFromUnix can be made to time out and return
an error with Timeout() == true after a fixed time limit;
see SetDeadline and SetReadDeadline.
</p>

				
				
			
				
				<h3 id="UnixConn.ReadMsgUnix">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L260">ReadMsgUnix</a></h3>
				<pre>func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)</pre>
				<p>
ReadMsgUnix reads a packet from c, copying the payload into b
and the associated out-of-band data into oob.
It returns the number of bytes copied into b, the number of
bytes copied into oob, the flags that were set on the packet,
and the source address of the packet.
</p>

				
				
			
				
				<h3 id="UnixConn.RemoteAddr">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L149">RemoteAddr</a></h3>
				<pre>func (c *UnixConn) RemoteAddr() Addr</pre>
				<p>
RemoteAddr returns the remote network address, a *UnixAddr.
Unlike in other protocols, RemoteAddr is usually nil for connections
accepted by a listener.
</p>

				
				
			
				
				<h3 id="UnixConn.SetDeadline">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L157">SetDeadline</a></h3>
				<pre>func (c *UnixConn) SetDeadline(t time.Time) error</pre>
				<p>
SetDeadline implements the Conn SetDeadline method.
</p>

				
				
			
				
				<h3 id="UnixConn.SetReadBuffer">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L182">SetReadBuffer</a></h3>
				<pre>func (c *UnixConn) SetReadBuffer(bytes int) error</pre>
				<p>
SetReadBuffer sets the size of the operating system&#39;s
receive buffer associated with the connection.
</p>

				
				
			
				
				<h3 id="UnixConn.SetReadDeadline">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L165">SetReadDeadline</a></h3>
				<pre>func (c *UnixConn) SetReadDeadline(t time.Time) error</pre>
				<p>
SetReadDeadline implements the Conn SetReadDeadline method.
</p>

				
				
			
				
				<h3 id="UnixConn.SetWriteBuffer">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L191">SetWriteBuffer</a></h3>
				<pre>func (c *UnixConn) SetWriteBuffer(bytes int) error</pre>
				<p>
SetWriteBuffer sets the size of the operating system&#39;s
transmit buffer associated with the connection.
</p>

				
				
			
				
				<h3 id="UnixConn.SetWriteDeadline">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L173">SetWriteDeadline</a></h3>
				<pre>func (c *UnixConn) SetWriteDeadline(t time.Time) error</pre>
				<p>
SetWriteDeadline implements the Conn SetWriteDeadline method.
</p>

				
				
			
				
				<h3 id="UnixConn.Write">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L122">Write</a></h3>
				<pre>func (c *UnixConn) Write(b []byte) (n int, err error)</pre>
				<p>
Write implements the Conn Write method.
</p>

				
				
			
				
				<h3 id="UnixConn.WriteMsgUnix">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L275">WriteMsgUnix</a></h3>
				<pre>func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)</pre>
				<p>
WriteMsgUnix writes a packet to addr via c, copying the payload from b
and the associated out-of-band data from oob.  It returns the number
of payload and out-of-band bytes written.
</p>

				
				
			
				
				<h3 id="UnixConn.WriteTo">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L244">WriteTo</a></h3>
				<pre>func (c *UnixConn) WriteTo(b []byte, addr Addr) (n int, err error)</pre>
				<p>
WriteTo implements the PacketConn WriteTo method.
</p>

				
				
			
				
				<h3 id="UnixConn.WriteToUnix">func (*UnixConn) <a href="src/pkg/net/unixsock_posix.htm#L232">WriteToUnix</a></h3>
				<pre>func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (n int, err error)</pre>
				<p>
WriteToUnix writes a packet to addr via c, copying the payload from b.
</p>
<p>
WriteToUnix can be made to time out and return
an error with Timeout() == true after a fixed time limit;
see SetDeadline and SetWriteDeadline.
On packet-oriented connections, write timeouts are rare.
</p>

				
				
			
		
			
			
			<h2 id="UnixListener">type <a href="src/pkg/net/unixsock_posix.htm#L308">UnixListener</a></h2>
			<pre>type UnixListener struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
UnixListener is a Unix domain socket listener.
Clients should typically use variables of type Listener
instead of assuming Unix domain sockets.
</p>


			

			

			

			
				
				<h3 id="ListenUnix">func <a href="src/pkg/net/unixsock_posix.htm#L315">ListenUnix</a></h3>
				<pre>func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error)</pre>
				<p>
ListenUnix announces on the Unix domain socket laddr and returns a Unix listener.
Net must be &#34;unix&#34; (stream sockets).
</p>

				
			

			
				
				<h3 id="UnixListener.Accept">func (*UnixListener) <a href="src/pkg/net/unixsock_posix.htm#L350">Accept</a></h3>
				<pre>func (l *UnixListener) Accept() (c Conn, err error)</pre>
				<p>
Accept implements the Accept method in the Listener interface;
it waits for the next call and returns a generic Conn.
</p>

				
				
			
				
				<h3 id="UnixListener.AcceptUnix">func (*UnixListener) <a href="src/pkg/net/unixsock_posix.htm#L336">AcceptUnix</a></h3>
				<pre>func (l *UnixListener) AcceptUnix() (*UnixConn, error)</pre>
				<p>
AcceptUnix accepts the next incoming call and returns the new connection
and the remote address.
</p>

				
				
			
				
				<h3 id="UnixListener.Addr">func (*UnixListener) <a href="src/pkg/net/unixsock_posix.htm#L384">Addr</a></h3>
				<pre>func (l *UnixListener) Addr() Addr</pre>
				<p>
Addr returns the listener&#39;s network address.
</p>

				
				
			
				
				<h3 id="UnixListener.Close">func (*UnixListener) <a href="src/pkg/net/unixsock_posix.htm#L360">Close</a></h3>
				<pre>func (l *UnixListener) Close() error</pre>
				<p>
Close stops listening on the Unix address.
Already accepted connections are not closed.
</p>

				
				
			
				
				<h3 id="UnixListener.File">func (*UnixListener) <a href="src/pkg/net/unixsock_posix.htm#L398">File</a></h3>
				<pre>func (l *UnixListener) File() (f *os.File, err error)</pre>
				<p>
File returns a copy of the underlying os.File, set to blocking mode.
It is the caller&#39;s responsibility to close f when finished.
Closing l does not affect f, and closing f does not affect l.
</p>

				
				
			
				
				<h3 id="UnixListener.SetDeadline">func (*UnixListener) <a href="src/pkg/net/unixsock_posix.htm#L388">SetDeadline</a></h3>
				<pre>func (l *UnixListener) SetDeadline(t time.Time) (err error)</pre>
				<p>
SetDeadline sets the deadline associated with the listener.
A zero time value disables the deadline.
</p>

				
				
			
		
			
			
			<h2 id="UnknownNetworkError">type <a href="src/pkg/net/net.htm#L238">UnknownNetworkError</a></h2>
			<pre>type UnknownNetworkError string</pre>
			

			

			

			

			

			
				
				<h3 id="UnknownNetworkError.Error">func (UnknownNetworkError) <a href="src/pkg/net/net.htm#L240">Error</a></h3>
				<pre>func (e UnknownNetworkError) Error() string</pre>
				
				
				
			
				
				<h3 id="UnknownNetworkError.Temporary">func (UnknownNetworkError) <a href="src/pkg/net/net.htm#L241">Temporary</a></h3>
				<pre>func (e UnknownNetworkError) Temporary() bool</pre>
				
				
				
			
				
				<h3 id="UnknownNetworkError.Timeout">func (UnknownNetworkError) <a href="src/pkg/net/net.htm#L242">Timeout</a></h3>
				<pre>func (e UnknownNetworkError) Timeout() bool</pre>
				
				
				
			
		
		</div>
	

	
		<h2 id="bugs">Bugs</h2>
		
		<p>
On OpenBSD, listening on the &#34;tcp&#34; network does not listen for
both IPv4 and IPv6 connections. This is due to the fact that IPv4 traffic
will not be routed to an IPv6 socket - two separate sockets are required
if both AFs are to be supported. See inet6(4) on OpenBSD for details.
</p>

		
	







	
	
		<h2 id="subdirectories">Subdirectories</h2>
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>
	
		
			<tr>
			<td class="name"><a href="net_http.htm">http</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package http provides HTTP client and server implementations.</td>
			</tr>
		
	
		
			<tr>
			<td class="name">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="net_http_cgi.htm">cgi</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package cgi implements CGI (Common Gateway Interface) as specified in RFC 3875.</td>
			</tr>
		
	
		
			<tr>
			<td class="name">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="net_http_fcgi.htm">fcgi</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package fcgi implements the FastCGI protocol.</td>
			</tr>
		
	
		
			<tr>
			<td class="name">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="net_http_httptest.htm">httptest</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package httptest provides utilities for HTTP testing.</td>
			</tr>
		
	
		
			<tr>
			<td class="name">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="net_http_httputil.htm">httputil</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package httputil provides HTTP utility functions, complementing the more common ones in the net/http package.</td>
			</tr>
		
	
		
			<tr>
			<td class="name">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="net_http_pprof.hmt">pprof</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package pprof serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="net_mail.htm">mail</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package mail implements parsing of mail messages.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="net_rpc.htm">rpc</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package rpc provides access to the exported methods of an object across a network or other I/O connection.</td>
			</tr>
		
	
		
			<tr>
			<td class="name">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="net_rpc_jsonrpc.htm">jsonrpc</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package jsonrpc implements a JSON-RPC ClientCodec and ServerCodec for the rpc package.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="net_smtp.htm">smtp</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="net_textproto.htm">textproto</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package textproto implements generic support for text-based request/response protocols in the style of HTTP, NNTP, and SMTP.</td>
			</tr>
		
	
		
			<tr>
			<td class="name"><a href="net_url.htm">url</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package url parses URLs and implements query escaping.</td>
			</tr>
		
	
	</table>
	



</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
