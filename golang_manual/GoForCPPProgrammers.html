<!DOCTYPE html>
<html>
<head>
 <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" >
 <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" >
 
 <meta name="ROBOTS" content="NOARCHIVE">
 
 <link rel="icon" type="image/vnd.microsoft.icon" href="https://ssl.gstatic.com/codesite/ph/images/phosting.ico">
 
 
 <link rel="canonical" href="http://code.google.com/p/go-wiki/wiki/GoForCPPProgrammers" />
 
 <script type="text/javascript">
 
 
 
 
 var codesite_token = "vN8W-QGEa6r_0jhlgI9JPpJJ-b4:1336723203665";
 
 
 var CS_env = {"profileUrl":["/u/111292884696033638814/"],"token":"vN8W-QGEa6r_0jhlgI9JPpJJ-b4:1336723203665","assetHostPath":"https://ssl.gstatic.com/codesite/ph","domainName":null,"assetVersionPath":"https://ssl.gstatic.com/codesite/ph/7512473178023540559","projectHomeUrl":"/p/go-wiki","relativeBaseUrl":"","projectName":"go-wiki","loggedInUserEmail":"xiemengjun@gmail.com"};
 var _gaq = _gaq || [];
 _gaq.push(
 ['siteTracker._setAccount', 'UA-18071-1'],
 ['siteTracker._trackPageview']);
 
 (function() {
 var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
 ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
 (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ga);
 })();
 
 </script>
 
 
 <title>GoForCPPProgrammers - 
 go-wiki -
 
 Go for C++ Programmers - 
 Go Language Community Wiki - Google Project Hosting
 </title>
 <link type="text/css" rel="stylesheet" href="https://ssl.gstatic.com/codesite/ph/7512473178023540559/css/core.css">
 
 <link type="text/css" rel="stylesheet" href="https://ssl.gstatic.com/codesite/ph/7512473178023540559/css/ph_detail.css" >
 
 
 
 <link type="application/atom+xml" rel="alternate" href="/feeds/p/go-wiki/hgchanges/basic?repo=wiki&amp;path=/GoForCPPProgrammers.wiki">
 
 
<!--[if IE]>
 <link type="text/css" rel="stylesheet" href="https://ssl.gstatic.com/codesite/ph/7512473178023540559/css/d_ie.css" >
<![endif]-->
 <style type="text/css">
 .menuIcon.off { background: no-repeat url(https://ssl.gstatic.com/codesite/ph/images/dropdown_sprite.gif) 0 -42px }
 .menuIcon.on { background: no-repeat url(https://ssl.gstatic.com/codesite/ph/images/dropdown_sprite.gif) 0 -28px }
 .menuIcon.down { background: no-repeat url(https://ssl.gstatic.com/codesite/ph/images/dropdown_sprite.gif) 0 0; }
 
 
 #maincol {
 padding-top: 0;
 padding-bottom: 0;
 }

 
 </style>
</head>
<body class="t6">
<script type="text/javascript">
 window.___gcfg = {lang: 'en'};
 (function() 
 {var po = document.createElement("script");
 po.type = "text/javascript"; po.async = true;po.src = "https://apis.google.com/js/plusone.js";
 var s = document.getElementsByTagName("script")[0];
 s.parentNode.insertBefore(po, s);
 })();
</script>

<div id="mt" class="gtb"> 
 <a href="/p/go-wiki/" class="tab ">Project&nbsp;Home</a>
 
 
 
 
 
 
 <a href="/p/go-wiki/w/list" class="tab active">Wiki</a>
 
 
 
 
 
 
 
 
 
 
 
 <div class=gtbc></div>
</div>
<table cellspacing="0" cellpadding="0" width="100%" align="center" border="0" class="st">
 <tr>
 
 
 
 
 <td class="subt">
 <div class="issueDetail">
<div class="isf">
 
 <span class="inIssueList"> 
 <span>Search</span>
 <form action="/p/go-wiki/w/list" method="GET" style="display:inline">
 <select id="can" name="can" >
 <option disabled="disabled">Search within:</option>
 
 <option value="1" >&nbsp;All wiki pages</option>
 <option value="3" >&nbsp;Featured pages</option>
 <option value="2" selected="selected">&nbsp;Current pages</option>
 
 
 <option value="5" >&nbsp;My starred pages</option>
 
 <option value="4" >&nbsp;Deprecated pages</option>
 
 </select>
 <span>for</span>
 <span id="qq"><input type="text" size="38" id="searchq" name="q" value=""
 autocomplete="off" ></span>
 
 
 
 <input type="submit" value="Search" >
 </form>
 </span>

 
 
 
 
 
 
 

</div>
</div>

 </td>
 
 
 
 
 
 
 <td align="right" valign="top" class="bevel-right"></td>
 </tr>
</table>


<script type="text/javascript">
 var cancelBubble = false;
 function _go(url) { document.location = url; }
</script>
<div id="maincol"
 
>

 
<!-- IE -->







 <style type="text/css">
 .delcom { background: #e8e8e8 }
 .commentcontent {
 margin: 2em;
 padding: 0px 10px;
 width: 66em;
 }
 .artifactcomment {
 border-top: 3px solid #c3d9ff;
 }
 #commentform {
 border-top: 3px solid #c3d9ff;
 }
 </style>

<div id="wikipage">
<table>
 <tr>
 
 
 <td style="vertical-align:top; padding-left:5px">
 
 <div id="wikiheader">
 
 <img width="15" height="15" id="star_img"
 src="https://ssl.gstatic.com/codesite/ph/images/star_off.gif"
 style="cursor:pointer"
 onclick="_CS_toggleStar(this,
 {'scope': 'wiki',
 'user': '_CURRENT_USER',
 'item': 'go-wiki:GoForCPPProgrammers'
 });"/>
 
 <span style="font-size:120%;font-weight:bold">GoForCPPProgrammers</span>
 &nbsp;
 <div> 
 
 <i>Go for C++ Programmers</i>
 
 
 
 <div id="wikiauthor" style="float:right">
 Updated <span title="Tue Mar  6 15:55:30 2012">
 Mar 6, 2012</span>
 
 by <a style="white-space: nowrap" href="/u/106387542691710977843/">a...@golang.org</a>
 
 </div>
 </div>
 </div>
 
 <div id="wikicontent">
 <div class="vt" id="wikimaincol">
 <p>Go is a systems programming language intended to be a general-purpose systems language, like C++.  These are some notes on Go for experienced C++ programmers. This document discusses the differences between Go and C++, and says little to nothing about the similarities. </p><p>For a more general introduction to Go, see the <a href="http://tour.golang.org/" rel="nofollow">Go Tour</a>, <a href="http://golang.org/doc/code.html" rel="nofollow">How to Write Go Code</a> and <a href="http://golang.org/doc/effective_go.html" rel="nofollow">Effective Go</a>. </p><p>For a detailed description of the Go language, see the <a href="http://golang.org/doc/go_spec.html" rel="nofollow">Go spec</a>. </p><p><h2>Conceptual Differences</h2> </p><p><ul> <li>Go does not have classes with constructors or destructors.  Instead of class methods, a class inheritance hierarchy, and virtual functions, Go provides <em>interfaces</em>, which are discussed in more detail below. Interfaces are also used where C++ uses templates.</li> </p><p><li>Go uses garbage collection. It is not necessary (or possible) to release memory explicitly.</li> </p><p><li>Go has pointers but not pointer arithmetic. You cannot use a pointer variable to walk through the bytes of a string.</li> </p><p><li>Arrays in Go are first class values. When an array is used as a function parameter, the function receives a copy of the array, not a pointer to it. However, in practice functions often use slices for parameters; slices hold pointers to underlying arrays.  Slices are discussed further below.</li> </p><p><li>Strings are provided by the language. They may not be changed once they have been created.</li> </p><p><li>Hash tables are provided by the language. They are called maps.</li> </p><p><li>Separate threads of execution, and communication channels between them, are provided by the language. This is discussed further below.</li> </p><p><li>Certain types (maps and channels, described further below) are passed by reference, not by value. That is, passing a map to a function does not copy the map, and if the function changes the map the change will be seen by the caller. In C++ terms, one can think of these as being reference types.</li> </p><p><li>Go does not use header files. Instead, each source file is part of a defined <em>package</em>. When a package defines an object (type, constant, variable, function) with a name starting with an upper case letter, that object is visible to any other file which imports that package.</li> </p><p><li>Go does not support implicit type conversion. Operations that mix different types require casts (called conversions in Go).</li> </p><p><li>Go does not support function overloading and does not support user defined operators.</li> </p><p><li>Go does not support <tt>const</tt> or <tt>volatile</tt> qualifiers.</li> </p><p><li>Go uses <tt>nil</tt> for invalid pointers, where C++ uses <tt>NULL</tt> or simply <tt>0</tt>.</li> </ul> </p><p><h2>Syntax</h2> </p><p>The declaration syntax is reversed compared to C++. You write the name followed by the type. Unlike in C++, the syntax for a type does not match the way in which the variable is used. Type declarations may be read easily from left to right. </p><pre class="prettyprint">Go                           C++
var v1 int                // int v1;
var v2 string             // const std::string v2;  (approximately)
var v3 [10]int            // int v3[10];
var v4 []int              // int* v4;  (approximately)
var v5 struct { f int }   // struct { int f; } v5;
var v6 *int               // int* v6;  (but no pointer arithmetic)
var v7 map[string]int     // unordered_map&lt;string, int&gt;* v7;  (approximately)
var v8 func(a int) int    // int (*v8)(int a);</pre><p>Declarations generally take the form of a keyword followed by the name of the object being declared.  The keyword is one of <tt>var</tt>, <tt>func</tt>, <tt>const</tt>, or <tt>type</tt>.  Method declarations are a minor exception in that the receiver appears before the name of the object being declared; see the <a rel="nofollow">discussion of interfaces</a>. </p><p>You can also use a keyword followed by a series of declarations in parentheses. </p><pre class="prettyprint">var (
    i int
    m float64
)</pre><p>When declaring a function, you must either provide a name for each parameter or not provide a name for any parameter; you can&#x27;t omit some names and provide others.  You may group several names with the same type: </p><pre class="prettyprint">func f(i, j, k int, s, t string)</pre><p>A variable may be initialized when it is declared.  When this is done, specifying the type is permitted but not required.  When the type is not specified, the type of the variable is the type of the initialization expression. </p><pre class="prettyprint">var v = *p</pre><p>See also the <a rel="nofollow">discussion of constants, below</a>. If a variable is not initialized explicitly, the type must be specified. In that case it will be implicitly initialized to the type&#x27;s zero value (<tt>0</tt>, <tt>nil</tt>, etc.).  There are no uninitialized variables in Go. </p><p>Within a function, a short declaration syntax is available with <tt>:=</tt> . </p><pre class="prettyprint">v1 := v2</pre><p>This is equivalent to </p><pre class="prettyprint">var v1 = v2</pre><p>Go permits multiple assignments, which are done in parallel. </p><pre class="prettyprint">i, j = j, i    // Swap i and j.</pre><p>Functions may have multiple return values, indicated by a list in parentheses.  The returned values can be stored by assignment to a list of variables. </p><pre class="prettyprint">func f() (i int, j int) { ... }
v1, v2 = f()</pre><p>Go code uses very few semicolons in practice.  Technically, all Go statements are terminated by a semicolon.  However, Go treats the end of a non-blank line as a semicolon unless the line is clearly incomplete (the exact rules are in <a rel="nofollow">the language specification</a>). A consequence of this is that in some cases Go does not permit you to use a line break.  For example, you may not write </p><pre class="prettyprint">func g()
{                  // INVALID
}</pre><p>A semicolon will be inserted after <tt>g()</tt>, causing it to be a function declaration rather than a function definition.  Similarly, you may not write </p><pre class="prettyprint">if x {
}
else {             // INVALID
}</pre><p>A semicolon will be inserted after the <tt>}</tt> preceding the <tt>else</tt>, causing a syntax error. </p><p>Since semicolons do end statements, you may continue using them as in C++.  However, that is not the recommended style.  Idiomatic Go code omits unnecessary semicolons, which in practice is all of them other than the initial <tt>for</tt> loop clause and cases where you want several short statements on a single line. </p><p>While we&#x27;re on the topic, we recommend that rather than worry about semicolons and brace placement, you format your code with the <tt>gofmt</tt> program.  That will produce a single standard Go style, and let you worry about your code rather than your formatting.  While the style may initially seem odd, it is as good as any other style, and familiarity will lead to comfort. </p><p>When using a pointer to a struct, you use <tt>.</tt> instead of <tt>-&gt;</tt>. Thus syntactically speaking a structure and a pointer to a structure are used in the same way. </p><pre class="prettyprint">type myStruct struct { i int }
var v9 myStruct              // v9 has structure type
var p9 *myStruct             // p9 is a pointer to a structure
f(v9.i, p9.i)</pre><p>Go does not require parentheses around the condition of an <tt>if</tt> statement, or the expressions of a <tt>for</tt> statement, or the value of a <tt>switch</tt> statement.  On the other hand, it does require curly braces around the body of an <tt>if</tt> or <tt>for</tt> statement. </p><pre class="prettyprint">if a &lt; b { f() }             // Valid
if (a &lt; b) { f() }           // Valid (condition is a parenthesized expression)
if (a &lt; b) f()               // INVALID
for i = 0; i &lt; 10; i++ {}    // Valid
for (i = 0; i &lt; 10; i++) {}  // INVALID</pre><p>Go does not have a <tt>while</tt> statement nor does it have a <tt>do/while</tt> statement.  The <tt>for</tt> statement may be used with a single condition, which makes it equivalent to a <tt>while</tt> statement.  Omitting the condition entirely is an endless loop. </p><p>Go permits <tt>break</tt> and <tt>continue</tt> to specify a label. The label must refer to a <tt>for</tt>, <tt>switch</tt>, or <tt>select</tt> statement. </p><p>In a <tt>switch</tt> statement, <tt>case</tt> labels do not fall through.  You can make them fall through using the <tt>fallthrough</tt> keyword.  This applies even to adjacent cases. </p><pre class="prettyprint">switch i {
case 0:  // empty case body
case 1:
    f()  // f is not called when i == 0!
}</pre><p>But a <tt>case</tt> can have multiple values. </p><pre class="prettyprint">switch i {
case 0, 1:
    f()  // f is called if i == 0 || i == 1.
}</pre><p>The values in a <tt>case</tt> need not be constants--or even integers; any type that supports the equality comparison operator, such as strings or pointers, can be used--and if the <tt>switch</tt> value is omitted it defaults to <tt>true</tt>. </p><pre class="prettyprint">switch {
case i &lt; 0:
    f1()
case i == 0:
    f2()
case i &gt; 0:
    f3()
}</pre><p>The <tt>++</tt> and <tt>--</tt> operators may only be used in statements, not in expressions. You cannot write <tt>c = *p++</tt>.  <tt>*p++</tt> is parsed as <tt>(*p)++</tt>. </p><p>The <tt>defer</tt> statement may be used to call a function after the function containing the <tt>defer</tt> statement returns. </p><pre class="prettyprint">fd := open(&quot;filename&quot;)
defer close(fd)         // fd will be closed when this function returns.</pre><p><h2>Constants </h2> </p><p>In Go constants may be <i>untyped</i>. This applies even to constants named with a <tt>const</tt> declaration, if no type is given in the declaration and the initializer expression uses only untyped constants. A value derived from an untyped constant becomes typed when it is used within a context that requires a typed value. This permits constants to be used relatively freely without requiring general implicit type conversion. </p><pre class="prettyprint">var a uint
f(a + 1)  // untyped numeric constant &quot;1&quot; becomes typed as uint</pre><p>The language does not impose any limits on the size of an untyped numeric constant or constant expression. A limit is only applied when a constant is used where a type is required. </p><pre class="prettyprint">const huge = 1 &lt;&lt; 100
f(huge &gt;&gt; 98)</pre><p>Go does not support enums.  Instead, you can use the special name <tt>iota</tt> in a single <tt>const</tt> declaration to get a series of increasing value.  When an initialization expression is omitted for a <tt>const</tt>, it reuses the preceding expression. </p><pre class="prettyprint">const (
    red = iota   // red == 0
    blue         // blue == 1
    green        // green == 2
)</pre><p><h2>Slices</h2> </p><p>A slice is conceptually a struct with three fields: a pointer to an array, a length, and a capacity. Slices support the <tt>[]</tt> operator to access elements of the underlying array. The builtin <tt>len</tt> function returns the length of the slice.  The builtin <tt>cap</tt> function returns the capacity. </p><p>Given an array, or another slice, a new slice is created via <tt>a[i:j]</tt>.  This creates a new slice which refers to <tt>a</tt>, starts at index <tt>i</tt>, and ends before index <tt>j</tt>.  It has length <tt>j-i</tt>. If <tt>i</tt> is omitted, the slice starts at <tt>0</tt>. If <tt>j</tt> is omitted, the slice ends at <tt>len(a)</tt>. The new slice refers to the same array to which <tt>a</tt> refers.  That is, changes made using the new slice may be seen using <tt>a</tt>.  The capacity of the new slice is simply the capacity of <tt>a</tt> minus <tt>i</tt>.  The capacity of an array is the length of the array. </p><p>What this means is that Go uses slices for some cases where C++ uses pointers. If you create a value of type <tt>[100]byte</tt> (an array of 100 bytes, perhaps a buffer) and you want to pass it to a function without copying it, you should declare the function parameter to have type <tt>[]byte</tt>, and pass a slice of the array (<tt>a[:]</tt> will pass the entire array). Unlike in C++, it is not necessary to pass the length of the buffer; it is efficiently accessible via <tt>len</tt>. </p><p>The slice syntax may also be used with a string.  It returns a new string, whose value is a substring of the original string. Because strings are immutable, string slices can be implemented without allocating new storage for the slices&#x27;s contents. </p><p><h2>Making values</h2> </p><p>Go has a builtin function <tt>new</tt> which takes a type and allocates space on the heap. The allocated space will be zero-initialized for the type. For example, <tt>new(int)</tt> allocates a new int on the heap, initializes it with the value <tt>0</tt>, and returns its address, which has type <tt>*int</tt>. Unlike in C++, <tt>new</tt> is a function, not an operator; <tt>new int</tt> is a syntax error. </p><p>Perhaps surprisingly, <tt>new</tt> is not commonly used in Go programs.  In Go taking the address of a variable is always safe and never yields a dangling pointer.  If the program takes the address of a variable, it will be allocated on the heap if necessary.  So these functions are equivalent: </p><pre class="prettyprint">type S { I int }

func f1() *S {
	return new(S)
}

func f2() *S {
	var s S
	return &amp;s
}

func f3() *S {
	// More idiomatic: use composite literal syntax.
	return &amp;S{0}
}</pre><p>Map and channel values must be allocated using the builtin function <tt>make</tt>. A variable declared with map or channel type without an initializer will be automatically initialized to <tt>nil</tt>. Calling <tt>make(map[int]int)</tt> returns a newly allocated value of type <tt>map[int]int</tt>. Note that <tt>make</tt> returns a value, not a pointer.  This is consistent with the fact that map and channel values are passed by reference.  Calling <tt>make</tt> with a map type takes an optional argument which is the expected capacity of the map.  Calling <tt>make</tt> with a channel type takes an optional argument which sets the buffering capacity of the channel; the default is 0 (unbuffered). </p><p>The <tt>make</tt> function may also be used to allocate a slice. In this case it allocates memory for the underlying array and returns a slice referring to it. There is one required argument, which is the number of elements in the slice. A second, optional, argument is the capacity of the slice.  For example, <tt>make([]int, 10, 20)</tt>.  This is identical to <tt>new([20]int)[0:10]</tt>.  Since Go uses garbage collection, the newly allocated array will be discarded sometime after there are no references to the returned slice. </p><p><h2>Interfaces</h2> </p><p>Where C++ provides classes, subclasses and templates, Go provides interfaces.  A Go interface is similar to a C++ pure abstract class: a class with no data members, with methods which are all pure virtual.  However, in Go, any type which provides the methods named in the interface may be treated as an implementation of the interface.  No explicitly declared inheritance is required.  The implementation of the interface is entirely separate from the interface itself. </p><p>A method looks like an ordinary function definition, except that it has a <em>receiver</em>.  The receiver is similar to the <tt>this</tt> pointer in a C++ class method. </p><pre class="prettyprint">type myType struct { i int }
func (p *myType) Get() int { return p.i }</pre><p>This declares a method <tt>Get</tt> associated with <tt>myType</tt>. The receiver is named <tt>p</tt> in the body of the function. </p><p>Methods are defined on named types.  If you convert the value to a different type, the new value will have the methods of the new type, not the old type. </p><p>You may define methods on a builtin type by declaring a new named type derived from it.  The new type is distinct from the builtin type. </p><pre class="prettyprint">type myInteger int
func (p myInteger) Get() int { return int(p) } // Conversion required.
func f(i int) { }
var v myInteger
// f(v) is invalid.
// f(int(v)) is valid; int(v) has no defined methods.</pre><p>Given this interface: </p><pre class="prettyprint">type myInterface interface {
	Get() int
	Set(i int)
}</pre><p>we can make <tt>myType</tt> satisfy the interface by adding </p><pre class="prettyprint">func (p *myType) Set(i int) { p.i = i }</pre><p>Now any function which takes <tt>myInterface</tt> as a parameter will accept a variable of type <tt>*myType</tt>. </p><pre class="prettyprint">func GetAndSet(x myInterface) {}
func f1() {
	var p myType
	GetAndSet(&amp;p)
}</pre><p>In other words, if we view <tt>myInterface</tt> as a C++ pure abstract base class, defining <tt>Set</tt> and <tt>Get</tt> for <tt>*myType</tt> made <tt>*myType</tt> automatically inherit from <tt>myInterface</tt>.  A type may satisfy multiple interfaces. </p><p>An anonymous field may be used to implement something much like a C++ child class. </p><pre class="prettyprint">type myChildType struct { myType; j int }
func (p *myChildType) Get() int { p.j++; return p.myType.Get() }</pre><p>This effectively implements <tt>myChildType</tt> as a child of <tt>myType</tt>. </p><pre class="prettyprint">func f2() {
	var p myChildType
	GetAndSet(&amp;p)
}</pre><p>The <tt>set</tt> method is effectively inherited from <tt>myType</tt>, because methods associated with the anonymous field are promoted to become methods of the enclosing type.  In this case, because <tt>myChildType</tt> has an anonymous field of type <tt>myType</tt>, the methods of <tt>myType</tt> also become methods of <tt>myChildType</tt>. In this example, the <tt>Get</tt> method was overridden, and the <tt>Set</tt> method was inherited. </p><p>This is not precisely the same as a child class in C++. When a method of an anonymous field is called, its receiver is the field, not the surrounding struct. In other words, methods on anonymous fields are not virtual functions. When you want the equivalent of a virtual function, use an interface. </p><p>A variable that has an interface type may be converted to have a different interface type using a special construct called a type assertion. This is implemented dynamically at run time, like C++ <tt>dynamic_cast</tt>.  Unlike <tt>dynamic_cast</tt>, there does not need to be any declared relationship between the two interfaces. </p><pre class="prettyprint">type myPrintInterface interface {
	Print()
}
func f3(x myInterface) {
	x.(myPrintInterface).Print()  // type assertion to myPrintInterface
}</pre><p>The conversion to <tt>myPrintInterface</tt> is entirely dynamic. It will work as long as the underlying type of x (the <em>dynamic type</em>) defines a <tt>print</tt> method. </p><p>Because the conversion is dynamic, it may be used to implement generic programming similar to templates in C++.  This is done by manipulating values of the minimal interface. </p><pre class="prettyprint">type Any interface { }</pre><p>Containers may be written in terms of <tt>Any</tt>, but the caller must unbox using a type assertion to recover values of the contained type.  As the typing is dynamic rather than static, there is no equivalent of the way that a C++ template may inline the relevant operations.  The operations are fully type-checked at run time, but all operations will involve a function call. </p><pre class="prettyprint">type Iterator interface {
	Get() Any
	Set(v Any)
	Increment()
	Equal(arg Iterator) bool
}</pre><p>Note that <tt>Equal</tt> has an argument of type <tt>Iterator</tt>.  This does not behave like a C++ template.  See <a rel="nofollow">the FAQ</a>. </p><p><h2>Goroutines</h2> </p><p>Go permits starting a new thread of execution (a <em>goroutine</em>) using the <tt>go</tt> statement.  The <tt>go</tt> statement runs a function in a different, newly created, goroutine. All goroutines in a single program share the same address space. </p><p>Internally, goroutines act like coroutines that are multiplexed among multiple operating system threads.  You do not have to worry about these details. </p><pre class="prettyprint">func server(i int) {
	for {
		fmt.Print(i)
		time.Sleep(10 * time.Second)
	}
}
go server(1)
go server(2)</pre><p>(Note that the <tt>for</tt> statement in the <tt>server</tt> function is equivalent to a C++ <tt>while (true)</tt> loop.) </p><p>Goroutines are (intended to be) cheap. </p><p>Function literals (which Go implements as closures) can be useful with the <tt>go</tt> statement. </p><pre class="prettyprint">var g int
go func(i int) {
	s := 0
	for j := 0; j &lt; i; j++ { s += j }
	g = s
}(1000)  // Passes argument 1000 to the function literal.</pre><p><h2>Channels</h2> </p><p>Channels are used to communicate between goroutines.  Any value may be sent over a channel.  Channels are (intended to be) efficient and cheap.  To send a value on a channel, use <tt>&lt;-</tt> as a binary operator.  To receive a value on a channel, use <tt>&lt;-</tt> as a unary operator. When calling functions, channels are passed by reference. </p><p>The Go library provides mutexes, but you can also use a single goroutine with a shared channel. Here is an example of using a manager function to control access to a single value. </p><pre class="prettyprint">type Cmd struct { Get bool; Val int }
func Manager(ch chan Cmd) {
	val := 0
	for {
		c := &lt;-ch
		if c.Get { c.Val = val; ch &lt;- c }
		else { val = c.Val }
	}
}</pre><p>In that example the same channel is used for input and output. This is incorrect if there are multiple goroutines communicating with the manager at once: a goroutine waiting for a response from the manager might receive a request from another goroutine instead. A solution is to pass in a channel. </p><pre class="prettyprint">type Cmd2 struct { Get bool; Val int; Ch &lt;- chan int }
func Manager2(ch chan Cmd2) {
	val := 0
	for {
		c := &lt;-ch
		if c.Get { c.ch &lt;- val }
		else { val = c.Val }
	}
}</pre><p>To use <tt>Manager2</tt>, given a channel to it: </p><pre class="prettyprint">func f4(ch &lt;- chan Cmd2) int {
	myCh := make(chan int)
	c := Cmd2{ true, 0, myCh }   // Composite literal syntax.
	ch &lt;- c
	return &lt;-myCh
}</pre>
 </div>
 </div>
 </td><tr>
</table>
 </div>


 
 
 
 <form name="delcom" action="../w/delComment.do" method="POST">
 <input type="hidden" name="sequence_num" value="" >
 <input type="hidden" name="create_time" value="" >
 <input type="hidden" name="mode" value="" >
 <input type="hidden" name="pagename" value="GoForCPPProgrammers" >
 <input type="hidden" name="token" value="vN8W-QGEa6r_0jhlgI9JPpJJ-b4:1336723203665" >
 </form>



 <script src="https://ssl.gstatic.com/codesite/ph/7512473178023540559/js/prettify/prettify.js"></script>
 <script type="text/javascript">
 prettyPrint();
 </script>

<script type="text/javascript" src="https://ssl.gstatic.com/codesite/ph/7512473178023540559/js/dit_scripts.js"></script>



  
 
 
 <script type="text/javascript" src="https://ssl.gstatic.com/codesite/ph/7512473178023540559/js/ph_core.js"></script>
 
 
 
 
 <script type="text/javascript" src="/js/codesite_product_dictionary_ph.pack.04102009.js"></script>
</div> 
<div id="footer" dir="ltr">
 <div class="text">
 <a href="/projecthosting/terms.html">Terms</a> -
 <a href="http://www.google.com/privacy.html">Privacy</a> -
 <a href="/p/support/">Project Hosting Help</a>
 </div>
</div>
 <div class="hostedBy" style="margin-top: -20px;">
 <span style="vertical-align: top;">Powered by <a href="http://code.google.com/projecthosting/">Google Project Hosting</a></span>
 </div>
 
 


 
 </body>
</html>

