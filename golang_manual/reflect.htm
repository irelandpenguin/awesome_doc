
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>reflect - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package reflect</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "reflect"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package reflect implements run-time reflection, allowing a program to
manipulate objects with arbitrary types.  The typical use is to take a value
with static type interface{} and extract its dynamic type information by
calling TypeOf, which returns a Type.
</p>
<p>
A call to ValueOf returns a Value representing the run-time data.
Zero takes a Type and returns a Value representing a zero value
for that type.
</p>
<p>
See &#34;The Laws of Reflection&#34; for an introduction to reflection in Go:
<a href="http://golang.org/doc/articles/laws_of_reflection.html">http://golang.org/doc/articles/laws_of_reflection.html</a>
</p>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#Copy">func Copy(dst, src Value) int</a></dd>
			
				
				<dd><a href="#DeepEqual">func DeepEqual(a1, a2 interface{}) bool</a></dd>
			
			
				
				<dd><a href="#ChanDir">type ChanDir</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ChanDir.String">func (d ChanDir) String() string</a></dd>
				
			
				
				<dd><a href="#Kind">type Kind</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Kind.String">func (k Kind) String() string</a></dd>
				
			
				
				<dd><a href="#Method">type Method</a></dd>
				
				
			
				
				<dd><a href="#SliceHeader">type SliceHeader</a></dd>
				
				
			
				
				<dd><a href="#StringHeader">type StringHeader</a></dd>
				
				
			
				
				<dd><a href="#StructField">type StructField</a></dd>
				
				
			
				
				<dd><a href="#StructTag">type StructTag</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#StructTag.Get">func (tag StructTag) Get(key string) string</a></dd>
				
			
				
				<dd><a href="#Type">type Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PtrTo">func PtrTo(t Type) Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeOf">func TypeOf(i interface{}) Type</a></dd>
				
				
			
				
				<dd><a href="#Value">type Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Append">func Append(s Value, x ...Value) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AppendSlice">func AppendSlice(s, t Value) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Indirect">func Indirect(v Value) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeChan">func MakeChan(typ Type, buffer int) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeMap">func MakeMap(typ Type) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeSlice">func MakeSlice(typ Type, len, cap int) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#New">func New(typ Type) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAt">func NewAt(typ Type, p unsafe.Pointer) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ValueOf">func ValueOf(i interface{}) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Zero">func Zero(typ Type) Value</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Addr">func (v Value) Addr() Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Bool">func (v Value) Bool() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Bytes">func (v Value) Bytes() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Call">func (v Value) Call(in []Value) []Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.CallSlice">func (v Value) CallSlice(in []Value) []Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.CanAddr">func (v Value) CanAddr() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.CanInterface">func (v Value) CanInterface() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.CanSet">func (v Value) CanSet() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Cap">func (v Value) Cap() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Close">func (v Value) Close()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Complex">func (v Value) Complex() complex128</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Elem">func (v Value) Elem() Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Field">func (v Value) Field(i int) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.FieldByIndex">func (v Value) FieldByIndex(index []int) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.FieldByName">func (v Value) FieldByName(name string) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.FieldByNameFunc">func (v Value) FieldByNameFunc(match func(string) bool) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Float">func (v Value) Float() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Index">func (v Value) Index(i int) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Int">func (v Value) Int() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Interface">func (v Value) Interface() (i interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.InterfaceData">func (v Value) InterfaceData() [2]uintptr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.IsNil">func (v Value) IsNil() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.IsValid">func (v Value) IsValid() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Kind">func (v Value) Kind() Kind</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Len">func (v Value) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.MapIndex">func (v Value) MapIndex(key Value) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.MapKeys">func (v Value) MapKeys() []Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Method">func (v Value) Method(i int) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.MethodByName">func (v Value) MethodByName(name string) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.NumField">func (v Value) NumField() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.NumMethod">func (v Value) NumMethod() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.OverflowComplex">func (v Value) OverflowComplex(x complex128) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.OverflowFloat">func (v Value) OverflowFloat(x float64) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.OverflowInt">func (v Value) OverflowInt(x int64) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.OverflowUint">func (v Value) OverflowUint(x uint64) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Pointer">func (v Value) Pointer() uintptr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Recv">func (v Value) Recv() (x Value, ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Send">func (v Value) Send(x Value)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Set">func (v Value) Set(x Value)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.SetBool">func (v Value) SetBool(x bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.SetBytes">func (v Value) SetBytes(x []byte)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.SetComplex">func (v Value) SetComplex(x complex128)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.SetFloat">func (v Value) SetFloat(x float64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.SetInt">func (v Value) SetInt(x int64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.SetLen">func (v Value) SetLen(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.SetMapIndex">func (v Value) SetMapIndex(key, val Value)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.SetPointer">func (v Value) SetPointer(x unsafe.Pointer)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.SetString">func (v Value) SetString(x string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.SetUint">func (v Value) SetUint(x uint64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Slice">func (v Value) Slice(beg, end int) Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.String">func (v Value) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.TryRecv">func (v Value) TryRecv() (x Value, ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.TrySend">func (v Value) TrySend(x Value) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Type">func (v Value) Type() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Uint">func (v Value) Uint() uint64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.UnsafeAddr">func (v Value) UnsafeAddr() uintptr</a></dd>
				
			
				
				<dd><a href="#ValueError">type ValueError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ValueError.Error">func (e *ValueError) Error() string</a></dd>
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/reflect/deepequal.htm">deepequal.go</a>
			
				<a href="src/pkg/reflect/type.htm">type.go</a>
			
				<a href="src/pkg/reflect/value.htm">value.go</a>
			
			</span>
			</p>
		
	
		
		
		
			
			
			<h2 id="Copy">func <a href="src/pkg/reflect/value.htm#L1561">Copy</a></h2>
			<pre>func Copy(dst, src Value) int</pre>
			<p>
Copy copies the contents of src into dst until either
dst has been filled or src has been exhausted.
It returns the number of elements copied.
Dst and src each must have kind Slice or Array, and
dst and src must have the same element type.
</p>

			
		
			
			
			<h2 id="DeepEqual">func <a href="src/pkg/reflect/deepequal.htm#L118">DeepEqual</a></h2>
			<pre>func DeepEqual(a1, a2 interface{}) bool</pre>
			<p>
DeepEqual tests for deep equality. It uses normal == equality where possible
but will scan members of arrays, slices, maps, and fields of structs. It correctly
handles recursive types. Functions are equal only if they are both nil.
</p>

			
		
		
			
			
			<h2 id="ChanDir">type <a href="src/pkg/reflect/type.htm#L263">ChanDir</a></h2>
			<pre>type ChanDir int</pre>
			<p>
ChanDir represents a channel type&#39;s direction.
</p>


			
				<pre>const (
    RecvDir ChanDir             = 1 &lt;&lt; iota <span class="comment">// &lt;-chan</span>
    SendDir                                 <span class="comment">// chan&lt;-</span>
    BothDir = RecvDir | SendDir             <span class="comment">// chan</span>
)</pre>
				
			

			

			

			

			
				
				<h3 id="ChanDir.String">func (ChanDir) <a href="src/pkg/reflect/type.htm#L653">String</a></h3>
				<pre>func (d ChanDir) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Kind">type <a href="src/pkg/reflect/type.htm#L181">Kind</a></h2>
			<pre>type Kind uint</pre>
			<p>
A Kind represents the specific kind of type that a Type represents.
The zero Kind is not a valid kind.
</p>


			
				<pre>const (
    Invalid Kind = iota
    Bool
    Int
    Int8
    Int16
    Int32
    Int64
    Uint
    Uint8
    Uint16
    Uint32
    Uint64
    Uintptr
    Float32
    Float64
    Complex64
    Complex128
    Array
    Chan
    Func
    Interface
    Map
    Ptr
    Slice
    String
    Struct
    UnsafePointer
)</pre>
				
			

			

			

			

			
				
				<h3 id="Kind.String">func (Kind) <a href="src/pkg/reflect/type.htm#L366">String</a></h3>
				<pre>func (k Kind) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Method">type <a href="src/pkg/reflect/type.htm#L347">Method</a></h2>
			<pre>type Method struct {
    <span class="comment">// Name is the method name.</span>
    <span class="comment">// PkgPath is the package path that qualifies a lower case (unexported)</span>
    <span class="comment">// method name.  It is empty for upper case (exported) method names.</span>
    <span class="comment">// The combination of PkgPath and Name uniquely identifies a method</span>
    <span class="comment">// in a method set. </span>
    <span class="comment">// See http://golang.org/ref/spec#Uniqueness_of_identifiers</span>
    Name    string
    PkgPath string

    Type  Type  <span class="comment">// method type</span>
    Func  Value <span class="comment">// func with receiver as first argument</span>
    Index int   <span class="comment">// index for Type.Method</span>
}</pre>
			<p>
Method represents a single method.
</p>


			

			

			

			

			
		
			
			
			<h2 id="SliceHeader">type <a href="src/pkg/reflect/value.htm#L1494">SliceHeader</a></h2>
			<pre>type SliceHeader struct {
    Data uintptr
    Len  int
    Cap  int
}</pre>
			<p>
SliceHeader is the runtime representation of a slice.
It cannot be used safely or portably.
</p>


			

			

			

			

			
		
			
			
			<h2 id="StringHeader">type <a href="src/pkg/reflect/value.htm#L1487">StringHeader</a></h2>
			<pre>type StringHeader struct {
    Data uintptr
    Len  int
}</pre>
			<p>
StringHeader is the runtime representation of a string.
It cannot be used safely or portably.
</p>


			

			

			

			

			
		
			
			
			<h2 id="StructField">type <a href="src/pkg/reflect/type.htm#L699">StructField</a></h2>
			<pre>type StructField struct {
    <span class="comment">// Name is the field name.</span>
    <span class="comment">// PkgPath is the package path that qualifies a lower case (unexported)</span>
    <span class="comment">// field name.  It is empty for upper case (exported) field names.</span>
    <span class="comment">// See http://golang.org/ref/spec#Uniqueness_of_identifiers</span>
    Name    string
    PkgPath string

    Type      Type      <span class="comment">// field type</span>
    Tag       StructTag <span class="comment">// field tag string</span>
    Offset    uintptr   <span class="comment">// offset within struct, in bytes</span>
    Index     []int     <span class="comment">// index sequence for Type.FieldByIndex</span>
    Anonymous bool      <span class="comment">// is an anonymous field</span>
}</pre>
			<p>
A StructField describes a single field in a struct.
</p>


			

			

			

			

			
		
			
			
			<h2 id="StructTag">type <a href="src/pkg/reflect/type.htm#L722">StructTag</a></h2>
			<pre>type StructTag string</pre>
			<p>
A StructTag is the tag string in a struct field.
</p>
<p>
By convention, tag strings are a concatenation of
optionally space-separated key:&#34;value&#34; pairs.
Each key is a non-empty string consisting of non-control
characters other than space (U+0020 &#39; &#39;), quote (U+0022 &#39;&#34;&#39;),
and colon (U+003A &#39;:&#39;).  Each value is quoted using U+0022 &#39;&#34;&#39;
characters and Go string literal syntax.
</p>


			

			

			

			

			
				
				<h3 id="StructTag.Get">func (StructTag) <a href="src/pkg/reflect/type.htm#L728">Get</a></h3>
				<pre>func (tag StructTag) Get(key string) string</pre>
				<p>
Get returns the value associated with key in the tag string.
If there is no such key in the tag, Get returns the empty string.
If the tag does not have the conventional format, the value
returned by Get is unspecified.
</p>

				
				
			
		
			
			
			<h2 id="Type">type <a href="src/pkg/reflect/type.htm#L21">Type</a></h2>
			<pre>type Type interface {

    <span class="comment">// Align returns the alignment in bytes of a value of</span>
    <span class="comment">// this type when allocated in memory.</span>
    Align() int

    <span class="comment">// FieldAlign returns the alignment in bytes of a value of</span>
    <span class="comment">// this type when used as a field in a struct.</span>
    FieldAlign() int

    <span class="comment">// Method returns the i&#39;th method in the type&#39;s method set.</span>
    <span class="comment">// It panics if i is not in the range [0, NumMethod()).</span>
    <span class="comment">//</span>
    <span class="comment">// For a non-interface type T or *T, the returned Method&#39;s Type and Func</span>
    <span class="comment">// fields describe a function whose first argument is the receiver.</span>
    <span class="comment">//</span>
    <span class="comment">// For an interface type, the returned Method&#39;s Type field gives the</span>
    <span class="comment">// method signature, without a receiver, and the Func field is nil.</span>
    Method(int) Method

    <span class="comment">// MethodByName returns the method with that name in the type&#39;s</span>
    <span class="comment">// method set and a boolean indicating if the method was found.</span>
    <span class="comment">//</span>
    <span class="comment">// For a non-interface type T or *T, the returned Method&#39;s Type and Func</span>
    <span class="comment">// fields describe a function whose first argument is the receiver.</span>
    <span class="comment">//</span>
    <span class="comment">// For an interface type, the returned Method&#39;s Type field gives the</span>
    <span class="comment">// method signature, without a receiver, and the Func field is nil.</span>
    MethodByName(string) (Method, bool)

    <span class="comment">// NumMethod returns the number of methods in the type&#39;s method set.</span>
    NumMethod() int

    <span class="comment">// Name returns the type&#39;s name within its package.</span>
    <span class="comment">// It returns an empty string for unnamed types.</span>
    Name() string

    <span class="comment">// PkgPath returns a named type&#39;s package path, that is, the import path</span>
    <span class="comment">// that uniquely identifies the package, such as &#34;encoding/base64&#34;.</span>
    <span class="comment">// If the type was predeclared (string, error) or unnamed (*T, struct{}, []int),</span>
    <span class="comment">// the package path will be the empty string.</span>
    PkgPath() string

    <span class="comment">// Size returns the number of bytes needed to store</span>
    <span class="comment">// a value of the given type; it is analogous to unsafe.Sizeof.</span>
    Size() uintptr

    <span class="comment">// String returns a string representation of the type.</span>
    <span class="comment">// The string representation may use shortened package names</span>
    <span class="comment">// (e.g., base64 instead of &#34;encoding/base64&#34;) and is not</span>
    <span class="comment">// guaranteed to be unique among types.  To test for equality,</span>
    <span class="comment">// compare the Types directly.</span>
    String() string

    <span class="comment">// Kind returns the specific kind of this type.</span>
    Kind() Kind

    <span class="comment">// Implements returns true if the type implements the interface type u.</span>
    Implements(u Type) bool

    <span class="comment">// AssignableTo returns true if a value of the type is assignable to type u.</span>
    AssignableTo(u Type) bool

    <span class="comment">// Bits returns the size of the type in bits.</span>
    <span class="comment">// It panics if the type&#39;s Kind is not one of the</span>
    <span class="comment">// sized or unsized Int, Uint, Float, or Complex kinds.</span>
    Bits() int

    <span class="comment">// ChanDir returns a channel type&#39;s direction.</span>
    <span class="comment">// It panics if the type&#39;s Kind is not Chan.</span>
    ChanDir() ChanDir

    <span class="comment">// IsVariadic returns true if a function type&#39;s final input parameter</span>
    <span class="comment">// is a &#34;...&#34; parameter.  If so, t.In(t.NumIn() - 1) returns the parameter&#39;s</span>
    <span class="comment">// implicit actual type []T.</span>
    <span class="comment">//</span>
    <span class="comment">// For concreteness, if t represents func(x int, y ... float64), then</span>
    <span class="comment">//</span>
    <span class="comment">//	t.NumIn() == 2</span>
    <span class="comment">//	t.In(0) is the reflect.Type for &#34;int&#34;</span>
    <span class="comment">//	t.In(1) is the reflect.Type for &#34;[]float64&#34;</span>
    <span class="comment">//	t.IsVariadic() == true</span>
    <span class="comment">//</span>
    <span class="comment">// IsVariadic panics if the type&#39;s Kind is not Func.</span>
    IsVariadic() bool

    <span class="comment">// Elem returns a type&#39;s element type.</span>
    <span class="comment">// It panics if the type&#39;s Kind is not Array, Chan, Map, Ptr, or Slice.</span>
    Elem() Type

    <span class="comment">// Field returns a struct type&#39;s i&#39;th field.</span>
    <span class="comment">// It panics if the type&#39;s Kind is not Struct.</span>
    <span class="comment">// It panics if i is not in the range [0, NumField()).</span>
    Field(i int) StructField

    <span class="comment">// FieldByIndex returns the nested field corresponding</span>
    <span class="comment">// to the index sequence.  It is equivalent to calling Field</span>
    <span class="comment">// successively for each index i.</span>
    <span class="comment">// It panics if the type&#39;s Kind is not Struct.</span>
    FieldByIndex(index []int) StructField

    <span class="comment">// FieldByName returns the struct field with the given name</span>
    <span class="comment">// and a boolean indicating if the field was found.</span>
    FieldByName(name string) (StructField, bool)

    <span class="comment">// FieldByNameFunc returns the first struct field with a name</span>
    <span class="comment">// that satisfies the match function and a boolean indicating if</span>
    <span class="comment">// the field was found.</span>
    FieldByNameFunc(match func(string) bool) (StructField, bool)

    <span class="comment">// In returns the type of a function type&#39;s i&#39;th input parameter.</span>
    <span class="comment">// It panics if the type&#39;s Kind is not Func.</span>
    <span class="comment">// It panics if i is not in the range [0, NumIn()).</span>
    In(i int) Type

    <span class="comment">// Key returns a map type&#39;s key type.</span>
    <span class="comment">// It panics if the type&#39;s Kind is not Map.</span>
    Key() Type

    <span class="comment">// Len returns an array type&#39;s length.</span>
    <span class="comment">// It panics if the type&#39;s Kind is not Array.</span>
    Len() int

    <span class="comment">// NumField returns a struct type&#39;s field count.</span>
    <span class="comment">// It panics if the type&#39;s Kind is not Struct.</span>
    NumField() int

    <span class="comment">// NumIn returns a function type&#39;s input parameter count.</span>
    <span class="comment">// It panics if the type&#39;s Kind is not Func.</span>
    NumIn() int

    <span class="comment">// NumOut returns a function type&#39;s output parameter count.</span>
    <span class="comment">// It panics if the type&#39;s Kind is not Func.</span>
    NumOut() int

    <span class="comment">// Out returns the type of a function type&#39;s i&#39;th output parameter.</span>
    <span class="comment">// It panics if the type&#39;s Kind is not Func.</span>
    <span class="comment">// It panics if i is not in the range [0, NumOut()).</span>
    Out(i int) Type
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
			<p>
Type is the representation of a Go type.
</p>
<p>
Not all methods apply to all kinds of types.  Restrictions,
if any, are noted in the documentation for each method.
Use the Kind method to find out the kind of type before
calling kind-specific methods.  Calling a method
inappropriate to the kind of type causes a run-time panic.
</p>


			

			

			

			
				
				<h3 id="PtrTo">func <a href="src/pkg/reflect/type.htm#L957">PtrTo</a></h3>
				<pre>func PtrTo(t Type) Type</pre>
				<p>
PtrTo returns the pointer type with element t.
For example, if t represents type Foo, PtrTo(t) represents *Foo.
</p>

				
			
				
				<h3 id="TypeOf">func <a href="src/pkg/reflect/type.htm#L934">TypeOf</a></h3>
				<pre>func TypeOf(i interface{}) Type</pre>
				<p>
TypeOf returns the reflection Type of the value in the interface{}.
TypeOf(nil) returns nil.
</p>

				
			

			
		
			
			
			<h2 id="Value">type <a href="src/pkg/reflect/value.htm#L51">Value</a></h2>
			<pre>type Value struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Value is the reflection interface to a Go value.
</p>
<p>
Not all methods apply to all kinds of values.  Restrictions,
if any, are noted in the documentation for each method.
Use the Kind method to find out the kind of value before
calling kind-specific methods.  Calling a method
inappropriate to the kind of type causes a run time panic.
</p>
<p>
The zero Value represents no value.
Its IsValid method returns false, its Kind method returns Invalid,
its String method returns &#34;&lt;invalid Value&gt;&#34;, and all other methods panic.
Most functions and methods never return an invalid value.
If one does, its documentation states the conditions explicitly.
</p>
<p>
A Value can be used concurrently by multiple goroutines provided that
the underlying Go value can be used concurrently for the equivalent
direct operations.
</p>


			

			

			

			
				
				<h3 id="Append">func <a href="src/pkg/reflect/value.htm#L1536">Append</a></h3>
				<pre>func Append(s Value, x ...Value) Value</pre>
				<p>
Append appends the values x to a slice s and returns the resulting slice.
As in Go, each x&#39;s value must be assignable to the slice&#39;s element type.
</p>

				
			
				
				<h3 id="AppendSlice">func <a href="src/pkg/reflect/value.htm#L1547">AppendSlice</a></h3>
				<pre>func AppendSlice(s, t Value) Value</pre>
				<p>
AppendSlice appends a slice t to a slice s and returns the resulting slice.
The slices s and t must have the same element type.
</p>

				
			
				
				<h3 id="Indirect">func <a href="src/pkg/reflect/value.htm#L1674">Indirect</a></h3>
				<pre>func Indirect(v Value) Value</pre>
				<p>
Indirect returns the value that v points to.
If v is a nil pointer, Indirect returns a zero Value.
If v is not a pointer, Indirect returns v.
</p>

				
			
				
				<h3 id="MakeChan">func <a href="src/pkg/reflect/value.htm#L1648">MakeChan</a></h3>
				<pre>func MakeChan(typ Type, buffer int) Value</pre>
				<p>
MakeChan creates a new channel with the specified type and buffer size.
</p>

				
			
				
				<h3 id="MakeMap">func <a href="src/pkg/reflect/value.htm#L1663">MakeMap</a></h3>
				<pre>func MakeMap(typ Type) Value</pre>
				<p>
MakeMap creates a new map of the specified type.
</p>

				
			
				
				<h3 id="MakeSlice">func <a href="src/pkg/reflect/value.htm#L1621">MakeSlice</a></h3>
				<pre>func MakeSlice(typ Type, len, cap int) Value</pre>
				<p>
MakeSlice creates a new zero-initialized slice value
for the specified slice type, length, and capacity.
</p>

				
			
				
				<h3 id="New">func <a href="src/pkg/reflect/value.htm#L1724">New</a></h3>
				<pre>func New(typ Type) Value</pre>
				<p>
New returns a Value representing a pointer to a new zero value
for the specified type.  That is, the returned Value&#39;s Type is PtrTo(t).
</p>

				
			
				
				<h3 id="NewAt">func <a href="src/pkg/reflect/value.htm#L1735">NewAt</a></h3>
				<pre>func NewAt(typ Type, p unsafe.Pointer) Value</pre>
				<p>
NewAt returns a Value representing a pointer to a value of the
specified type, using p as that pointer.
</p>

				
			
				
				<h3 id="ValueOf">func <a href="src/pkg/reflect/value.htm#L1683">ValueOf</a></h3>
				<pre>func ValueOf(i interface{}) Value</pre>
				<p>
ValueOf returns a new Value initialized to the concrete value
stored in the interface i.  ValueOf(nil) returns the zero Value.
</p>

				
			
				
				<h3 id="Zero">func <a href="src/pkg/reflect/value.htm#L1710">Zero</a></h3>
				<pre>func Zero(typ Type) Value</pre>
				<p>
Zero returns a Value representing a zero value for the specified type.
The result is different from the zero value of the Value struct,
which represents no value at all.
For example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.
</p>

				
			

			
				
				<h3 id="Value.Addr">func (Value) <a href="src/pkg/reflect/value.htm#L267">Addr</a></h3>
				<pre>func (v Value) Addr() Value</pre>
				<p>
Addr returns a pointer value representing the address of v.
It panics if CanAddr() returns false.
Addr is typically used to obtain a pointer to a struct field
or slice element in order to call a method that requires a
pointer receiver.
</p>

				
				
			
				
				<h3 id="Value.Bool">func (Value) <a href="src/pkg/reflect/value.htm#L276">Bool</a></h3>
				<pre>func (v Value) Bool() bool</pre>
				<p>
Bool returns v&#39;s underlying value.
It panics if v&#39;s kind is not Bool.
</p>

				
				
			
				
				<h3 id="Value.Bytes">func (Value) <a href="src/pkg/reflect/value.htm#L286">Bytes</a></h3>
				<pre>func (v Value) Bytes() []byte</pre>
				<p>
Bytes returns v&#39;s underlying value.
It panics if v&#39;s underlying value is not a slice of bytes.
</p>

				
				
			
				
				<h3 id="Value.Call">func (Value) <a href="src/pkg/reflect/value.htm#L321">Call</a></h3>
				<pre>func (v Value) Call(in []Value) []Value</pre>
				<p>
Call calls the function v with the input arguments in.
For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]).
Call panics if v&#39;s Kind is not Func.
It returns the output results as Values.
As in Go, each input argument must be assignable to the
type of the function&#39;s corresponding input parameter.
If v is a variadic function, Call creates the variadic slice parameter
itself, copying in the corresponding values.
</p>

				
				
			
				
				<h3 id="Value.CallSlice">func (Value) <a href="src/pkg/reflect/value.htm#L334">CallSlice</a></h3>
				<pre>func (v Value) CallSlice(in []Value) []Value</pre>
				<p>
CallSlice calls the variadic function v with the input arguments in,
assigning the slice in[len(in)-1] to v&#39;s final variadic argument.
For example, if len(in) == 3, v.Call(in) represents the Go call v(in[0], in[1], in[2]...).
Call panics if v&#39;s Kind is not Func or if v is not variadic.
It returns the output results as Values.
As in Go, each input argument must be assignable to the
type of the function&#39;s corresponding input parameter.
</p>

				
				
			
				
				<h3 id="Value.CanAddr">func (Value) <a href="src/pkg/reflect/value.htm#L300">CanAddr</a></h3>
				<pre>func (v Value) CanAddr() bool</pre>
				<p>
CanAddr returns true if the value&#39;s address can be obtained with Addr.
Such values are called addressable.  A value is addressable if it is
an element of a slice, an element of an addressable array,
a field of an addressable struct, or the result of dereferencing a pointer.
If CanAddr returns false, calling Addr will panic.
</p>

				
				
			
				
				<h3 id="Value.CanInterface">func (Value) <a href="src/pkg/reflect/value.htm#L790">CanInterface</a></h3>
				<pre>func (v Value) CanInterface() bool</pre>
				<p>
CanInterface returns true if Interface can be used without panicking.
</p>

				
				
			
				
				<h3 id="Value.CanSet">func (Value) <a href="src/pkg/reflect/value.htm#L309">CanSet</a></h3>
				<pre>func (v Value) CanSet() bool</pre>
				<p>
CanSet returns true if the value of v can be changed.
A Value can be changed only if it is addressable and was not
obtained by the use of unexported struct fields.
If CanSet returns false, calling Set or any type-specific
setter (e.g., SetBool, SetInt64) will panic.
</p>

				
				
			
				
				<h3 id="Value.Cap">func (Value) <a href="src/pkg/reflect/value.htm#L531">Cap</a></h3>
				<pre>func (v Value) Cap() int</pre>
				<p>
Cap returns v&#39;s capacity.
It panics if v&#39;s Kind is not Array, Chan, or Slice.
</p>

				
				
			
				
				<h3 id="Value.Close">func (Value) <a href="src/pkg/reflect/value.htm#L547">Close</a></h3>
				<pre>func (v Value) Close()</pre>
				<p>
Close closes the channel v.
It panics if v&#39;s Kind is not Chan.
</p>

				
				
			
				
				<h3 id="Value.Complex">func (Value) <a href="src/pkg/reflect/value.htm#L555">Complex</a></h3>
				<pre>func (v Value) Complex() complex128</pre>
				<p>
Complex returns v&#39;s underlying value, as a complex128.
It panics if v&#39;s Kind is not Complex64 or Complex128
</p>

				
				
			
				
				<h3 id="Value.Elem">func (Value) <a href="src/pkg/reflect/value.htm#L574">Elem</a></h3>
				<pre>func (v Value) Elem() Value</pre>
				<p>
Elem returns the value that the interface v contains
or that the pointer v points to.
It panics if v&#39;s Kind is not Interface or Ptr.
It returns the zero Value if v is nil.
</p>

				
				
			
				
				<h3 id="Value.Field">func (Value) <a href="src/pkg/reflect/value.htm#L626">Field</a></h3>
				<pre>func (v Value) Field(i int) Value</pre>
				<p>
Field returns the i&#39;th field of the struct v.
It panics if v&#39;s Kind is not Struct or i is out of range.
</p>

				
				
			
				
				<h3 id="Value.FieldByIndex">func (Value) <a href="src/pkg/reflect/value.htm#L661">FieldByIndex</a></h3>
				<pre>func (v Value) FieldByIndex(index []int) Value</pre>
				<p>
FieldByIndex returns the nested field corresponding to index.
It panics if v&#39;s Kind is not struct.
</p>

				
				
			
				
				<h3 id="Value.FieldByName">func (Value) <a href="src/pkg/reflect/value.htm#L677">FieldByName</a></h3>
				<pre>func (v Value) FieldByName(name string) Value</pre>
				<p>
FieldByName returns the struct field with the given name.
It returns the zero Value if no field was found.
It panics if v&#39;s Kind is not struct.
</p>

				
				
			
				
				<h3 id="Value.FieldByNameFunc">func (Value) <a href="src/pkg/reflect/value.htm#L689">FieldByNameFunc</a></h3>
				<pre>func (v Value) FieldByNameFunc(match func(string) bool) Value</pre>
				<p>
FieldByNameFunc returns the struct field with a name
that satisfies the match function.
It panics if v&#39;s Kind is not struct.
It returns the zero Value if no field was found.
</p>

				
				
			
				
				<h3 id="Value.Float">func (Value) <a href="src/pkg/reflect/value.htm#L699">Float</a></h3>
				<pre>func (v Value) Float() float64</pre>
				<p>
Float returns v&#39;s underlying value, as a float64.
It panics if v&#39;s Kind is not Float32 or Float64
</p>

				
				
			
				
				<h3 id="Value.Index">func (Value) <a href="src/pkg/reflect/value.htm#L718">Index</a></h3>
				<pre>func (v Value) Index(i int) Value</pre>
				<p>
Index returns v&#39;s i&#39;th element.
It panics if v&#39;s Kind is not Array or Slice or i is out of range.
</p>

				
				
			
				
				<h3 id="Value.Int">func (Value) <a href="src/pkg/reflect/value.htm#L764">Int</a></h3>
				<pre>func (v Value) Int() int64</pre>
				<p>
Int returns v&#39;s underlying value, as an int64.
It panics if v&#39;s Kind is not Int, Int8, Int16, Int32, or Int64.
</p>

				
				
			
				
				<h3 id="Value.Interface">func (Value) <a href="src/pkg/reflect/value.htm#L805">Interface</a></h3>
				<pre>func (v Value) Interface() (i interface{})</pre>
				<p>
Interface returns v&#39;s current value as an interface{}.
It is equivalent to:
</p>
<pre>var i interface{} = (v&#39;s underlying value)
</pre>
<p>
If v is a method obtained by invoking Value.Method
(as opposed to Type.Method), Interface cannot return an
interface value, so it panics.
It also panics if the Value was obtained by accessing
unexported struct fields.
</p>

				
				
			
				
				<h3 id="Value.InterfaceData">func (Value) <a href="src/pkg/reflect/value.htm#L856">InterfaceData</a></h3>
				<pre>func (v Value) InterfaceData() [2]uintptr</pre>
				<p>
InterfaceData returns the interface v&#39;s value as a uintptr pair.
It panics if v&#39;s Kind is not Interface.
</p>

				
				
			
				
				<h3 id="Value.IsNil">func (Value) <a href="src/pkg/reflect/value.htm#L868">IsNil</a></h3>
				<pre>func (v Value) IsNil() bool</pre>
				<p>
IsNil returns true if v is a nil value.
It panics if v&#39;s Kind is not Chan, Func, Interface, Map, Ptr, or Slice.
</p>

				
				
			
				
				<h3 id="Value.IsValid">func (Value) <a href="src/pkg/reflect/value.htm#L893">IsValid</a></h3>
				<pre>func (v Value) IsValid() bool</pre>
				<p>
IsValid returns true if v represents a value.
It returns false if v is the zero Value.
If IsValid returns false, all other methods except String panic.
Most functions and methods never return an invalid value.
If one does, its documentation states the conditions explicitly.
</p>

				
				
			
				
				<h3 id="Value.Kind">func (Value) <a href="src/pkg/reflect/value.htm#L899">Kind</a></h3>
				<pre>func (v Value) Kind() Kind</pre>
				<p>
Kind returns v&#39;s Kind.
If v is the zero Value (IsValid returns false), Kind returns Invalid.
</p>

				
				
			
				
				<h3 id="Value.Len">func (Value) <a href="src/pkg/reflect/value.htm#L905">Len</a></h3>
				<pre>func (v Value) Len() int</pre>
				<p>
Len returns v&#39;s length.
It panics if v&#39;s Kind is not Array, Chan, Map, Slice, or String.
</p>

				
				
			
				
				<h3 id="Value.MapIndex">func (Value) <a href="src/pkg/reflect/value.htm#L929">MapIndex</a></h3>
				<pre>func (v Value) MapIndex(key Value) Value</pre>
				<p>
MapIndex returns the value associated with key in the map v.
It panics if v&#39;s Kind is not Map.
It returns the zero Value if key is not found in the map or if v represents a nil map.
As in Go, the key&#39;s value must be assignable to the map&#39;s key type.
</p>

				
				
			
				
				<h3 id="Value.MapKeys">func (Value) <a href="src/pkg/reflect/value.htm#L959">MapKeys</a></h3>
				<pre>func (v Value) MapKeys() []Value</pre>
				<p>
MapKeys returns a slice containing all the keys present in the map,
in unspecified order.
It panics if v&#39;s Kind is not Map.
It returns an empty slice if v represents a nil map.
</p>

				
				
			
				
				<h3 id="Value.Method">func (Value) <a href="src/pkg/reflect/value.htm#L993">Method</a></h3>
				<pre>func (v Value) Method(i int) Value</pre>
				<p>
Method returns a function value corresponding to v&#39;s i&#39;th method.
The arguments to a Call on the returned function should not include
a receiver; the returned function will always use v as the receiver.
Method panics if i is out of range.
</p>

				
				
			
				
				<h3 id="Value.MethodByName">func (Value) <a href="src/pkg/reflect/value.htm#L1022">MethodByName</a></h3>
				<pre>func (v Value) MethodByName(name string) Value</pre>
				<p>
MethodByName returns a function value corresponding to the method
of v with the given name.
The arguments to a Call on the returned function should not include
a receiver; the returned function will always use v as the receiver.
It returns the zero Value if no method was found.
</p>

				
				
			
				
				<h3 id="Value.NumField">func (Value) <a href="src/pkg/reflect/value.htm#L1038">NumField</a></h3>
				<pre>func (v Value) NumField() int</pre>
				<p>
NumField returns the number of fields in the struct v.
It panics if v&#39;s Kind is not Struct.
</p>

				
				
			
				
				<h3 id="Value.NumMethod">func (Value) <a href="src/pkg/reflect/value.htm#L1007">NumMethod</a></h3>
				<pre>func (v Value) NumMethod() int</pre>
				<p>
NumMethod returns the number of methods in the value&#39;s method set.
</p>

				
				
			
				
				<h3 id="Value.OverflowComplex">func (Value) <a href="src/pkg/reflect/value.htm#L1046">OverflowComplex</a></h3>
				<pre>func (v Value) OverflowComplex(x complex128) bool</pre>
				<p>
OverflowComplex returns true if the complex128 x cannot be represented by v&#39;s type.
It panics if v&#39;s Kind is not Complex64 or Complex128.
</p>

				
				
			
				
				<h3 id="Value.OverflowFloat">func (Value) <a href="src/pkg/reflect/value.htm#L1059">OverflowFloat</a></h3>
				<pre>func (v Value) OverflowFloat(x float64) bool</pre>
				<p>
OverflowFloat returns true if the float64 x cannot be represented by v&#39;s type.
It panics if v&#39;s Kind is not Float32 or Float64.
</p>

				
				
			
				
				<h3 id="Value.OverflowInt">func (Value) <a href="src/pkg/reflect/value.htm#L1079">OverflowInt</a></h3>
				<pre>func (v Value) OverflowInt(x int64) bool</pre>
				<p>
OverflowInt returns true if the int64 x cannot be represented by v&#39;s type.
It panics if v&#39;s Kind is not Int, Int8, int16, Int32, or Int64.
</p>

				
				
			
				
				<h3 id="Value.OverflowUint">func (Value) <a href="src/pkg/reflect/value.htm#L1092">OverflowUint</a></h3>
				<pre>func (v Value) OverflowUint(x uint64) bool</pre>
				<p>
OverflowUint returns true if the uint64 x cannot be represented by v&#39;s type.
It panics if v&#39;s Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.
</p>

				
				
			
				
				<h3 id="Value.Pointer">func (Value) <a href="src/pkg/reflect/value.htm#L1108">Pointer</a></h3>
				<pre>func (v Value) Pointer() uintptr</pre>
				<p>
Pointer returns v&#39;s value as a uintptr.
It returns uintptr instead of unsafe.Pointer so that
code using reflect cannot obtain unsafe.Pointers
without importing the unsafe package explicitly.
It panics if v&#39;s Kind is not Chan, Func, Map, Ptr, Slice, or UnsafePointer.
</p>

				
				
			
				
				<h3 id="Value.Recv">func (Value) <a href="src/pkg/reflect/value.htm#L1131">Recv</a></h3>
				<pre>func (v Value) Recv() (x Value, ok bool)</pre>
				<p>
Recv receives and returns a value from the channel v.
It panics if v&#39;s Kind is not Chan.
The receive blocks until a value is ready.
The boolean value ok is true if the value x corresponds to a send
on the channel, false if it is a zero value received because the channel is closed.
</p>

				
				
			
				
				<h3 id="Value.Send">func (Value) <a href="src/pkg/reflect/value.htm#L1159">Send</a></h3>
				<pre>func (v Value) Send(x Value)</pre>
				<p>
Send sends x on the channel v.
It panics if v&#39;s kind is not Chan or if x&#39;s type is not the same type as v&#39;s element type.
As in Go, x&#39;s value must be assignable to the channel&#39;s element type.
</p>

				
				
			
				
				<h3 id="Value.Set">func (Value) <a href="src/pkg/reflect/value.htm#L1180">Set</a></h3>
				<pre>func (v Value) Set(x Value)</pre>
				<p>
Set assigns x to the value v.
It panics if CanSet returns false.
As in Go, x&#39;s value must be assignable to v&#39;s type.
</p>

				
				
			
				
				<h3 id="Value.SetBool">func (Value) <a href="src/pkg/reflect/value.htm#L1197">SetBool</a></h3>
				<pre>func (v Value) SetBool(x bool)</pre>
				<p>
SetBool sets v&#39;s underlying value.
It panics if v&#39;s Kind is not Bool or if CanSet() is false.
</p>

				
				
			
				
				<h3 id="Value.SetBytes">func (Value) <a href="src/pkg/reflect/value.htm#L1205">SetBytes</a></h3>
				<pre>func (v Value) SetBytes(x []byte)</pre>
				<p>
SetBytes sets v&#39;s underlying value.
It panics if v&#39;s underlying value is not a slice of bytes.
</p>

				
				
			
				
				<h3 id="Value.SetComplex">func (Value) <a href="src/pkg/reflect/value.htm#L1216">SetComplex</a></h3>
				<pre>func (v Value) SetComplex(x complex128)</pre>
				<p>
SetComplex sets v&#39;s underlying value to x.
It panics if v&#39;s Kind is not Complex64 or Complex128, or if CanSet() is false.
</p>

				
				
			
				
				<h3 id="Value.SetFloat">func (Value) <a href="src/pkg/reflect/value.htm#L1230">SetFloat</a></h3>
				<pre>func (v Value) SetFloat(x float64)</pre>
				<p>
SetFloat sets v&#39;s underlying value to x.
It panics if v&#39;s Kind is not Float32 or Float64, or if CanSet() is false.
</p>

				
				
			
				
				<h3 id="Value.SetInt">func (Value) <a href="src/pkg/reflect/value.htm#L1244">SetInt</a></h3>
				<pre>func (v Value) SetInt(x int64)</pre>
				<p>
SetInt sets v&#39;s underlying value to x.
It panics if v&#39;s Kind is not Int, Int8, Int16, Int32, or Int64, or if CanSet() is false.
</p>

				
				
			
				
				<h3 id="Value.SetLen">func (Value) <a href="src/pkg/reflect/value.htm#L1265">SetLen</a></h3>
				<pre>func (v Value) SetLen(n int)</pre>
				<p>
SetLen sets v&#39;s length to n.
It panics if v&#39;s Kind is not Slice or if n is negative or
greater than the capacity of the slice.
</p>

				
				
			
				
				<h3 id="Value.SetMapIndex">func (Value) <a href="src/pkg/reflect/value.htm#L1280">SetMapIndex</a></h3>
				<pre>func (v Value) SetMapIndex(key, val Value)</pre>
				<p>
SetMapIndex sets the value associated with key in the map v to val.
It panics if v&#39;s Kind is not Map.
If val is the zero Value, SetMapIndex deletes the key from the map.
As in Go, key&#39;s value must be assignable to the map&#39;s key type,
and val&#39;s value must be assignable to the map&#39;s value type.
</p>

				
				
			
				
				<h3 id="Value.SetPointer">func (Value) <a href="src/pkg/reflect/value.htm#L1317">SetPointer</a></h3>
				<pre>func (v Value) SetPointer(x unsafe.Pointer)</pre>
				<p>
SetPointer sets the unsafe.Pointer value v to x.
It panics if v&#39;s Kind is not UnsafePointer.
</p>

				
				
			
				
				<h3 id="Value.SetString">func (Value) <a href="src/pkg/reflect/value.htm#L1325">SetString</a></h3>
				<pre>func (v Value) SetString(x string)</pre>
				<p>
SetString sets v&#39;s underlying value to x.
It panics if v&#39;s Kind is not String or if CanSet() is false.
</p>

				
				
			
				
				<h3 id="Value.SetUint">func (Value) <a href="src/pkg/reflect/value.htm#L1295">SetUint</a></h3>
				<pre>func (v Value) SetUint(x uint64)</pre>
				<p>
SetUint sets v&#39;s underlying value to x.
It panics if v&#39;s Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64, or if CanSet() is false.
</p>

				
				
			
				
				<h3 id="Value.Slice">func (Value) <a href="src/pkg/reflect/value.htm#L1333">Slice</a></h3>
				<pre>func (v Value) Slice(beg, end int) Value</pre>
				<p>
Slice returns a slice of v.
It panics if v&#39;s Kind is not Array or Slice.
</p>

				
				
			
				
				<h3 id="Value.String">func (Value) <a href="src/pkg/reflect/value.htm#L1378">String</a></h3>
				<pre>func (v Value) String() string</pre>
				<p>
String returns the string v&#39;s underlying value, as a string.
String is a special case because of Go&#39;s String method convention.
Unlike the other getters, it does not panic if v&#39;s Kind is not String.
Instead, it returns a string of the form &#34;&lt;T value&gt;&#34; where T is v&#39;s type.
</p>

				
				
			
				
				<h3 id="Value.TryRecv">func (Value) <a href="src/pkg/reflect/value.htm#L1395">TryRecv</a></h3>
				<pre>func (v Value) TryRecv() (x Value, ok bool)</pre>
				<p>
TryRecv attempts to receive a value from the channel v but will not block.
It panics if v&#39;s Kind is not Chan.
If the receive cannot finish without blocking, x is the zero Value.
The boolean ok is true if the value x corresponds to a send
on the channel, false if it is a zero value received because the channel is closed.
</p>

				
				
			
				
				<h3 id="Value.TrySend">func (Value) <a href="src/pkg/reflect/value.htm#L1405">TrySend</a></h3>
				<pre>func (v Value) TrySend(x Value) bool</pre>
				<p>
TrySend attempts to send x on the channel v but will not block.
It panics if v&#39;s Kind is not Chan.
It returns true if the value was sent, false otherwise.
As in Go, x&#39;s value must be assignable to the channel&#39;s element type.
</p>

				
				
			
				
				<h3 id="Value.Type">func (Value) <a href="src/pkg/reflect/value.htm#L1412">Type</a></h3>
				<pre>func (v Value) Type() Type</pre>
				<p>
Type returns v&#39;s type.
</p>

				
				
			
				
				<h3 id="Value.Uint">func (Value) <a href="src/pkg/reflect/value.htm#L1445">Uint</a></h3>
				<pre>func (v Value) Uint() uint64</pre>
				<p>
Uint returns v&#39;s underlying value, as a uint64.
It panics if v&#39;s Kind is not Uint, Uintptr, Uint8, Uint16, Uint32, or Uint64.
</p>

				
				
			
				
				<h3 id="Value.UnsafeAddr">func (Value) <a href="src/pkg/reflect/value.htm#L1475">UnsafeAddr</a></h3>
				<pre>func (v Value) UnsafeAddr() uintptr</pre>
				<p>
UnsafeAddr returns a pointer to v&#39;s data.
It is for advanced clients that also import the &#34;unsafe&#34; package.
It panics if v is not addressable.
</p>

				
				
			
		
			
			
			<h2 id="ValueError">type <a href="src/pkg/reflect/value.htm#L104">ValueError</a></h2>
			<pre>type ValueError struct {
    Method string
    Kind   Kind
}</pre>
			<p>
A ValueError occurs when a Value method is invoked on
a Value that does not support it.  Such cases are documented
in the description of each method.
</p>


			

			

			

			

			
				
				<h3 id="ValueError.Error">func (*ValueError) <a href="src/pkg/reflect/value.htm#L109">Error</a></h3>
				<pre>func (e *ValueError) Error() string</pre>
				
				
				
			
		
		</div>
	

	









</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
