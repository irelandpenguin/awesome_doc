<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>src/pkg/text/template/doc.go - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="/doc/style.css">
<script type="text/javascript" src="/doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>



</div></div>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Source file src/pkg/text/template/doc.go</h1>




<div id="nav"></div>


<pre><a id="L1"></a><span class="ln">     1</span>	<span class="comment">// Copyright 2011 The Go Authors. All rights reserved.</span>
<a id="L2"></a><span class="ln">     2</span>	<span class="comment">// Use of this source code is governed by a BSD-style</span>
<a id="L3"></a><span class="ln">     3</span>	<span class="comment">// license that can be found in the LICENSE file.</span>
<a id="L4"></a><span class="ln">     4</span>	
<a id="L5"></a><span class="ln">     5</span>	<span class="comment">/*
</span><a id="L6"></a><span class="ln">     6</span>	<span class="comment">Package template implements data-driven templates for generating textual output.
</span><a id="L7"></a><span class="ln">     7</span>	<span class="comment">
</span><a id="L8"></a><span class="ln">     8</span>	<span class="comment">To generate HTML output, see package html/template, which has the same interface
</span><a id="L9"></a><span class="ln">     9</span>	<span class="comment">as this package but automatically secures HTML output against certain attacks.
</span><a id="L10"></a><span class="ln">    10</span>	<span class="comment">
</span><a id="L11"></a><span class="ln">    11</span>	<span class="comment">Templates are executed by applying them to a data structure. Annotations in the
</span><a id="L12"></a><span class="ln">    12</span>	<span class="comment">template refer to elements of the data structure (typically a field of a struct
</span><a id="L13"></a><span class="ln">    13</span>	<span class="comment">or a key in a map) to control execution and derive values to be displayed.
</span><a id="L14"></a><span class="ln">    14</span>	<span class="comment">Execution of the template walks the structure and sets the cursor, represented
</span><a id="L15"></a><span class="ln">    15</span>	<span class="comment">by a period &#39;.&#39; and called &#34;dot&#34;, to the value at the current location in the
</span><a id="L16"></a><span class="ln">    16</span>	<span class="comment">structure as execution proceeds.
</span><a id="L17"></a><span class="ln">    17</span>	<span class="comment">
</span><a id="L18"></a><span class="ln">    18</span>	<span class="comment">The input text for a template is UTF-8-encoded text in any format.
</span><a id="L19"></a><span class="ln">    19</span>	<span class="comment">&#34;Actions&#34;--data evaluations or control structures--are delimited by
</span><a id="L20"></a><span class="ln">    20</span>	<span class="comment">&#34;{{&#34; and &#34;}}&#34;; all text outside actions is copied to the output unchanged.
</span><a id="L21"></a><span class="ln">    21</span>	<span class="comment">Actions may not span newlines, although comments can.
</span><a id="L22"></a><span class="ln">    22</span>	<span class="comment">
</span><a id="L23"></a><span class="ln">    23</span>	<span class="comment">Once constructed, a template may be executed safely in parallel.
</span><a id="L24"></a><span class="ln">    24</span>	<span class="comment">
</span><a id="L25"></a><span class="ln">    25</span>	<span class="comment">Here is a trivial example that prints &#34;17 items are made of wool&#34;.
</span><a id="L26"></a><span class="ln">    26</span>	<span class="comment">
</span><a id="L27"></a><span class="ln">    27</span>	<span class="comment">	type Inventory struct {
</span><a id="L28"></a><span class="ln">    28</span>	<span class="comment">		Material string
</span><a id="L29"></a><span class="ln">    29</span>	<span class="comment">		Count    uint
</span><a id="L30"></a><span class="ln">    30</span>	<span class="comment">	}
</span><a id="L31"></a><span class="ln">    31</span>	<span class="comment">	sweaters := Inventory{&#34;wool&#34;, 17}
</span><a id="L32"></a><span class="ln">    32</span>	<span class="comment">	tmpl, err := template.New(&#34;test&#34;).Parse(&#34;{{.Count}} items are made of {{.Material}}&#34;)
</span><a id="L33"></a><span class="ln">    33</span>	<span class="comment">	if err != nil { panic(err) }
</span><a id="L34"></a><span class="ln">    34</span>	<span class="comment">	err = tmpl.Execute(os.Stdout, sweaters)
</span><a id="L35"></a><span class="ln">    35</span>	<span class="comment">	if err != nil { panic(err) }
</span><a id="L36"></a><span class="ln">    36</span>	<span class="comment">
</span><a id="L37"></a><span class="ln">    37</span>	<span class="comment">More intricate examples appear below.
</span><a id="L38"></a><span class="ln">    38</span>	<span class="comment">
</span><a id="L39"></a><span class="ln">    39</span>	<span class="comment">Actions
</span><a id="L40"></a><span class="ln">    40</span>	<span class="comment">
</span><a id="L41"></a><span class="ln">    41</span>	<span class="comment">Here is the list of actions. &#34;Arguments&#34; and &#34;pipelines&#34; are evaluations of
</span><a id="L42"></a><span class="ln">    42</span>	<span class="comment">data, defined in detail below.
</span><a id="L43"></a><span class="ln">    43</span>	<span class="comment">
</span><a id="L44"></a><span class="ln">    44</span>	<span class="comment">*/</span>
<a id="L45"></a><span class="ln">    45</span>	<span class="comment">//	{{/* a comment */}}</span>
<a id="L46"></a><span class="ln">    46</span>	<span class="comment">//		A comment; discarded. May contain newlines.</span>
<a id="L47"></a><span class="ln">    47</span>	<span class="comment">//		Comments do not nest.</span>
<a id="L48"></a><span class="ln">    48</span>	<span class="comment">/*
</span><a id="L49"></a><span class="ln">    49</span>	<span class="comment">
</span><a id="L50"></a><span class="ln">    50</span>	<span class="comment">	{{pipeline}}
</span><a id="L51"></a><span class="ln">    51</span>	<span class="comment">		The default textual representation of the value of the pipeline
</span><a id="L52"></a><span class="ln">    52</span>	<span class="comment">		is copied to the output.
</span><a id="L53"></a><span class="ln">    53</span>	<span class="comment">
</span><a id="L54"></a><span class="ln">    54</span>	<span class="comment">	{{if pipeline}} T1 {{end}}
</span><a id="L55"></a><span class="ln">    55</span>	<span class="comment">		If the value of the pipeline is empty, no output is generated;
</span><a id="L56"></a><span class="ln">    56</span>	<span class="comment">		otherwise, T1 is executed.  The empty values are false, 0, any
</span><a id="L57"></a><span class="ln">    57</span>	<span class="comment">		nil pointer or interface value, and any array, slice, map, or
</span><a id="L58"></a><span class="ln">    58</span>	<span class="comment">		string of length zero.
</span><a id="L59"></a><span class="ln">    59</span>	<span class="comment">		Dot is unaffected.
</span><a id="L60"></a><span class="ln">    60</span>	<span class="comment">
</span><a id="L61"></a><span class="ln">    61</span>	<span class="comment">	{{if pipeline}} T1 {{else}} T0 {{end}}
</span><a id="L62"></a><span class="ln">    62</span>	<span class="comment">		If the value of the pipeline is empty, T0 is executed;
</span><a id="L63"></a><span class="ln">    63</span>	<span class="comment">		otherwise, T1 is executed.  Dot is unaffected.
</span><a id="L64"></a><span class="ln">    64</span>	<span class="comment">
</span><a id="L65"></a><span class="ln">    65</span>	<span class="comment">	{{range pipeline}} T1 {{end}}
</span><a id="L66"></a><span class="ln">    66</span>	<span class="comment">		The value of the pipeline must be an array, slice, or map. If
</span><a id="L67"></a><span class="ln">    67</span>	<span class="comment">		the value of the pipeline has length zero, nothing is output;
</span><a id="L68"></a><span class="ln">    68</span>	<span class="comment">		otherwise, dot is set to the successive elements of the array,
</span><a id="L69"></a><span class="ln">    69</span>	<span class="comment">		slice, or map and T1 is executed. If the value is a map and the
</span><a id="L70"></a><span class="ln">    70</span>	<span class="comment">		keys are of basic type with a defined order (&#34;comparable&#34;), the
</span><a id="L71"></a><span class="ln">    71</span>	<span class="comment">		elements will be visited in sorted key order.
</span><a id="L72"></a><span class="ln">    72</span>	<span class="comment">
</span><a id="L73"></a><span class="ln">    73</span>	<span class="comment">	{{range pipeline}} T1 {{else}} T0 {{end}}
</span><a id="L74"></a><span class="ln">    74</span>	<span class="comment">		The value of the pipeline must be an array, slice, or map. If
</span><a id="L75"></a><span class="ln">    75</span>	<span class="comment">		the value of the pipeline has length zero, dot is unaffected and
</span><a id="L76"></a><span class="ln">    76</span>	<span class="comment">		T0 is executed; otherwise, dot is set to the successive elements
</span><a id="L77"></a><span class="ln">    77</span>	<span class="comment">		of the array, slice, or map and T1 is executed.
</span><a id="L78"></a><span class="ln">    78</span>	<span class="comment">
</span><a id="L79"></a><span class="ln">    79</span>	<span class="comment">	{{template &#34;name&#34;}}
</span><a id="L80"></a><span class="ln">    80</span>	<span class="comment">		The template with the specified name is executed with nil data.
</span><a id="L81"></a><span class="ln">    81</span>	<span class="comment">
</span><a id="L82"></a><span class="ln">    82</span>	<span class="comment">	{{template &#34;name&#34; pipeline}}
</span><a id="L83"></a><span class="ln">    83</span>	<span class="comment">		The template with the specified name is executed with dot set
</span><a id="L84"></a><span class="ln">    84</span>	<span class="comment">		to the value of the pipeline.
</span><a id="L85"></a><span class="ln">    85</span>	<span class="comment">
</span><a id="L86"></a><span class="ln">    86</span>	<span class="comment">	{{with pipeline}} T1 {{end}}
</span><a id="L87"></a><span class="ln">    87</span>	<span class="comment">		If the value of the pipeline is empty, no output is generated;
</span><a id="L88"></a><span class="ln">    88</span>	<span class="comment">		otherwise, dot is set to the value of the pipeline and T1 is
</span><a id="L89"></a><span class="ln">    89</span>	<span class="comment">		executed.
</span><a id="L90"></a><span class="ln">    90</span>	<span class="comment">
</span><a id="L91"></a><span class="ln">    91</span>	<span class="comment">	{{with pipeline}} T1 {{else}} T0 {{end}}
</span><a id="L92"></a><span class="ln">    92</span>	<span class="comment">		If the value of the pipeline is empty, dot is unaffected and T0
</span><a id="L93"></a><span class="ln">    93</span>	<span class="comment">		is executed; otherwise, dot is set to the value of the pipeline
</span><a id="L94"></a><span class="ln">    94</span>	<span class="comment">		and T1 is executed.
</span><a id="L95"></a><span class="ln">    95</span>	<span class="comment">
</span><a id="L96"></a><span class="ln">    96</span>	<span class="comment">Arguments
</span><a id="L97"></a><span class="ln">    97</span>	<span class="comment">
</span><a id="L98"></a><span class="ln">    98</span>	<span class="comment">An argument is a simple value, denoted by one of the following.
</span><a id="L99"></a><span class="ln">    99</span>	<span class="comment">
</span><a id="L100"></a><span class="ln">   100</span>	<span class="comment">	- A boolean, string, character, integer, floating-point, imaginary
</span><a id="L101"></a><span class="ln">   101</span>	<span class="comment">	  or complex constant in Go syntax. These behave like Go&#39;s untyped
</span><a id="L102"></a><span class="ln">   102</span>	<span class="comment">	  constants, although raw strings may not span newlines.
</span><a id="L103"></a><span class="ln">   103</span>	<span class="comment">	- The character &#39;.&#39; (period):
</span><a id="L104"></a><span class="ln">   104</span>	<span class="comment">		.
</span><a id="L105"></a><span class="ln">   105</span>	<span class="comment">	  The result is the value of dot.
</span><a id="L106"></a><span class="ln">   106</span>	<span class="comment">	- A variable name, which is a (possibly empty) alphanumeric string
</span><a id="L107"></a><span class="ln">   107</span>	<span class="comment">	  preceded by a dollar sign, such as
</span><a id="L108"></a><span class="ln">   108</span>	<span class="comment">		$piOver2
</span><a id="L109"></a><span class="ln">   109</span>	<span class="comment">	  or
</span><a id="L110"></a><span class="ln">   110</span>	<span class="comment">		$
</span><a id="L111"></a><span class="ln">   111</span>	<span class="comment">	  The result is the value of the variable.
</span><a id="L112"></a><span class="ln">   112</span>	<span class="comment">	  Variables are described below.
</span><a id="L113"></a><span class="ln">   113</span>	<span class="comment">	- The name of a field of the data, which must be a struct, preceded
</span><a id="L114"></a><span class="ln">   114</span>	<span class="comment">	  by a period, such as
</span><a id="L115"></a><span class="ln">   115</span>	<span class="comment">		.Field
</span><a id="L116"></a><span class="ln">   116</span>	<span class="comment">	  The result is the value of the field. Field invocations may be
</span><a id="L117"></a><span class="ln">   117</span>	<span class="comment">	  chained:
</span><a id="L118"></a><span class="ln">   118</span>	<span class="comment">	    .Field1.Field2
</span><a id="L119"></a><span class="ln">   119</span>	<span class="comment">	  Fields can also be evaluated on variables, including chaining:
</span><a id="L120"></a><span class="ln">   120</span>	<span class="comment">	    $x.Field1.Field2
</span><a id="L121"></a><span class="ln">   121</span>	<span class="comment">	- The name of a key of the data, which must be a map, preceded
</span><a id="L122"></a><span class="ln">   122</span>	<span class="comment">	  by a period, such as
</span><a id="L123"></a><span class="ln">   123</span>	<span class="comment">		.Key
</span><a id="L124"></a><span class="ln">   124</span>	<span class="comment">	  The result is the map element value indexed by the key.
</span><a id="L125"></a><span class="ln">   125</span>	<span class="comment">	  Key invocations may be chained and combined with fields to any
</span><a id="L126"></a><span class="ln">   126</span>	<span class="comment">	  depth:
</span><a id="L127"></a><span class="ln">   127</span>	<span class="comment">	    .Field1.Key1.Field2.Key2
</span><a id="L128"></a><span class="ln">   128</span>	<span class="comment">	  Although the key must be an alphanumeric identifier, unlike with
</span><a id="L129"></a><span class="ln">   129</span>	<span class="comment">	  field names they do not need to start with an upper case letter.
</span><a id="L130"></a><span class="ln">   130</span>	<span class="comment">	  Keys can also be evaluated on variables, including chaining:
</span><a id="L131"></a><span class="ln">   131</span>	<span class="comment">	    $x.key1.key2
</span><a id="L132"></a><span class="ln">   132</span>	<span class="comment">	- The name of a niladic method of the data, preceded by a period,
</span><a id="L133"></a><span class="ln">   133</span>	<span class="comment">	  such as
</span><a id="L134"></a><span class="ln">   134</span>	<span class="comment">		.Method
</span><a id="L135"></a><span class="ln">   135</span>	<span class="comment">	  The result is the value of invoking the method with dot as the
</span><a id="L136"></a><span class="ln">   136</span>	<span class="comment">	  receiver, dot.Method(). Such a method must have one return value (of
</span><a id="L137"></a><span class="ln">   137</span>	<span class="comment">	  any type) or two return values, the second of which is an error.
</span><a id="L138"></a><span class="ln">   138</span>	<span class="comment">	  If it has two and the returned error is non-nil, execution terminates
</span><a id="L139"></a><span class="ln">   139</span>	<span class="comment">	  and an error is returned to the caller as the value of Execute.
</span><a id="L140"></a><span class="ln">   140</span>	<span class="comment">	  Method invocations may be chained and combined with fields and keys
</span><a id="L141"></a><span class="ln">   141</span>	<span class="comment">	  to any depth:
</span><a id="L142"></a><span class="ln">   142</span>	<span class="comment">	    .Field1.Key1.Method1.Field2.Key2.Method2
</span><a id="L143"></a><span class="ln">   143</span>	<span class="comment">	  Methods can also be evaluated on variables, including chaining:
</span><a id="L144"></a><span class="ln">   144</span>	<span class="comment">	    $x.Method1.Field
</span><a id="L145"></a><span class="ln">   145</span>	<span class="comment">	- The name of a niladic function, such as
</span><a id="L146"></a><span class="ln">   146</span>	<span class="comment">		fun
</span><a id="L147"></a><span class="ln">   147</span>	<span class="comment">	  The result is the value of invoking the function, fun(). The return
</span><a id="L148"></a><span class="ln">   148</span>	<span class="comment">	  types and values behave as in methods. Functions and function
</span><a id="L149"></a><span class="ln">   149</span>	<span class="comment">	  names are described below.
</span><a id="L150"></a><span class="ln">   150</span>	<span class="comment">
</span><a id="L151"></a><span class="ln">   151</span>	<span class="comment">Arguments may evaluate to any type; if they are pointers the implementation
</span><a id="L152"></a><span class="ln">   152</span>	<span class="comment">automatically indirects to the base type when required.
</span><a id="L153"></a><span class="ln">   153</span>	<span class="comment">If an evaluation yields a function value, such as a function-valued
</span><a id="L154"></a><span class="ln">   154</span>	<span class="comment">field of a struct, the function is not invoked automatically, but it
</span><a id="L155"></a><span class="ln">   155</span>	<span class="comment">can be used as a truth value for an if action and the like. To invoke
</span><a id="L156"></a><span class="ln">   156</span>	<span class="comment">it, use the call function, defined below.
</span><a id="L157"></a><span class="ln">   157</span>	<span class="comment">
</span><a id="L158"></a><span class="ln">   158</span>	<span class="comment">A pipeline is a possibly chained sequence of &#34;commands&#34;. A command is a simple
</span><a id="L159"></a><span class="ln">   159</span>	<span class="comment">value (argument) or a function or method call, possibly with multiple arguments:
</span><a id="L160"></a><span class="ln">   160</span>	<span class="comment">
</span><a id="L161"></a><span class="ln">   161</span>	<span class="comment">	Argument
</span><a id="L162"></a><span class="ln">   162</span>	<span class="comment">		The result is the value of evaluating the argument.
</span><a id="L163"></a><span class="ln">   163</span>	<span class="comment">	.Method [Argument...]
</span><a id="L164"></a><span class="ln">   164</span>	<span class="comment">		The method can be alone or the last element of a chain but,
</span><a id="L165"></a><span class="ln">   165</span>	<span class="comment">		unlike methods in the middle of a chain, it can take arguments.
</span><a id="L166"></a><span class="ln">   166</span>	<span class="comment">		The result is the value of calling the method with the
</span><a id="L167"></a><span class="ln">   167</span>	<span class="comment">		arguments:
</span><a id="L168"></a><span class="ln">   168</span>	<span class="comment">			dot.Method(Argument1, etc.)
</span><a id="L169"></a><span class="ln">   169</span>	<span class="comment">	functionName [Argument...]
</span><a id="L170"></a><span class="ln">   170</span>	<span class="comment">		The result is the value of calling the function associated
</span><a id="L171"></a><span class="ln">   171</span>	<span class="comment">		with the name:
</span><a id="L172"></a><span class="ln">   172</span>	<span class="comment">			function(Argument1, etc.)
</span><a id="L173"></a><span class="ln">   173</span>	<span class="comment">		Functions and function names are described below.
</span><a id="L174"></a><span class="ln">   174</span>	<span class="comment">
</span><a id="L175"></a><span class="ln">   175</span>	<span class="comment">Pipelines
</span><a id="L176"></a><span class="ln">   176</span>	<span class="comment">
</span><a id="L177"></a><span class="ln">   177</span>	<span class="comment">A pipeline may be &#34;chained&#34; by separating a sequence of commands with pipeline
</span><a id="L178"></a><span class="ln">   178</span>	<span class="comment">characters &#39;|&#39;. In a chained pipeline, the result of the each command is
</span><a id="L179"></a><span class="ln">   179</span>	<span class="comment">passed as the last argument of the following command. The output of the final
</span><a id="L180"></a><span class="ln">   180</span>	<span class="comment">command in the pipeline is the value of the pipeline.
</span><a id="L181"></a><span class="ln">   181</span>	<span class="comment">
</span><a id="L182"></a><span class="ln">   182</span>	<span class="comment">The output of a command will be either one value or two values, the second of
</span><a id="L183"></a><span class="ln">   183</span>	<span class="comment">which has type error. If that second value is present and evaluates to
</span><a id="L184"></a><span class="ln">   184</span>	<span class="comment">non-nil, execution terminates and the error is returned to the caller of
</span><a id="L185"></a><span class="ln">   185</span>	<span class="comment">Execute.
</span><a id="L186"></a><span class="ln">   186</span>	<span class="comment">
</span><a id="L187"></a><span class="ln">   187</span>	<span class="comment">Variables
</span><a id="L188"></a><span class="ln">   188</span>	<span class="comment">
</span><a id="L189"></a><span class="ln">   189</span>	<span class="comment">A pipeline inside an action may initialize a variable to capture the result.
</span><a id="L190"></a><span class="ln">   190</span>	<span class="comment">The initialization has syntax
</span><a id="L191"></a><span class="ln">   191</span>	<span class="comment">
</span><a id="L192"></a><span class="ln">   192</span>	<span class="comment">	$variable := pipeline
</span><a id="L193"></a><span class="ln">   193</span>	<span class="comment">
</span><a id="L194"></a><span class="ln">   194</span>	<span class="comment">where $variable is the name of the variable. An action that declares a
</span><a id="L195"></a><span class="ln">   195</span>	<span class="comment">variable produces no output.
</span><a id="L196"></a><span class="ln">   196</span>	<span class="comment">
</span><a id="L197"></a><span class="ln">   197</span>	<span class="comment">If a &#34;range&#34; action initializes a variable, the variable is set to the
</span><a id="L198"></a><span class="ln">   198</span>	<span class="comment">successive elements of the iteration.  Also, a &#34;range&#34; may declare two
</span><a id="L199"></a><span class="ln">   199</span>	<span class="comment">variables, separated by a comma:
</span><a id="L200"></a><span class="ln">   200</span>	<span class="comment">
</span><a id="L201"></a><span class="ln">   201</span>	<span class="comment">	$index, $element := pipeline
</span><a id="L202"></a><span class="ln">   202</span>	<span class="comment">
</span><a id="L203"></a><span class="ln">   203</span>	<span class="comment">in which case $index and $element are set to the successive values of the
</span><a id="L204"></a><span class="ln">   204</span>	<span class="comment">array/slice index or map key and element, respectively.  Note that if there is
</span><a id="L205"></a><span class="ln">   205</span>	<span class="comment">only one variable, it is assigned the element; this is opposite to the
</span><a id="L206"></a><span class="ln">   206</span>	<span class="comment">convention in Go range clauses.
</span><a id="L207"></a><span class="ln">   207</span>	<span class="comment">
</span><a id="L208"></a><span class="ln">   208</span>	<span class="comment">A variable&#39;s scope extends to the &#34;end&#34; action of the control structure (&#34;if&#34;,
</span><a id="L209"></a><span class="ln">   209</span>	<span class="comment">&#34;with&#34;, or &#34;range&#34;) in which it is declared, or to the end of the template if
</span><a id="L210"></a><span class="ln">   210</span>	<span class="comment">there is no such control structure.  A template invocation does not inherit
</span><a id="L211"></a><span class="ln">   211</span>	<span class="comment">variables from the point of its invocation.
</span><a id="L212"></a><span class="ln">   212</span>	<span class="comment">
</span><a id="L213"></a><span class="ln">   213</span>	<span class="comment">When execution begins, $ is set to the data argument passed to Execute, that is,
</span><a id="L214"></a><span class="ln">   214</span>	<span class="comment">to the starting value of dot.
</span><a id="L215"></a><span class="ln">   215</span>	<span class="comment">
</span><a id="L216"></a><span class="ln">   216</span>	<span class="comment">Examples
</span><a id="L217"></a><span class="ln">   217</span>	<span class="comment">
</span><a id="L218"></a><span class="ln">   218</span>	<span class="comment">Here are some example one-line templates demonstrating pipelines and variables.
</span><a id="L219"></a><span class="ln">   219</span>	<span class="comment">All produce the quoted word &#34;output&#34;:
</span><a id="L220"></a><span class="ln">   220</span>	<span class="comment">
</span><a id="L221"></a><span class="ln">   221</span>	<span class="comment">	{{&#34;\&#34;output\&#34;&#34;}}
</span><a id="L222"></a><span class="ln">   222</span>	<span class="comment">		A string constant.
</span><a id="L223"></a><span class="ln">   223</span>	<span class="comment">	{{`&#34;output&#34;`}}
</span><a id="L224"></a><span class="ln">   224</span>	<span class="comment">		A raw string constant.
</span><a id="L225"></a><span class="ln">   225</span>	<span class="comment">	{{printf &#34;%q&#34; &#34;output&#34;}}
</span><a id="L226"></a><span class="ln">   226</span>	<span class="comment">		A function call.
</span><a id="L227"></a><span class="ln">   227</span>	<span class="comment">	{{&#34;output&#34; | printf &#34;%q&#34;}}
</span><a id="L228"></a><span class="ln">   228</span>	<span class="comment">		A function call whose final argument comes from the previous
</span><a id="L229"></a><span class="ln">   229</span>	<span class="comment">		command.
</span><a id="L230"></a><span class="ln">   230</span>	<span class="comment">	{{&#34;put&#34; | printf &#34;%s%s&#34; &#34;out&#34; | printf &#34;%q&#34;}}
</span><a id="L231"></a><span class="ln">   231</span>	<span class="comment">		A more elaborate call.
</span><a id="L232"></a><span class="ln">   232</span>	<span class="comment">	{{&#34;output&#34; | printf &#34;%s&#34; | printf &#34;%q&#34;}}
</span><a id="L233"></a><span class="ln">   233</span>	<span class="comment">		A longer chain.
</span><a id="L234"></a><span class="ln">   234</span>	<span class="comment">	{{with &#34;output&#34;}}{{printf &#34;%q&#34; .}}{{end}}
</span><a id="L235"></a><span class="ln">   235</span>	<span class="comment">		A with action using dot.
</span><a id="L236"></a><span class="ln">   236</span>	<span class="comment">	{{with $x := &#34;output&#34; | printf &#34;%q&#34;}}{{$x}}{{end}}
</span><a id="L237"></a><span class="ln">   237</span>	<span class="comment">		A with action that creates and uses a variable.
</span><a id="L238"></a><span class="ln">   238</span>	<span class="comment">	{{with $x := &#34;output&#34;}}{{printf &#34;%q&#34; $x}}{{end}}
</span><a id="L239"></a><span class="ln">   239</span>	<span class="comment">		A with action that uses the variable in another action.
</span><a id="L240"></a><span class="ln">   240</span>	<span class="comment">	{{with $x := &#34;output&#34;}}{{$x | printf &#34;%q&#34;}}{{end}}
</span><a id="L241"></a><span class="ln">   241</span>	<span class="comment">		The same, but pipelined.
</span><a id="L242"></a><span class="ln">   242</span>	<span class="comment">
</span><a id="L243"></a><span class="ln">   243</span>	<span class="comment">Functions
</span><a id="L244"></a><span class="ln">   244</span>	<span class="comment">
</span><a id="L245"></a><span class="ln">   245</span>	<span class="comment">During execution functions are found in two function maps: first in the
</span><a id="L246"></a><span class="ln">   246</span>	<span class="comment">template, then in the global function map. By default, no functions are defined
</span><a id="L247"></a><span class="ln">   247</span>	<span class="comment">in the template but the Funcs method can be used to add them.
</span><a id="L248"></a><span class="ln">   248</span>	<span class="comment">
</span><a id="L249"></a><span class="ln">   249</span>	<span class="comment">Predefined global functions are named as follows.
</span><a id="L250"></a><span class="ln">   250</span>	<span class="comment">
</span><a id="L251"></a><span class="ln">   251</span>	<span class="comment">	and
</span><a id="L252"></a><span class="ln">   252</span>	<span class="comment">		Returns the boolean AND of its arguments by returning the
</span><a id="L253"></a><span class="ln">   253</span>	<span class="comment">		first empty argument or the last argument, that is,
</span><a id="L254"></a><span class="ln">   254</span>	<span class="comment">		&#34;and x y&#34; behaves as &#34;if x then y else x&#34;. All the
</span><a id="L255"></a><span class="ln">   255</span>	<span class="comment">		arguments are evaluated.
</span><a id="L256"></a><span class="ln">   256</span>	<span class="comment">	call
</span><a id="L257"></a><span class="ln">   257</span>	<span class="comment">		Returns the result of calling the first argument, which
</span><a id="L258"></a><span class="ln">   258</span>	<span class="comment">		must be a function, with the remaining arguments as parameters.
</span><a id="L259"></a><span class="ln">   259</span>	<span class="comment">		Thus &#34;call .X.Y 1 2&#34; is, in Go notation, dot.X.Y(1, 2) where
</span><a id="L260"></a><span class="ln">   260</span>	<span class="comment">		Y is a func-valued field, map entry, or the like.
</span><a id="L261"></a><span class="ln">   261</span>	<span class="comment">		The first argument must be the result of an evaluation
</span><a id="L262"></a><span class="ln">   262</span>	<span class="comment">		that yields a value of function type (as distinct from
</span><a id="L263"></a><span class="ln">   263</span>	<span class="comment">		a predefined function such as print). The function must
</span><a id="L264"></a><span class="ln">   264</span>	<span class="comment">		return either one or two result values, the second of which
</span><a id="L265"></a><span class="ln">   265</span>	<span class="comment">		is of type error. If the arguments don&#39;t match the function
</span><a id="L266"></a><span class="ln">   266</span>	<span class="comment">		or the returned error value is non-nil, execution stops.
</span><a id="L267"></a><span class="ln">   267</span>	<span class="comment">	html
</span><a id="L268"></a><span class="ln">   268</span>	<span class="comment">		Returns the escaped HTML equivalent of the textual
</span><a id="L269"></a><span class="ln">   269</span>	<span class="comment">		representation of its arguments.
</span><a id="L270"></a><span class="ln">   270</span>	<span class="comment">	index
</span><a id="L271"></a><span class="ln">   271</span>	<span class="comment">		Returns the result of indexing its first argument by the
</span><a id="L272"></a><span class="ln">   272</span>	<span class="comment">		following arguments. Thus &#34;index x 1 2 3&#34; is, in Go syntax,
</span><a id="L273"></a><span class="ln">   273</span>	<span class="comment">		x[1][2][3]. Each indexed item must be a map, slice, or array.
</span><a id="L274"></a><span class="ln">   274</span>	<span class="comment">	js
</span><a id="L275"></a><span class="ln">   275</span>	<span class="comment">		Returns the escaped JavaScript equivalent of the textual
</span><a id="L276"></a><span class="ln">   276</span>	<span class="comment">		representation of its arguments.
</span><a id="L277"></a><span class="ln">   277</span>	<span class="comment">	len
</span><a id="L278"></a><span class="ln">   278</span>	<span class="comment">		Returns the integer length of its argument.
</span><a id="L279"></a><span class="ln">   279</span>	<span class="comment">	not
</span><a id="L280"></a><span class="ln">   280</span>	<span class="comment">		Returns the boolean negation of its single argument.
</span><a id="L281"></a><span class="ln">   281</span>	<span class="comment">	or
</span><a id="L282"></a><span class="ln">   282</span>	<span class="comment">		Returns the boolean OR of its arguments by returning the
</span><a id="L283"></a><span class="ln">   283</span>	<span class="comment">		first non-empty argument or the last argument, that is,
</span><a id="L284"></a><span class="ln">   284</span>	<span class="comment">		&#34;or x y&#34; behaves as &#34;if x then x else y&#34;. All the
</span><a id="L285"></a><span class="ln">   285</span>	<span class="comment">		arguments are evaluated.
</span><a id="L286"></a><span class="ln">   286</span>	<span class="comment">	print
</span><a id="L287"></a><span class="ln">   287</span>	<span class="comment">		An alias for fmt.Sprint
</span><a id="L288"></a><span class="ln">   288</span>	<span class="comment">	printf
</span><a id="L289"></a><span class="ln">   289</span>	<span class="comment">		An alias for fmt.Sprintf
</span><a id="L290"></a><span class="ln">   290</span>	<span class="comment">	println
</span><a id="L291"></a><span class="ln">   291</span>	<span class="comment">		An alias for fmt.Sprintln
</span><a id="L292"></a><span class="ln">   292</span>	<span class="comment">	urlquery
</span><a id="L293"></a><span class="ln">   293</span>	<span class="comment">		Returns the escaped value of the textual representation of
</span><a id="L294"></a><span class="ln">   294</span>	<span class="comment">		its arguments in a form suitable for embedding in a URL query.
</span><a id="L295"></a><span class="ln">   295</span>	<span class="comment">
</span><a id="L296"></a><span class="ln">   296</span>	<span class="comment">The boolean functions take any zero value to be false and a non-zero value to
</span><a id="L297"></a><span class="ln">   297</span>	<span class="comment">be true.
</span><a id="L298"></a><span class="ln">   298</span>	<span class="comment">
</span><a id="L299"></a><span class="ln">   299</span>	<span class="comment">Associated templates
</span><a id="L300"></a><span class="ln">   300</span>	<span class="comment">
</span><a id="L301"></a><span class="ln">   301</span>	<span class="comment">Each template is named by a string specified when it is created. Also, each
</span><a id="L302"></a><span class="ln">   302</span>	<span class="comment">template is associated with zero or more other templates that it may invoke by
</span><a id="L303"></a><span class="ln">   303</span>	<span class="comment">name; such associations are transitive and form a name space of templates.
</span><a id="L304"></a><span class="ln">   304</span>	<span class="comment">
</span><a id="L305"></a><span class="ln">   305</span>	<span class="comment">A template may use a template invocation to instantiate another associated
</span><a id="L306"></a><span class="ln">   306</span>	<span class="comment">template; see the explanation of the &#34;template&#34; action above. The name must be
</span><a id="L307"></a><span class="ln">   307</span>	<span class="comment">that of a template associated with the template that contains the invocation.
</span><a id="L308"></a><span class="ln">   308</span>	<span class="comment">
</span><a id="L309"></a><span class="ln">   309</span>	<span class="comment">Nested template definitions
</span><a id="L310"></a><span class="ln">   310</span>	<span class="comment">
</span><a id="L311"></a><span class="ln">   311</span>	<span class="comment">When parsing a template, another template may be defined and associated with the
</span><a id="L312"></a><span class="ln">   312</span>	<span class="comment">template being parsed. Template definitions must appear at the top level of the
</span><a id="L313"></a><span class="ln">   313</span>	<span class="comment">template, much like global variables in a Go program.
</span><a id="L314"></a><span class="ln">   314</span>	<span class="comment">
</span><a id="L315"></a><span class="ln">   315</span>	<span class="comment">The syntax of such definitions is to surround each template declaration with a
</span><a id="L316"></a><span class="ln">   316</span>	<span class="comment">&#34;define&#34; and &#34;end&#34; action.
</span><a id="L317"></a><span class="ln">   317</span>	<span class="comment">
</span><a id="L318"></a><span class="ln">   318</span>	<span class="comment">The define action names the template being created by providing a string
</span><a id="L319"></a><span class="ln">   319</span>	<span class="comment">constant. Here is a simple example:
</span><a id="L320"></a><span class="ln">   320</span>	<span class="comment">
</span><a id="L321"></a><span class="ln">   321</span>	<span class="comment">	`{{define &#34;T1&#34;}}ONE{{end}}
</span><a id="L322"></a><span class="ln">   322</span>	<span class="comment">	{{define &#34;T2&#34;}}TWO{{end}}
</span><a id="L323"></a><span class="ln">   323</span>	<span class="comment">	{{define &#34;T3&#34;}}{{template &#34;T1&#34;}} {{template &#34;T2&#34;}}{{end}}
</span><a id="L324"></a><span class="ln">   324</span>	<span class="comment">	{{template &#34;T3&#34;}}`
</span><a id="L325"></a><span class="ln">   325</span>	<span class="comment">
</span><a id="L326"></a><span class="ln">   326</span>	<span class="comment">This defines two templates, T1 and T2, and a third T3 that invokes the other two
</span><a id="L327"></a><span class="ln">   327</span>	<span class="comment">when it is executed. Finally it invokes T3. If executed this template will
</span><a id="L328"></a><span class="ln">   328</span>	<span class="comment">produce the text
</span><a id="L329"></a><span class="ln">   329</span>	<span class="comment">
</span><a id="L330"></a><span class="ln">   330</span>	<span class="comment">	ONE TWO
</span><a id="L331"></a><span class="ln">   331</span>	<span class="comment">
</span><a id="L332"></a><span class="ln">   332</span>	<span class="comment">By construction, a template may reside in only one association. If it&#39;s
</span><a id="L333"></a><span class="ln">   333</span>	<span class="comment">necessary to have a template addressable from multiple associations, the
</span><a id="L334"></a><span class="ln">   334</span>	<span class="comment">template definition must be parsed multiple times to create distinct *Template
</span><a id="L335"></a><span class="ln">   335</span>	<span class="comment">values, or must be copied with the Clone or AddParseTree method.
</span><a id="L336"></a><span class="ln">   336</span>	<span class="comment">
</span><a id="L337"></a><span class="ln">   337</span>	<span class="comment">Parse may be called multiple times to assemble the various associated templates;
</span><a id="L338"></a><span class="ln">   338</span>	<span class="comment">see the ParseFiles and ParseGlob functions and methods for simple ways to parse
</span><a id="L339"></a><span class="ln">   339</span>	<span class="comment">related templates stored in files.
</span><a id="L340"></a><span class="ln">   340</span>	<span class="comment">
</span><a id="L341"></a><span class="ln">   341</span>	<span class="comment">A template may be executed directly or through ExecuteTemplate, which executes
</span><a id="L342"></a><span class="ln">   342</span>	<span class="comment">an associated template identified by name. To invoke our example above, we
</span><a id="L343"></a><span class="ln">   343</span>	<span class="comment">might write,
</span><a id="L344"></a><span class="ln">   344</span>	<span class="comment">
</span><a id="L345"></a><span class="ln">   345</span>	<span class="comment">	err := tmpl.Execute(os.Stdout, &#34;no data needed&#34;)
</span><a id="L346"></a><span class="ln">   346</span>	<span class="comment">	if err != nil {
</span><a id="L347"></a><span class="ln">   347</span>	<span class="comment">		log.Fatalf(&#34;execution failed: %s&#34;, err)
</span><a id="L348"></a><span class="ln">   348</span>	<span class="comment">	}
</span><a id="L349"></a><span class="ln">   349</span>	<span class="comment">
</span><a id="L350"></a><span class="ln">   350</span>	<span class="comment">or to invoke a particular template explicitly by name,
</span><a id="L351"></a><span class="ln">   351</span>	<span class="comment">
</span><a id="L352"></a><span class="ln">   352</span>	<span class="comment">	err := tmpl.ExecuteTemplate(os.Stdout, &#34;T2&#34;, &#34;no data needed&#34;)
</span><a id="L353"></a><span class="ln">   353</span>	<span class="comment">	if err != nil {
</span><a id="L354"></a><span class="ln">   354</span>	<span class="comment">		log.Fatalf(&#34;execution failed: %s&#34;, err)
</span><a id="L355"></a><span class="ln">   355</span>	<span class="comment">	}
</span><a id="L356"></a><span class="ln">   356</span>	<span class="comment">
</span><a id="L357"></a><span class="ln">   357</span>	<span class="comment">*/</span>
<a id="L358"></a><span class="ln">   358</span>	package template
</pre>

</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>

