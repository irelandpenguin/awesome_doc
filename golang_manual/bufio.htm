
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>bufio - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>

<div id="topbar"><div class="container wide">

</div></div>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package bufio</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "bufio"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package bufio implements buffered I/O.  It wraps an io.Reader or io.Writer
object, creating another object (Reader or Writer) that also implements
the interface but provides buffering and some help for textual I/O.
</p>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
				<dd><a href="#variables">Variables</a></dd>
			
			
			
				
				<dd><a href="#ReadWriter">type ReadWriter</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReadWriter">func NewReadWriter(r *Reader, w *Writer) *ReadWriter</a></dd>
				
				
			
				
				<dd><a href="#Reader">type Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReader">func NewReader(rd io.Reader) *Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReaderSize">func NewReaderSize(rd io.Reader, size int) *Reader</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Buffered">func (b *Reader) Buffered() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Peek">func (b *Reader) Peek(n int) ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Read">func (b *Reader) Read(p []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadByte">func (b *Reader) ReadByte() (c byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadBytes">func (b *Reader) ReadBytes(delim byte) (line []byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadLine">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadRune">func (b *Reader) ReadRune() (r rune, size int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadSlice">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadString">func (b *Reader) ReadString(delim byte) (line string, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.UnreadByte">func (b *Reader) UnreadByte() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.UnreadRune">func (b *Reader) UnreadRune() error</a></dd>
				
			
				
				<dd><a href="#Writer">type Writer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewWriter">func NewWriter(wr io.Writer) *Writer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewWriterSize">func NewWriterSize(wr io.Writer, size int) *Writer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.Available">func (b *Writer) Available() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.Buffered">func (b *Writer) Buffered() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.Flush">func (b *Writer) Flush() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.Write">func (b *Writer) Write(p []byte) (nn int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.WriteByte">func (b *Writer) WriteByte(c byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.WriteRune">func (b *Writer) WriteRune(r rune) (size int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.WriteString">func (b *Writer) WriteString(s string) (int, error)</a></dd>
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/bufio/bufio.htm">bufio.go</a>
			
			</span>
			</p>
		
	
		
		
			<h2 id="variables">Variables</h2>
			
				<pre>var (
    ErrInvalidUnreadByte = errors.New(&#34;bufio: invalid use of UnreadByte&#34;)
    ErrInvalidUnreadRune = errors.New(&#34;bufio: invalid use of UnreadRune&#34;)
    ErrBufferFull        = errors.New(&#34;bufio: buffer full&#34;)
    ErrNegativeCount     = errors.New(&#34;bufio: negative count&#34;)
)</pre>
				
			
		
		
		
			
			
			<h2 id="ReadWriter">type <a href="src/pkg/bufio/bufio.htm#L526">ReadWriter</a></h2>
			<pre>type ReadWriter struct {
    *Reader
    *Writer
}</pre>
			<p>
ReadWriter stores pointers to a Reader and a Writer.
It implements io.ReadWriter.
</p>


			

			

			

			
				
				<h3 id="NewReadWriter">func <a href="src/pkg/bufio/bufio.htm#L532">NewReadWriter</a></h3>
				<pre>func NewReadWriter(r *Reader, w *Writer) *ReadWriter</pre>
				<p>
NewReadWriter allocates a new ReadWriter that dispatches to r and w.
</p>

				
			

			
		
			
			
			<h2 id="Reader">type <a href="src/pkg/bufio/bufio.htm#L21">Reader</a></h2>
			<pre>type Reader struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Reader implements buffering for an io.Reader object.
</p>


			

			

			

			
				
				<h3 id="NewReader">func <a href="src/pkg/bufio/bufio.htm#L53">NewReader</a></h3>
				<pre>func NewReader(rd io.Reader) *Reader</pre>
				<p>
NewReader returns a new Reader whose buffer has the default size.
</p>

				
			
				
				<h3 id="NewReaderSize">func <a href="src/pkg/bufio/bufio.htm#L35">NewReaderSize</a></h3>
				<pre>func NewReaderSize(rd io.Reader, size int) *Reader</pre>
				<p>
NewReaderSize returns a new Reader whose buffer has at least the specified
size. If the argument io.Reader is already a Reader with large enough
size, it returns the underlying Reader.
</p>

				
			

			
				
				<h3 id="Reader.Buffered">func (*Reader) <a href="src/pkg/bufio/bufio.htm#L218">Buffered</a></h3>
				<pre>func (b *Reader) Buffered() int</pre>
				<p>
Buffered returns the number of bytes that can be read from the current buffer.
</p>

				
				
			
				
				<h3 id="Reader.Peek">func (*Reader) <a href="src/pkg/bufio/bufio.htm#L84">Peek</a></h3>
				<pre>func (b *Reader) Peek(n int) ([]byte, error)</pre>
				<p>
Peek returns the next n bytes without advancing the reader. The bytes stop
being valid at the next read call. If Peek returns fewer than n bytes, it
also returns an error explaining why the read is short. The error is
ErrBufferFull if n is larger than b&#39;s buffer size.
</p>

				
				
			
				
				<h3 id="Reader.Read">func (*Reader) <a href="src/pkg/bufio/bufio.htm#L113">Read</a></h3>
				<pre>func (b *Reader) Read(p []byte) (n int, err error)</pre>
				<p>
Read reads data into p.
It returns the number of bytes read into p.
It calls Read at most once on the underlying Reader,
hence n may be less than len(p).
At EOF, the count will be zero and err will be io.EOF.
</p>

				
				
			
				
				<h3 id="Reader.ReadByte">func (*Reader) <a href="src/pkg/bufio/bufio.htm#L150">ReadByte</a></h3>
				<pre>func (b *Reader) ReadByte() (c byte, err error)</pre>
				<p>
ReadByte reads and returns a single byte.
If no byte is available, returns an error.
</p>

				
				
			
				
				<h3 id="Reader.ReadBytes">func (*Reader) <a href="src/pkg/bufio/bufio.htm#L313">ReadBytes</a></h3>
				<pre>func (b *Reader) ReadBytes(delim byte) (line []byte, err error)</pre>
				<p>
ReadBytes reads until the first occurrence of delim in the input,
returning a slice containing the data up to and including the delimiter.
If ReadBytes encounters an error before finding a delimiter,
it returns the data read before the error and the error itself (often io.EOF).
ReadBytes returns err != nil if and only if the returned data does not end in
delim.
</p>

				
				
			
				
				<h3 id="Reader.ReadLine">func (*Reader) <a href="src/pkg/bufio/bufio.htm#L272">ReadLine</a></h3>
				<pre>func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</pre>
				<p>
ReadLine tries to return a single line, not including the end-of-line bytes.
If the line was too long for the buffer then isPrefix is set and the
beginning of the line is returned. The rest of the line will be returned
from future calls. isPrefix will be false when returning the last fragment
of the line. The returned buffer is only valid until the next call to
ReadLine. ReadLine either returns a non-nil line or it returns an error,
never both.
</p>

				
				
			
				
				<h3 id="Reader.ReadRune">func (*Reader) <a href="src/pkg/bufio/bufio.htm#L185">ReadRune</a></h3>
				<pre>func (b *Reader) ReadRune() (r rune, size int, err error)</pre>
				<p>
ReadRune reads a single UTF-8 encoded Unicode character and returns the
rune and its size in bytes. If the encoded rune is invalid, it consumes one byte
and returns unicode.ReplacementChar (U+FFFD) with a size of 1.
</p>

				
				
			
				
				<h3 id="Reader.ReadSlice">func (*Reader) <a href="src/pkg/bufio/bufio.htm#L230">ReadSlice</a></h3>
				<pre>func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</pre>
				<p>
ReadSlice reads until the first occurrence of delim in the input,
returning a slice pointing at the bytes in the buffer.
The bytes stop being valid at the next read call.
If ReadSlice encounters an error before finding a delimiter,
it returns all the data in the buffer and the error itself (often io.EOF).
ReadSlice fails with error ErrBufferFull if the buffer fills without a delim.
Because the data returned from ReadSlice will be overwritten
by the next I/O operation, most clients should use
ReadBytes or ReadString instead.
ReadSlice returns err != nil if and only if line does not end in delim.
</p>

				
				
			
				
				<h3 id="Reader.ReadString">func (*Reader) <a href="src/pkg/bufio/bufio.htm#L360">ReadString</a></h3>
				<pre>func (b *Reader) ReadString(delim byte) (line string, err error)</pre>
				<p>
ReadString reads until the first occurrence of delim in the input,
returning a string containing the data up to and including the delimiter.
If ReadString encounters an error before finding a delimiter,
it returns the data read before the error and the error itself (often io.EOF).
ReadString returns err != nil if and only if the returned data does not end in
delim.
</p>

				
				
			
				
				<h3 id="Reader.UnreadByte">func (*Reader) <a href="src/pkg/bufio/bufio.htm#L165">UnreadByte</a></h3>
				<pre>func (b *Reader) UnreadByte() error</pre>
				<p>
UnreadByte unreads the last byte.  Only the most recently read byte can be unread.
</p>

				
				
			
				
				<h3 id="Reader.UnreadRune">func (*Reader) <a href="src/pkg/bufio/bufio.htm#L207">UnreadRune</a></h3>
				<pre>func (b *Reader) UnreadRune() error</pre>
				<p>
UnreadRune unreads the last rune.  If the most recent read operation on
the buffer was not a ReadRune, UnreadRune returns an error.  (In this
regard it is stricter than UnreadByte, which will unread the last byte
from any read operation.)
</p>

				
				
			
		
			
			
			<h2 id="Writer">type <a href="src/pkg/bufio/bufio.htm#L370">Writer</a></h2>
			<pre>type Writer struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
Writer implements buffering for an io.Writer object.
If an error occurs writing to a Writer, no more data will be
accepted and all subsequent writes will return the error.
</p>


			

			

			

			
				
				<h3 id="NewWriter">func <a href="src/pkg/bufio/bufio.htm#L396">NewWriter</a></h3>
				<pre>func NewWriter(wr io.Writer) *Writer</pre>
				<p>
NewWriter returns a new Writer whose buffer has the default size.
</p>

				
			
				
				<h3 id="NewWriterSize">func <a href="src/pkg/bufio/bufio.htm#L380">NewWriterSize</a></h3>
				<pre>func NewWriterSize(wr io.Writer, size int) *Writer</pre>
				<p>
NewWriterSize returns a new Writer whose buffer has at least the specified
size. If the argument io.Writer is already a Writer with large enough
size, it returns the underlying Writer.
</p>

				
			

			
				
				<h3 id="Writer.Available">func (*Writer) <a href="src/pkg/bufio/bufio.htm#L425">Available</a></h3>
				<pre>func (b *Writer) Available() int</pre>
				<p>
Available returns how many bytes are unused in the buffer.
</p>

				
				
			
				
				<h3 id="Writer.Buffered">func (*Writer) <a href="src/pkg/bufio/bufio.htm#L428">Buffered</a></h3>
				<pre>func (b *Writer) Buffered() int</pre>
				<p>
Buffered returns the number of bytes that have been written into the current buffer.
</p>

				
				
			
				
				<h3 id="Writer.Flush">func (*Writer) <a href="src/pkg/bufio/bufio.htm#L401">Flush</a></h3>
				<pre>func (b *Writer) Flush() error</pre>
				<p>
Flush writes any buffered data to the underlying io.Writer.
</p>

				
				
			
				
				<h3 id="Writer.Write">func (*Writer) <a href="src/pkg/bufio/bufio.htm#L434">Write</a></h3>
				<pre>func (b *Writer) Write(p []byte) (nn int, err error)</pre>
				<p>
Write writes the contents of p into the buffer.
It returns the number of bytes written.
If nn &lt; len(p), it also returns an error explaining
why the write is short.
</p>

				
				
			
				
				<h3 id="Writer.WriteByte">func (*Writer) <a href="src/pkg/bufio/bufio.htm#L459">WriteByte</a></h3>
				<pre>func (b *Writer) WriteByte(c byte) error</pre>
				<p>
WriteByte writes a single byte.
</p>

				
				
			
				
				<h3 id="Writer.WriteRune">func (*Writer) <a href="src/pkg/bufio/bufio.htm#L473">WriteRune</a></h3>
				<pre>func (b *Writer) WriteRune(r rune) (size int, err error)</pre>
				<p>
WriteRune writes a single Unicode code point, returning
the number of bytes written and any error.
</p>

				
				
			
				
				<h3 id="Writer.WriteString">func (*Writer) <a href="src/pkg/bufio/bufio.htm#L504">WriteString</a></h3>
				<pre>func (b *Writer) WriteString(s string) (int, error)</pre>
				<p>
WriteString writes a string.
It returns the number of bytes written.
If the count is less than len(s), it also returns an error explaining
why the write is short.
</p>

				
				
			
		
		</div>
	

	









</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
