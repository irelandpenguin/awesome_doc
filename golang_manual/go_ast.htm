
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>ast - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package ast</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "go/ast"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
				<dd><a href="#examples">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package ast declares the types used to represent syntax trees for Go
packages.
</p>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#FileExports">func FileExports(src *File) bool</a></dd>
			
				
				<dd><a href="#FilterDecl">func FilterDecl(decl Decl, f Filter) bool</a></dd>
			
				
				<dd><a href="#FilterFile">func FilterFile(src *File, f Filter) bool</a></dd>
			
				
				<dd><a href="#FilterPackage">func FilterPackage(pkg *Package, f Filter) bool</a></dd>
			
				
				<dd><a href="#Fprint">func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) (err error)</a></dd>
			
				
				<dd><a href="#Inspect">func Inspect(node Node, f func(Node) bool)</a></dd>
			
				
				<dd><a href="#IsExported">func IsExported(name string) bool</a></dd>
			
				
				<dd><a href="#NotNilFilter">func NotNilFilter(_ string, v reflect.Value) bool</a></dd>
			
				
				<dd><a href="#PackageExports">func PackageExports(pkg *Package) bool</a></dd>
			
				
				<dd><a href="#Print">func Print(fset *token.FileSet, x interface{}) error</a></dd>
			
				
				<dd><a href="#SortImports">func SortImports(fset *token.FileSet, f *File)</a></dd>
			
				
				<dd><a href="#Walk">func Walk(v Visitor, node Node)</a></dd>
			
			
				
				<dd><a href="#ArrayType">type ArrayType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ArrayType.End">func (x *ArrayType) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ArrayType.Pos">func (x *ArrayType) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#AssignStmt">type AssignStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AssignStmt.End">func (s *AssignStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AssignStmt.Pos">func (s *AssignStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#BadDecl">type BadDecl</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BadDecl.End">func (d *BadDecl) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BadDecl.Pos">func (d *BadDecl) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#BadExpr">type BadExpr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BadExpr.End">func (x *BadExpr) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BadExpr.Pos">func (x *BadExpr) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#BadStmt">type BadStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BadStmt.End">func (s *BadStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BadStmt.Pos">func (s *BadStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#BasicLit">type BasicLit</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BasicLit.End">func (x *BasicLit) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BasicLit.Pos">func (x *BasicLit) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#BinaryExpr">type BinaryExpr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BinaryExpr.End">func (x *BinaryExpr) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BinaryExpr.Pos">func (x *BinaryExpr) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#BlockStmt">type BlockStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BlockStmt.End">func (s *BlockStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BlockStmt.Pos">func (s *BlockStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#BranchStmt">type BranchStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BranchStmt.End">func (s *BranchStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BranchStmt.Pos">func (s *BranchStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#CallExpr">type CallExpr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CallExpr.End">func (x *CallExpr) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CallExpr.Pos">func (x *CallExpr) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#CaseClause">type CaseClause</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CaseClause.End">func (s *CaseClause) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CaseClause.Pos">func (s *CaseClause) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#ChanDir">type ChanDir</a></dd>
				
				
			
				
				<dd><a href="#ChanType">type ChanType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ChanType.End">func (x *ChanType) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ChanType.Pos">func (x *ChanType) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#CommClause">type CommClause</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CommClause.End">func (s *CommClause) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CommClause.Pos">func (s *CommClause) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#Comment">type Comment</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Comment.End">func (c *Comment) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Comment.Pos">func (c *Comment) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#CommentGroup">type CommentGroup</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CommentGroup.End">func (g *CommentGroup) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CommentGroup.Pos">func (g *CommentGroup) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CommentGroup.Text">func (g *CommentGroup) Text() string</a></dd>
				
			
				
				<dd><a href="#CompositeLit">type CompositeLit</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CompositeLit.End">func (x *CompositeLit) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CompositeLit.Pos">func (x *CompositeLit) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#Decl">type Decl</a></dd>
				
				
			
				
				<dd><a href="#DeclStmt">type DeclStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DeclStmt.End">func (s *DeclStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DeclStmt.Pos">func (s *DeclStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#DeferStmt">type DeferStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DeferStmt.End">func (s *DeferStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DeferStmt.Pos">func (s *DeferStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#Ellipsis">type Ellipsis</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Ellipsis.End">func (x *Ellipsis) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Ellipsis.Pos">func (x *Ellipsis) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#EmptyStmt">type EmptyStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#EmptyStmt.End">func (s *EmptyStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EmptyStmt.Pos">func (s *EmptyStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#Expr">type Expr</a></dd>
				
				
			
				
				<dd><a href="#ExprStmt">type ExprStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ExprStmt.End">func (s *ExprStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ExprStmt.Pos">func (s *ExprStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#Field">type Field</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Field.End">func (f *Field) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Field.Pos">func (f *Field) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#FieldFilter">type FieldFilter</a></dd>
				
				
			
				
				<dd><a href="#FieldList">type FieldList</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FieldList.End">func (f *FieldList) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FieldList.NumFields">func (f *FieldList) NumFields() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FieldList.Pos">func (f *FieldList) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#File">type File</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MergePackageFiles">func MergePackageFiles(pkg *Package, mode MergeMode) *File</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#File.End">func (f *File) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Pos">func (f *File) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#Filter">type Filter</a></dd>
				
				
			
				
				<dd><a href="#ForStmt">type ForStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ForStmt.End">func (s *ForStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ForStmt.Pos">func (s *ForStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#FuncDecl">type FuncDecl</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FuncDecl.End">func (d *FuncDecl) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FuncDecl.Pos">func (d *FuncDecl) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#FuncLit">type FuncLit</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FuncLit.End">func (x *FuncLit) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FuncLit.Pos">func (x *FuncLit) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#FuncType">type FuncType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FuncType.End">func (x *FuncType) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FuncType.Pos">func (x *FuncType) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#GenDecl">type GenDecl</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#GenDecl.End">func (d *GenDecl) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GenDecl.Pos">func (d *GenDecl) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#GoStmt">type GoStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#GoStmt.End">func (s *GoStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GoStmt.Pos">func (s *GoStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#Ident">type Ident</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewIdent">func NewIdent(name string) *Ident</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Ident.End">func (x *Ident) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Ident.IsExported">func (id *Ident) IsExported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Ident.Pos">func (x *Ident) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Ident.String">func (id *Ident) String() string</a></dd>
				
			
				
				<dd><a href="#IfStmt">type IfStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IfStmt.End">func (s *IfStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IfStmt.Pos">func (s *IfStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#ImportSpec">type ImportSpec</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ImportSpec.End">func (s *ImportSpec) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ImportSpec.Pos">func (s *ImportSpec) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#Importer">type Importer</a></dd>
				
				
			
				
				<dd><a href="#IncDecStmt">type IncDecStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IncDecStmt.End">func (s *IncDecStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IncDecStmt.Pos">func (s *IncDecStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#IndexExpr">type IndexExpr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexExpr.End">func (x *IndexExpr) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexExpr.Pos">func (x *IndexExpr) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#InterfaceType">type InterfaceType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#InterfaceType.End">func (x *InterfaceType) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#InterfaceType.Pos">func (x *InterfaceType) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#KeyValueExpr">type KeyValueExpr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#KeyValueExpr.End">func (x *KeyValueExpr) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#KeyValueExpr.Pos">func (x *KeyValueExpr) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#LabeledStmt">type LabeledStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#LabeledStmt.End">func (s *LabeledStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LabeledStmt.Pos">func (s *LabeledStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#MapType">type MapType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MapType.End">func (x *MapType) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MapType.Pos">func (x *MapType) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#MergeMode">type MergeMode</a></dd>
				
				
			
				
				<dd><a href="#Node">type Node</a></dd>
				
				
			
				
				<dd><a href="#ObjKind">type ObjKind</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ObjKind.String">func (kind ObjKind) String() string</a></dd>
				
			
				
				<dd><a href="#Object">type Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewObj">func NewObj(kind ObjKind, name string) *Object</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Object.Pos">func (obj *Object) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#Package">type Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewPackage">func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.End">func (p *Package) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.Pos">func (p *Package) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#ParenExpr">type ParenExpr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ParenExpr.End">func (x *ParenExpr) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParenExpr.Pos">func (x *ParenExpr) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#RangeStmt">type RangeStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RangeStmt.End">func (s *RangeStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RangeStmt.Pos">func (s *RangeStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#ReturnStmt">type ReturnStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ReturnStmt.End">func (s *ReturnStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ReturnStmt.Pos">func (s *ReturnStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#Scope">type Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewScope">func NewScope(outer *Scope) *Scope</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.Insert">func (s *Scope) Insert(obj *Object) (alt *Object)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.Lookup">func (s *Scope) Lookup(name string) *Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.String">func (s *Scope) String() string</a></dd>
				
			
				
				<dd><a href="#SelectStmt">type SelectStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SelectStmt.End">func (s *SelectStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SelectStmt.Pos">func (s *SelectStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#SelectorExpr">type SelectorExpr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SelectorExpr.End">func (x *SelectorExpr) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SelectorExpr.Pos">func (x *SelectorExpr) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#SendStmt">type SendStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SendStmt.End">func (s *SendStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SendStmt.Pos">func (s *SendStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#SliceExpr">type SliceExpr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SliceExpr.End">func (x *SliceExpr) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SliceExpr.Pos">func (x *SliceExpr) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#Spec">type Spec</a></dd>
				
				
			
				
				<dd><a href="#StarExpr">type StarExpr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#StarExpr.End">func (x *StarExpr) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StarExpr.Pos">func (x *StarExpr) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#Stmt">type Stmt</a></dd>
				
				
			
				
				<dd><a href="#StructType">type StructType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#StructType.End">func (x *StructType) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StructType.Pos">func (x *StructType) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#SwitchStmt">type SwitchStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SwitchStmt.End">func (s *SwitchStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SwitchStmt.Pos">func (s *SwitchStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#TypeAssertExpr">type TypeAssertExpr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAssertExpr.End">func (x *TypeAssertExpr) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAssertExpr.Pos">func (x *TypeAssertExpr) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#TypeSpec">type TypeSpec</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeSpec.End">func (s *TypeSpec) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeSpec.Pos">func (s *TypeSpec) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#TypeSwitchStmt">type TypeSwitchStmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeSwitchStmt.End">func (s *TypeSwitchStmt) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeSwitchStmt.Pos">func (s *TypeSwitchStmt) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#UnaryExpr">type UnaryExpr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnaryExpr.End">func (x *UnaryExpr) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnaryExpr.Pos">func (x *UnaryExpr) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#ValueSpec">type ValueSpec</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ValueSpec.End">func (s *ValueSpec) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ValueSpec.Pos">func (s *ValueSpec) Pos() token.Pos</a></dd>
				
			
				
				<dd><a href="#Visitor">type Visitor</a></dd>
				
				
			
			
		</dl>

		
			<h4 id="examples">Examples</h4>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Inspect">Inspect</a></dd>
			
			<dd><a class="exampleLink" href="#example_Print">Print</a></dd>
			
			</dl>
		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/go/ast/ast.htm">ast.go</a>
			
				<a href="src/pkg/go/ast/filter.htm">filter.go</a>
			
				<a href="src/pkg/go/ast/import.htm">import.go</a>
			
				<a href="src/pkg/go/ast/print.htm">print.go</a>
			
				<a href="src/pkg/go/ast/resolve.htm">resolve.go</a>
			
				<a href="src/pkg/go/ast/scope.htm">scope.go</a>
			
				<a href="src/pkg/go/ast/walk.htm">walk.go</a>
			
			</span>
			</p>
		
	
		
		
		
			
			
			<h2 id="FileExports">func <a href="src/pkg/go/ast/filter.htm#L19">FileExports</a></h2>
			<pre>func FileExports(src *File) bool</pre>
			<p>
FileExports trims the AST for a Go source file in place such that
only exported nodes remain: all top-level identifiers which are not exported
and their associated information (such as type, initial value, or function
body) are removed. Non-exported fields and methods of exported types are
stripped. The File.Comments list is not changed.
</p>
<p>
FileExports returns true if there are exported declarations;
it returns false otherwise.
</p>

			
		
			
			
			<h2 id="FilterDecl">func <a href="src/pkg/go/ast/filter.htm#L195">FilterDecl</a></h2>
			<pre>func FilterDecl(decl Decl, f Filter) bool</pre>
			<p>
FilterDecl trims the AST for a Go declaration in place by removing
all names (including struct field and interface method names, but
not from parameter lists) that don&#39;t pass through the filter f.
</p>
<p>
FilterDecl returns true if there are any declared names left after
filtering; it returns false otherwise.
</p>

			
		
			
			
			<h2 id="FilterFile">func <a href="src/pkg/go/ast/filter.htm#L220">FilterFile</a></h2>
			<pre>func FilterFile(src *File, f Filter) bool</pre>
			<p>
FilterFile trims the AST for a Go file in place by removing all
names from top-level declarations (including struct field and
interface method names, but not from parameter lists) that don&#39;t
pass through the filter f. If the declaration is empty afterwards,
the declaration is removed from the AST. The File.Comments list
is not changed.
</p>
<p>
FilterFile returns true if there are any top-level declarations
left after filtering; it returns false otherwise.
</p>

			
		
			
			
			<h2 id="FilterPackage">func <a href="src/pkg/go/ast/filter.htm#L247">FilterPackage</a></h2>
			<pre>func FilterPackage(pkg *Package, f Filter) bool</pre>
			<p>
FilterPackage trims the AST for a Go package in place by removing
all names from top-level declarations (including struct field and
interface method names, but not from parameter lists) that don&#39;t
pass through the filter f. If the declaration is empty afterwards,
the declaration is removed from the AST. The pkg.Files list is not
changed, so that file names and top-level package comments don&#39;t get
lost.
</p>
<p>
FilterPackage returns true if there are any top-level declarations
left after filtering; it returns false otherwise.
</p>

			
		
			
			
			<h2 id="Fprint">func <a href="src/pkg/go/ast/print.htm#L29">Fprint</a></h2>
			<pre>func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) (err error)</pre>
			<p>
Fprint prints the (sub-)tree starting at AST node x to w.
If fset != nil, position information is interpreted relative
to that file set. Otherwise positions are printed as integer
values (file set specific offsets).
</p>
<p>
A non-nil FieldFilter f may be provided to control the output:
struct fields for which f(fieldname, fieldvalue) is true are
are printed; all others are filtered from the output.
</p>

			
		
			
			
			<h2 id="Inspect">func <a href="src/pkg/go/ast/walk.htm#L370">Inspect</a></h2>
			<pre>func Inspect(node Node, f func(Node) bool)</pre>
			<p>
Inspect traverses an AST in depth-first order: It starts by calling
f(node); node must not be nil. If f returns true, Inspect invokes f
for all the non-nil children of node, recursively.
</p>

			<div id="example_Inspect" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		<p>This example demonstrates how to inspect the AST of a Go program.
</p>
		<p>Code:</p>
		<pre class="code"><span class="comment">// src is the input for which we want to inspect the AST.</span>
src := `
package p
const c = 1.0
var X = f(3.14)*2 + c
`

<span class="comment">// Create the AST by parsing src.</span>
fset := token.NewFileSet() <span class="comment">// positions are relative to fset</span>
f, err := parser.ParseFile(fset, &#34;src.go&#34;, src, 0)
if err != nil {
    panic(err)
}

<span class="comment">// Inspect the AST and print all identifiers and literals.</span>
ast.Inspect(f, func(n ast.Node) bool {
    var s string
    switch x := n.(type) {
    case *ast.BasicLit:
        s = x.Value
    case *ast.Ident:
        s = x.Name
    }
    if s != &#34;&#34; {
        fmt.Printf(&#34;%s:\t%s\n&#34;, fset.Position(n.Pos()), s)
    }
    return true
})

<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">src.go:2:9:	p
src.go:3:7:	c
src.go:3:11:	1.0
src.go:4:5:	X
src.go:4:9:	f
src.go:4:11:	3.14
src.go:4:17:	2
src.go:4:21:	c</pre>
		
	</div>
</div>

		
			
			
			<h2 id="IsExported">func <a href="src/pkg/go/ast/ast.htm#L511">IsExported</a></h2>
			<pre>func IsExported(name string) bool</pre>
			<p>
IsExported returns whether name is an exported Go symbol
(i.e., whether it begins with an uppercase letter).
</p>

			
		
			
			
			<h2 id="NotNilFilter">func <a href="src/pkg/go/ast/print.htm#L12">NotNilFilter</a></h2>
			<pre>func NotNilFilter(_ string, v reflect.Value) bool</pre>
			<p>
NotNilFilter returns true for field values that are not nil;
it returns false otherwise.
</p>

			
		
			
			
			<h2 id="PackageExports">func <a href="src/pkg/go/ast/filter.htm#L30">PackageExports</a></h2>
			<pre>func PackageExports(pkg *Package) bool</pre>
			<p>
PackageExports trims the AST for a Go package in place such that
only exported nodes remain. The pkg.Files list is not changed, so that
file names and top-level package comments don&#39;t get lost.
</p>
<p>
PackageExports returns true if there are exported declarations;
it returns false otherwise.
</p>

			
		
			
			
			<h2 id="Print">func <a href="src/pkg/go/ast/print.htm#L59">Print</a></h2>
			<pre>func Print(fset *token.FileSet, x interface{}) error</pre>
			<p>
Print prints x to standard output, skipping nil fields.
Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).
</p>

			<div id="example_Print" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">? <span class="text">Example</span></p>
		<p>This example shows what an AST looks like when printed for debugging.
</p>
		<p>Code:</p>
		<pre class="code"><span class="comment">// src is the input for which we want to print the AST.</span>
src := `
package main
func main() {
println(&#34;Hello, World!&#34;)
}
`

<span class="comment">// Create the AST by parsing src.</span>
fset := token.NewFileSet() <span class="comment">// positions are relative to fset</span>
f, err := parser.ParseFile(fset, &#34;&#34;, src, 0)
if err != nil {
    panic(err)
}

<span class="comment">// Print the AST.</span>
ast.Print(fset, f)

<span class="comment"></pre>
		
		<p>Output:</p>
		<pre class="output">0  *ast.File {
     1  .  Package: 2:1
     2  .  Name: *ast.Ident {
     3  .  .  NamePos: 2:9
     4  .  .  Name: &#34;main&#34;
     5  .  }
     6  .  Decls: []ast.Decl (len = 1) {
     7  .  .  0: *ast.FuncDecl {
     8  .  .  .  Name: *ast.Ident {
     9  .  .  .  .  NamePos: 3:6
    10  .  .  .  .  Name: &#34;main&#34;
    11  .  .  .  .  Obj: *ast.Object {
    12  .  .  .  .  .  Kind: func
    13  .  .  .  .  .  Name: &#34;main&#34;
    14  .  .  .  .  .  Decl: *(obj @ 7)
    15  .  .  .  .  }
    16  .  .  .  }
    17  .  .  .  Type: *ast.FuncType {
    18  .  .  .  .  Func: 3:1
    19  .  .  .  .  Params: *ast.FieldList {
    20  .  .  .  .  .  Opening: 3:10
    21  .  .  .  .  .  Closing: 3:11
    22  .  .  .  .  }
    23  .  .  .  }
    24  .  .  .  Body: *ast.BlockStmt {
    25  .  .  .  .  Lbrace: 3:13
    26  .  .  .  .  List: []ast.Stmt (len = 1) {
    27  .  .  .  .  .  0: *ast.ExprStmt {
    28  .  .  .  .  .  .  X: *ast.CallExpr {
    29  .  .  .  .  .  .  .  Fun: *ast.Ident {
    30  .  .  .  .  .  .  .  .  NamePos: 4:2
    31  .  .  .  .  .  .  .  .  Name: &#34;println&#34;
    32  .  .  .  .  .  .  .  }
    33  .  .  .  .  .  .  .  Lparen: 4:9
    34  .  .  .  .  .  .  .  Args: []ast.Expr (len = 1) {
    35  .  .  .  .  .  .  .  .  0: *ast.BasicLit {
    36  .  .  .  .  .  .  .  .  .  ValuePos: 4:10
    37  .  .  .  .  .  .  .  .  .  Kind: STRING
    38  .  .  .  .  .  .  .  .  .  Value: &#34;\&#34;Hello, World!\&#34;&#34;
    39  .  .  .  .  .  .  .  .  }
    40  .  .  .  .  .  .  .  }
    41  .  .  .  .  .  .  .  Ellipsis: -
    42  .  .  .  .  .  .  .  Rparen: 4:25
    43  .  .  .  .  .  .  }
    44  .  .  .  .  .  }
    45  .  .  .  .  }
    46  .  .  .  .  Rbrace: 5:1
    47  .  .  .  }
    48  .  .  }
    49  .  }
    50  .  Scope: *ast.Scope {
    51  .  .  Objects: map[string]*ast.Object (len = 1) {
    52  .  .  .  &#34;main&#34;: *(obj @ 11)
    53  .  .  }
    54  .  }
    55  .  Unresolved: []*ast.Ident (len = 1) {
    56  .  .  0: *(obj @ 29)
    57  .  }
    58  }</pre>
		
	</div>
</div>

		
			
			
			<h2 id="SortImports">func <a href="src/pkg/go/ast/import.htm#L4">SortImports</a></h2>
			<pre>func SortImports(fset *token.FileSet, f *File)</pre>
			<p>
SortImports sorts runs of consecutive import lines in import blocks in f.
</p>

			
		
			
			
			<h2 id="Walk">func <a href="src/pkg/go/ast/walk.htm#L41">Walk</a></h2>
			<pre>func Walk(v Visitor, node Node)</pre>
			<p>
Walk traverses an AST in depth-first order: It starts by calling
v.Visit(node); node must not be nil. If the visitor w returned by
v.Visit(node) is not nil, Walk is invoked recursively with visitor
w for each of the non-nil children of node, followed by a call of
w.Visit(nil).
</p>

			
		
		
			
			
			<h2 id="ArrayType">type <a href="src/pkg/go/ast/ast.htm#L359">ArrayType</a></h2>
			<pre>type ArrayType struct {
    Lbrack token.Pos <span class="comment">// position of &#34;[&#34;</span>
    Len    Expr      <span class="comment">// Ellipsis node for [...]T array types, nil for slice types</span>
    Elt    Expr      <span class="comment">// element type</span>
}</pre>
			<p>
An ArrayType node represents an array or slice type.
</p>


			

			

			

			

			
				
				<h3 id="ArrayType.End">func (*ArrayType) <a href="src/pkg/go/ast/ast.htm#L459">End</a></h3>
				<pre>func (x *ArrayType) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="ArrayType.Pos">func (*ArrayType) <a href="src/pkg/go/ast/ast.htm#L426">Pos</a></h3>
				<pre>func (x *ArrayType) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="AssignStmt">type <a href="src/pkg/go/ast/ast.htm#L587">AssignStmt</a></h2>
			<pre>type AssignStmt struct {
    Lhs    []Expr
    TokPos token.Pos   <span class="comment">// position of Tok</span>
    Tok    token.Token <span class="comment">// assignment token, DEFINE</span>
    Rhs    []Expr
}</pre>
			<p>
An AssignStmt node represents an assignment or
a short variable declaration.
</p>


			

			

			

			

			
				
				<h3 id="AssignStmt.End">func (*AssignStmt) <a href="src/pkg/go/ast/ast.htm#L730">End</a></h3>
				<pre>func (s *AssignStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="AssignStmt.Pos">func (*AssignStmt) <a href="src/pkg/go/ast/ast.htm#L704">Pos</a></h3>
				<pre>func (s *AssignStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="BadDecl">type <a href="src/pkg/go/ast/ast.htm#L880">BadDecl</a></h2>
			<pre>type BadDecl struct {
    From, To token.Pos <span class="comment">// position range of bad declaration</span>
}</pre>
			<p>
A BadDecl node is a placeholder for declarations containing
syntax errors for which no correct declaration nodes can be
created.
</p>


			

			

			

			

			
				
				<h3 id="BadDecl.End">func (*BadDecl) <a href="src/pkg/go/ast/ast.htm#L920">End</a></h3>
				<pre>func (d *BadDecl) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="BadDecl.Pos">func (*BadDecl) <a href="src/pkg/go/ast/ast.htm#L916">Pos</a></h3>
				<pre>func (d *BadDecl) Pos() token.Pos</pre>
				<p>
Pos and End implementations for declaration nodes.
</p>

				
				
			
		
			
			
			<h2 id="BadExpr">type <a href="src/pkg/go/ast/ast.htm#L221">BadExpr</a></h2>
			<pre>type BadExpr struct {
    From, To token.Pos <span class="comment">// position range of bad expression</span>
}</pre>
			<p>
A BadExpr node is a placeholder for expressions containing
syntax errors for which no correct expression nodes can be
created.
</p>


			

			

			

			

			
				
				<h3 id="BadExpr.End">func (*BadExpr) <a href="src/pkg/go/ast/ast.htm#L433">End</a></h3>
				<pre>func (x *BadExpr) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="BadExpr.Pos">func (*BadExpr) <a href="src/pkg/go/ast/ast.htm#L405">Pos</a></h3>
				<pre>func (x *BadExpr) Pos() token.Pos</pre>
				<p>
Pos and End implementations for expression/type nodes.
</p>

				
				
			
		
			
			
			<h2 id="BadStmt">type <a href="src/pkg/go/ast/ast.htm#L539">BadStmt</a></h2>
			<pre>type BadStmt struct {
    From, To token.Pos <span class="comment">// position range of bad statement</span>
}</pre>
			<p>
A BadStmt node is a placeholder for statements containing
syntax errors for which no correct statement nodes can be
created.
</p>


			

			

			

			

			
				
				<h3 id="BadStmt.End">func (*BadStmt) <a href="src/pkg/go/ast/ast.htm#L719">End</a></h3>
				<pre>func (s *BadStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="BadStmt.Pos">func (*BadStmt) <a href="src/pkg/go/ast/ast.htm#L697">Pos</a></h3>
				<pre>func (s *BadStmt) Pos() token.Pos</pre>
				<p>
Pos and End implementations for statement nodes.
</p>

				
				
			
		
			
			
			<h2 id="BasicLit">type <a href="src/pkg/go/ast/ast.htm#L241">BasicLit</a></h2>
			<pre>type BasicLit struct {
    ValuePos token.Pos   <span class="comment">// literal position</span>
    Kind     token.Token <span class="comment">// token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING</span>
    Value    string      <span class="comment">// literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, &#39;a&#39;, &#39;\x7f&#39;, &#34;foo&#34; or `\m\n\o`</span>
}</pre>
			<p>
A BasicLit node represents a literal of basic type.
</p>


			

			

			

			

			
				
				<h3 id="BasicLit.End">func (*BasicLit) <a href="src/pkg/go/ast/ast.htm#L441">End</a></h3>
				<pre>func (x *BasicLit) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="BasicLit.Pos">func (*BasicLit) <a href="src/pkg/go/ast/ast.htm#L408">Pos</a></h3>
				<pre>func (x *BasicLit) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="BinaryExpr">type <a href="src/pkg/go/ast/ast.htm#L326">BinaryExpr</a></h2>
			<pre>type BinaryExpr struct {
    X     Expr        <span class="comment">// left operand</span>
    OpPos token.Pos   <span class="comment">// position of Op</span>
    Op    token.Token <span class="comment">// operator</span>
    Y     Expr        <span class="comment">// right operand</span>
}</pre>
			<p>
A BinaryExpr node represents a binary expression.
</p>


			

			

			

			

			
				
				<h3 id="BinaryExpr.End">func (*BinaryExpr) <a href="src/pkg/go/ast/ast.htm#L457">End</a></h3>
				<pre>func (x *BinaryExpr) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="BinaryExpr.Pos">func (*BinaryExpr) <a href="src/pkg/go/ast/ast.htm#L424">Pos</a></h3>
				<pre>func (x *BinaryExpr) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="BlockStmt">type <a href="src/pkg/go/ast/ast.htm#L622">BlockStmt</a></h2>
			<pre>type BlockStmt struct {
    Lbrace token.Pos <span class="comment">// position of &#34;{&#34;</span>
    List   []Stmt
    Rbrace token.Pos <span class="comment">// position of &#34;}&#34;</span>
}</pre>
			<p>
A BlockStmt node represents a braced statement list.
</p>


			

			

			

			

			
				
				<h3 id="BlockStmt.End">func (*BlockStmt) <a href="src/pkg/go/ast/ast.htm#L745">End</a></h3>
				<pre>func (s *BlockStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="BlockStmt.Pos">func (*BlockStmt) <a href="src/pkg/go/ast/ast.htm#L709">Pos</a></h3>
				<pre>func (s *BlockStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="BranchStmt">type <a href="src/pkg/go/ast/ast.htm#L615">BranchStmt</a></h2>
			<pre>type BranchStmt struct {
    TokPos token.Pos   <span class="comment">// position of Tok</span>
    Tok    token.Token <span class="comment">// keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)</span>
    Label  *Ident      <span class="comment">// label name; or nil</span>
}</pre>
			<p>
A BranchStmt node represents a break, continue, goto,
or fallthrough statement.
</p>


			

			

			

			

			
				
				<h3 id="BranchStmt.End">func (*BranchStmt) <a href="src/pkg/go/ast/ast.htm#L739">End</a></h3>
				<pre>func (s *BranchStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="BranchStmt.Pos">func (*BranchStmt) <a href="src/pkg/go/ast/ast.htm#L708">Pos</a></h3>
				<pre>func (s *BranchStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="CallExpr">type <a href="src/pkg/go/ast/ast.htm#L300">CallExpr</a></h2>
			<pre>type CallExpr struct {
    Fun      Expr      <span class="comment">// function expression</span>
    Lparen   token.Pos <span class="comment">// position of &#34;(&#34;</span>
    Args     []Expr    <span class="comment">// function arguments; or nil</span>
    Ellipsis token.Pos <span class="comment">// position of &#34;...&#34;, if any</span>
    Rparen   token.Pos <span class="comment">// position of &#34;)&#34;</span>
}</pre>
			<p>
A CallExpr node represents an expression followed by an argument list.
</p>


			

			

			

			

			
				
				<h3 id="CallExpr.End">func (*CallExpr) <a href="src/pkg/go/ast/ast.htm#L454">End</a></h3>
				<pre>func (x *CallExpr) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="CallExpr.Pos">func (*CallExpr) <a href="src/pkg/go/ast/ast.htm#L421">Pos</a></h3>
				<pre>func (x *CallExpr) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="CaseClause">type <a href="src/pkg/go/ast/ast.htm#L638">CaseClause</a></h2>
			<pre>type CaseClause struct {
    Case  token.Pos <span class="comment">// position of &#34;case&#34; or &#34;default&#34; keyword</span>
    List  []Expr    <span class="comment">// list of expressions or types; nil means default case</span>
    Colon token.Pos <span class="comment">// position of &#34;:&#34;</span>
    Body  []Stmt    <span class="comment">// statement list; or nil</span>
}</pre>
			<p>
A CaseClause represents a case of an expression or type switch statement.
</p>


			

			

			

			

			
				
				<h3 id="CaseClause.End">func (*CaseClause) <a href="src/pkg/go/ast/ast.htm#L752">End</a></h3>
				<pre>func (s *CaseClause) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="CaseClause.Pos">func (*CaseClause) <a href="src/pkg/go/ast/ast.htm#L711">Pos</a></h3>
				<pre>func (s *CaseClause) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="ChanDir">type <a href="src/pkg/go/ast/ast.htm#L346">ChanDir</a></h2>
			<pre>type ChanDir int</pre>
			<p>
The direction of a channel type is indicated by one
of the following constants.
</p>


			
				<pre>const (
    SEND ChanDir = 1 &lt;&lt; iota
    RECV
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="ChanType">type <a href="src/pkg/go/ast/ast.htm#L396">ChanType</a></h2>
			<pre>type ChanType struct {
    Begin token.Pos <span class="comment">// position of &#34;chan&#34; keyword or &#34;&lt;-&#34; (whichever comes first)</span>
    Dir   ChanDir   <span class="comment">// channel direction</span>
    Value Expr      <span class="comment">// value type</span>
}</pre>
			<p>
A ChanType node represents a channel type.
</p>


			

			

			

			

			
				
				<h3 id="ChanType.End">func (*ChanType) <a href="src/pkg/go/ast/ast.htm#L469">End</a></h3>
				<pre>func (x *ChanType) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="ChanType.Pos">func (*ChanType) <a href="src/pkg/go/ast/ast.htm#L431">Pos</a></h3>
				<pre>func (x *ChanType) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="CommClause">type <a href="src/pkg/go/ast/ast.htm#L662">CommClause</a></h2>
			<pre>type CommClause struct {
    Case  token.Pos <span class="comment">// position of &#34;case&#34; or &#34;default&#34; keyword</span>
    Comm  Stmt      <span class="comment">// send or receive statement; nil means default case</span>
    Colon token.Pos <span class="comment">// position of &#34;:&#34;</span>
    Body  []Stmt    <span class="comment">// statement list; or nil</span>
}</pre>
			<p>
A CommClause node represents a case of a select statement.
</p>


			

			

			

			

			
				
				<h3 id="CommClause.End">func (*CommClause) <a href="src/pkg/go/ast/ast.htm#L760">End</a></h3>
				<pre>func (s *CommClause) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="CommClause.Pos">func (*CommClause) <a href="src/pkg/go/ast/ast.htm#L714">Pos</a></h3>
				<pre>func (s *CommClause) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="Comment">type <a href="src/pkg/go/ast/ast.htm#L52">Comment</a></h2>
			<pre>type Comment struct {
    Slash token.Pos <span class="comment">// position of &#34;/&#34; starting the comment</span>
    Text  string    <span class="comment">// comment text (excluding &#39;\n&#39; for //-style comments)</span>
}</pre>
			<p>
A Comment node represents a single //-style or /*-style comment.
</p>


			

			

			

			

			
				
				<h3 id="Comment.End">func (*Comment) <a href="src/pkg/go/ast/ast.htm#L58">End</a></h3>
				<pre>func (c *Comment) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="Comment.Pos">func (*Comment) <a href="src/pkg/go/ast/ast.htm#L57">Pos</a></h3>
				<pre>func (c *Comment) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="CommentGroup">type <a href="src/pkg/go/ast/ast.htm#L63">CommentGroup</a></h2>
			<pre>type CommentGroup struct {
    List []*Comment <span class="comment">// len(List) &gt; 0</span>
}</pre>
			<p>
A CommentGroup represents a sequence of comments
with no other tokens and no empty lines between.
</p>


			

			

			

			

			
				
				<h3 id="CommentGroup.End">func (*CommentGroup) <a href="src/pkg/go/ast/ast.htm#L68">End</a></h3>
				<pre>func (g *CommentGroup) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="CommentGroup.Pos">func (*CommentGroup) <a href="src/pkg/go/ast/ast.htm#L67">Pos</a></h3>
				<pre>func (g *CommentGroup) Pos() token.Pos</pre>
				
				
				
			
				
				<h3 id="CommentGroup.Text">func (*CommentGroup) <a href="src/pkg/go/ast/ast.htm#L82">Text</a></h3>
				<pre>func (g *CommentGroup) Text() string</pre>
				<p>
Text returns the text of the comment,
with the comment markers - //, /*, and */ - removed.
</p>

				
				
			
		
			
			
			<h2 id="CompositeLit">type <a href="src/pkg/go/ast/ast.htm#L254">CompositeLit</a></h2>
			<pre>type CompositeLit struct {
    Type   Expr      <span class="comment">// literal type; or nil</span>
    Lbrace token.Pos <span class="comment">// position of &#34;{&#34;</span>
    Elts   []Expr    <span class="comment">// list of composite elements; or nil</span>
    Rbrace token.Pos <span class="comment">// position of &#34;}&#34;</span>
}</pre>
			<p>
A CompositeLit node represents a composite literal.
</p>


			

			

			

			

			
				
				<h3 id="CompositeLit.End">func (*CompositeLit) <a href="src/pkg/go/ast/ast.htm#L443">End</a></h3>
				<pre>func (x *CompositeLit) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="CompositeLit.Pos">func (*CompositeLit) <a href="src/pkg/go/ast/ast.htm#L410">Pos</a></h3>
				<pre>func (x *CompositeLit) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="Decl">type <a href="src/pkg/go/ast/ast.htm#L43">Decl</a></h2>
			<pre>type Decl interface {
    Node
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
			<p>
All declaration nodes implement the Decl interface.
</p>


			

			

			

			

			
		
			
			
			<h2 id="DeclStmt">type <a href="src/pkg/go/ast/ast.htm#L544">DeclStmt</a></h2>
			<pre>type DeclStmt struct {
    Decl Decl
}</pre>
			<p>
A DeclStmt node represents a declaration in a statement list.
</p>


			

			

			

			

			
				
				<h3 id="DeclStmt.End">func (*DeclStmt) <a href="src/pkg/go/ast/ast.htm#L720">End</a></h3>
				<pre>func (s *DeclStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="DeclStmt.Pos">func (*DeclStmt) <a href="src/pkg/go/ast/ast.htm#L698">Pos</a></h3>
				<pre>func (s *DeclStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="DeferStmt">type <a href="src/pkg/go/ast/ast.htm#L601">DeferStmt</a></h2>
			<pre>type DeferStmt struct {
    Defer token.Pos <span class="comment">// position of &#34;defer&#34; keyword</span>
    Call  *CallExpr
}</pre>
			<p>
A DeferStmt node represents a defer statement.
</p>


			

			

			

			

			
				
				<h3 id="DeferStmt.End">func (*DeferStmt) <a href="src/pkg/go/ast/ast.htm#L732">End</a></h3>
				<pre>func (s *DeferStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="DeferStmt.Pos">func (*DeferStmt) <a href="src/pkg/go/ast/ast.htm#L706">Pos</a></h3>
				<pre>func (s *DeferStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="Ellipsis">type <a href="src/pkg/go/ast/ast.htm#L235">Ellipsis</a></h2>
			<pre>type Ellipsis struct {
    Ellipsis token.Pos <span class="comment">// position of &#34;...&#34;</span>
    Elt      Expr      <span class="comment">// ellipsis element type (parameter lists only); or nil</span>
}</pre>
			<p>
An Ellipsis node stands for the &#34;...&#34; type in a
parameter list or the &#34;...&#34; length in an array type.
</p>


			

			

			

			

			
				
				<h3 id="Ellipsis.End">func (*Ellipsis) <a href="src/pkg/go/ast/ast.htm#L435">End</a></h3>
				<pre>func (x *Ellipsis) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="Ellipsis.Pos">func (*Ellipsis) <a href="src/pkg/go/ast/ast.htm#L407">Pos</a></h3>
				<pre>func (x *Ellipsis) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="EmptyStmt">type <a href="src/pkg/go/ast/ast.htm#L552">EmptyStmt</a></h2>
			<pre>type EmptyStmt struct {
    Semicolon token.Pos <span class="comment">// position of preceding &#34;;&#34;</span>
}</pre>
			<p>
An EmptyStmt node represents an empty statement.
The &#34;position&#34; of the empty statement is the position
of the immediately preceding semicolon.
</p>


			

			

			

			

			
				
				<h3 id="EmptyStmt.End">func (*EmptyStmt) <a href="src/pkg/go/ast/ast.htm#L721">End</a></h3>
				<pre>func (s *EmptyStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="EmptyStmt.Pos">func (*EmptyStmt) <a href="src/pkg/go/ast/ast.htm#L699">Pos</a></h3>
				<pre>func (s *EmptyStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="Expr">type <a href="src/pkg/go/ast/ast.htm#L31">Expr</a></h2>
			<pre>type Expr interface {
    Node
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
			<p>
All expression nodes implement the Expr interface.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ExprStmt">type <a href="src/pkg/go/ast/ast.htm#L566">ExprStmt</a></h2>
			<pre>type ExprStmt struct {
    X Expr <span class="comment">// expression</span>
}</pre>
			<p>
An ExprStmt node represents a (stand-alone) expression
in a statement list.
</p>


			

			

			

			

			
				
				<h3 id="ExprStmt.End">func (*ExprStmt) <a href="src/pkg/go/ast/ast.htm#L725">End</a></h3>
				<pre>func (s *ExprStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="ExprStmt.Pos">func (*ExprStmt) <a href="src/pkg/go/ast/ast.htm#L701">Pos</a></h3>
				<pre>func (s *ExprStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="Field">type <a href="src/pkg/go/ast/ast.htm#L145">Field</a></h2>
			<pre>type Field struct {
    Doc     *CommentGroup <span class="comment">// associated documentation; or nil</span>
    Names   []*Ident      <span class="comment">// field/method/parameter names; or nil if anonymous field</span>
    Type    Expr          <span class="comment">// field/method/parameter type</span>
    Tag     *BasicLit     <span class="comment">// field tag; or nil</span>
    Comment *CommentGroup <span class="comment">// line comments; or nil</span>
}</pre>
			<p>
A Field represents a Field declaration list in a struct type,
a method list in an interface type, or a parameter/result declaration
in a signature.
</p>


			

			

			

			

			
				
				<h3 id="Field.End">func (*Field) <a href="src/pkg/go/ast/ast.htm#L160">End</a></h3>
				<pre>func (f *Field) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="Field.Pos">func (*Field) <a href="src/pkg/go/ast/ast.htm#L153">Pos</a></h3>
				<pre>func (f *Field) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="FieldFilter">type <a href="src/pkg/go/ast/print.htm#L8">FieldFilter</a></h2>
			<pre>type FieldFilter func(name string, value reflect.Value) bool</pre>
			<p>
A FieldFilter may be provided to Fprint to control the output.
</p>


			

			

			

			

			
		
			
			
			<h2 id="FieldList">type <a href="src/pkg/go/ast/ast.htm#L168">FieldList</a></h2>
			<pre>type FieldList struct {
    Opening token.Pos <span class="comment">// position of opening parenthesis/brace, if any</span>
    List    []*Field  <span class="comment">// field list; or nil</span>
    Closing token.Pos <span class="comment">// position of closing parenthesis/brace, if any</span>
}</pre>
			<p>
A FieldList represents a list of Fields, enclosed by parentheses or braces.
</p>


			

			

			

			

			
				
				<h3 id="FieldList.End">func (*FieldList) <a href="src/pkg/go/ast/ast.htm#L186">End</a></h3>
				<pre>func (f *FieldList) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="FieldList.NumFields">func (*FieldList) <a href="src/pkg/go/ast/ast.htm#L199">NumFields</a></h3>
				<pre>func (f *FieldList) NumFields() int</pre>
				<p>
NumFields returns the number of (named and anonymous fields) in a FieldList.
</p>

				
				
			
				
				<h3 id="FieldList.Pos">func (*FieldList) <a href="src/pkg/go/ast/ast.htm#L174">Pos</a></h3>
				<pre>func (f *FieldList) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="File">type <a href="src/pkg/go/ast/ast.htm#L950">File</a></h2>
			<pre>type File struct {
    Doc        *CommentGroup   <span class="comment">// associated documentation; or nil</span>
    Package    token.Pos       <span class="comment">// position of &#34;package&#34; keyword</span>
    Name       *Ident          <span class="comment">// package name</span>
    Decls      []Decl          <span class="comment">// top-level declarations; or nil</span>
    Scope      *Scope          <span class="comment">// package scope (this file only)</span>
    Imports    []*ImportSpec   <span class="comment">// imports in this file</span>
    Unresolved []*Ident        <span class="comment">// unresolved identifiers in this file</span>
    Comments   []*CommentGroup <span class="comment">// list of all comments in the source file</span>
}</pre>
			<p>
A File node represents a Go source file.
</p>
<p>
The Comments list contains all comments in the source file in order of
appearance, including the comments that are pointed to from other nodes
via Doc and Comment fields.
</p>


			

			

			

			
				
				<h3 id="MergePackageFiles">func <a href="src/pkg/go/ast/filter.htm#L285">MergePackageFiles</a></h3>
				<pre>func MergePackageFiles(pkg *Package, mode MergeMode) *File</pre>
				<p>
MergePackageFiles creates a file AST by merging the ASTs of the
files belonging to a package. The mode flags control merging behavior.
</p>

				
			

			
				
				<h3 id="File.End">func (*File) <a href="src/pkg/go/ast/ast.htm#L962">End</a></h3>
				<pre>func (f *File) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="File.Pos">func (*File) <a href="src/pkg/go/ast/ast.htm#L961">Pos</a></h3>
				<pre>func (f *File) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="Filter">type <a href="src/pkg/go/ast/filter.htm#L37">Filter</a></h2>
			<pre>type Filter func(string) bool</pre>
			

			

			

			

			

			
		
			
			
			<h2 id="ForStmt">type <a href="src/pkg/go/ast/ast.htm#L676">ForStmt</a></h2>
			<pre>type ForStmt struct {
    For  token.Pos <span class="comment">// position of &#34;for&#34; keyword</span>
    Init Stmt      <span class="comment">// initialization statement; or nil</span>
    Cond Expr      <span class="comment">// condition; or nil</span>
    Post Stmt      <span class="comment">// post iteration statement; or nil</span>
    Body *BlockStmt
}</pre>
			<p>
A ForStmt represents a for statement.
</p>


			

			

			

			

			
				
				<h3 id="ForStmt.End">func (*ForStmt) <a href="src/pkg/go/ast/ast.htm#L767">End</a></h3>
				<pre>func (s *ForStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="ForStmt.Pos">func (*ForStmt) <a href="src/pkg/go/ast/ast.htm#L716">Pos</a></h3>
				<pre>func (s *ForStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="FuncDecl">type <a href="src/pkg/go/ast/ast.htm#L905">FuncDecl</a></h2>
			<pre>type FuncDecl struct {
    Doc  *CommentGroup <span class="comment">// associated documentation; or nil</span>
    Recv *FieldList    <span class="comment">// receiver (methods); or nil (functions)</span>
    Name *Ident        <span class="comment">// function/method name</span>
    Type *FuncType     <span class="comment">// position of Func keyword, parameters and results</span>
    Body *BlockStmt    <span class="comment">// function body; or nil (forward declaration)</span>
}</pre>
			<p>
A FuncDecl node represents a function declaration.
</p>


			

			

			

			

			
				
				<h3 id="FuncDecl.End">func (*FuncDecl) <a href="src/pkg/go/ast/ast.htm#L927">End</a></h3>
				<pre>func (d *FuncDecl) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="FuncDecl.Pos">func (*FuncDecl) <a href="src/pkg/go/ast/ast.htm#L918">Pos</a></h3>
				<pre>func (d *FuncDecl) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="FuncLit">type <a href="src/pkg/go/ast/ast.htm#L248">FuncLit</a></h2>
			<pre>type FuncLit struct {
    Type *FuncType  <span class="comment">// function type</span>
    Body *BlockStmt <span class="comment">// function body</span>
}</pre>
			<p>
A FuncLit node represents a function literal.
</p>


			

			

			

			

			
				
				<h3 id="FuncLit.End">func (*FuncLit) <a href="src/pkg/go/ast/ast.htm#L442">End</a></h3>
				<pre>func (x *FuncLit) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="FuncLit.Pos">func (*FuncLit) <a href="src/pkg/go/ast/ast.htm#L409">Pos</a></h3>
				<pre>func (x *FuncLit) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="FuncType">type <a href="src/pkg/go/ast/ast.htm#L375">FuncType</a></h2>
			<pre>type FuncType struct {
    Func    token.Pos  <span class="comment">// position of &#34;func&#34; keyword</span>
    Params  *FieldList <span class="comment">// (incoming) parameters; or nil</span>
    Results *FieldList <span class="comment">// (outgoing) results; or nil</span>
}</pre>
			<p>
A FuncType node represents a function type.
</p>


			

			

			

			

			
				
				<h3 id="FuncType.End">func (*FuncType) <a href="src/pkg/go/ast/ast.htm#L461">End</a></h3>
				<pre>func (x *FuncType) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="FuncType.Pos">func (*FuncType) <a href="src/pkg/go/ast/ast.htm#L428">Pos</a></h3>
				<pre>func (x *FuncType) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="GenDecl">type <a href="src/pkg/go/ast/ast.htm#L895">GenDecl</a></h2>
			<pre>type GenDecl struct {
    Doc    *CommentGroup <span class="comment">// associated documentation; or nil</span>
    TokPos token.Pos     <span class="comment">// position of Tok</span>
    Tok    token.Token   <span class="comment">// IMPORT, CONST, TYPE, VAR</span>
    Lparen token.Pos     <span class="comment">// position of &#39;(&#39;, if any</span>
    Specs  []Spec
    Rparen token.Pos <span class="comment">// position of &#39;)&#39;, if any</span>
}</pre>
			<p>
A GenDecl node (generic declaration node) represents an import,
constant, type or variable declaration. A valid Lparen position
(Lparen.Line &gt; 0) indicates a parenthesized declaration.
</p>
<p>
Relationship between Tok value and Specs element type:
</p>
<pre>token.IMPORT  *ImportSpec
token.CONST   *ValueSpec
token.TYPE    *TypeSpec
token.VAR     *ValueSpec
</pre>


			

			

			

			

			
				
				<h3 id="GenDecl.End">func (*GenDecl) <a href="src/pkg/go/ast/ast.htm#L921">End</a></h3>
				<pre>func (d *GenDecl) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="GenDecl.Pos">func (*GenDecl) <a href="src/pkg/go/ast/ast.htm#L917">Pos</a></h3>
				<pre>func (d *GenDecl) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="GoStmt">type <a href="src/pkg/go/ast/ast.htm#L595">GoStmt</a></h2>
			<pre>type GoStmt struct {
    Go   token.Pos <span class="comment">// position of &#34;go&#34; keyword</span>
    Call *CallExpr
}</pre>
			<p>
A GoStmt node represents a go statement.
</p>


			

			

			

			

			
				
				<h3 id="GoStmt.End">func (*GoStmt) <a href="src/pkg/go/ast/ast.htm#L731">End</a></h3>
				<pre>func (s *GoStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="GoStmt.Pos">func (*GoStmt) <a href="src/pkg/go/ast/ast.htm#L705">Pos</a></h3>
				<pre>func (s *GoStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="Ident">type <a href="src/pkg/go/ast/ast.htm#L226">Ident</a></h2>
			<pre>type Ident struct {
    NamePos token.Pos <span class="comment">// identifier position</span>
    Name    string    <span class="comment">// identifier name</span>
    Obj     *Object   <span class="comment">// denoted object; or nil</span>
}</pre>
			<p>
An Ident node represents an identifier.
</p>


			

			

			

			
				
				<h3 id="NewIdent">func <a href="src/pkg/go/ast/ast.htm#L506">NewIdent</a></h3>
				<pre>func NewIdent(name string) *Ident</pre>
				<p>
NewIdent creates a new Ident without position.
Useful for ASTs generated by code other than the Go parser.
</p>

				
			

			
				
				<h3 id="Ident.End">func (*Ident) <a href="src/pkg/go/ast/ast.htm#L434">End</a></h3>
				<pre>func (x *Ident) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="Ident.IsExported">func (*Ident) <a href="src/pkg/go/ast/ast.htm#L519">IsExported</a></h3>
				<pre>func (id *Ident) IsExported() bool</pre>
				<p>
IsExported returns whether id is an exported Go symbol
(i.e., whether it begins with an uppercase letter).
</p>

				
				
			
				
				<h3 id="Ident.Pos">func (*Ident) <a href="src/pkg/go/ast/ast.htm#L406">Pos</a></h3>
				<pre>func (x *Ident) Pos() token.Pos</pre>
				
				
				
			
				
				<h3 id="Ident.String">func (*Ident) <a href="src/pkg/go/ast/ast.htm#L521">String</a></h3>
				<pre>func (id *Ident) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="IfStmt">type <a href="src/pkg/go/ast/ast.htm#L629">IfStmt</a></h2>
			<pre>type IfStmt struct {
    If   token.Pos <span class="comment">// position of &#34;if&#34; keyword</span>
    Init Stmt      <span class="comment">// initialization statement; or nil</span>
    Cond Expr      <span class="comment">// condition</span>
    Body *BlockStmt
    Else Stmt <span class="comment">// else branch; or nil</span>
}</pre>
			<p>
An IfStmt node represents an if statement.
</p>


			

			

			

			

			
				
				<h3 id="IfStmt.End">func (*IfStmt) <a href="src/pkg/go/ast/ast.htm#L746">End</a></h3>
				<pre>func (s *IfStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="IfStmt.Pos">func (*IfStmt) <a href="src/pkg/go/ast/ast.htm#L710">Pos</a></h3>
				<pre>func (s *IfStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="ImportSpec">type <a href="src/pkg/go/ast/ast.htm#L809">ImportSpec</a></h2>
			<pre>type ImportSpec struct {
    Doc     *CommentGroup <span class="comment">// associated documentation; or nil</span>
    Name    *Ident        <span class="comment">// local package name (including &#34;.&#34;); or nil</span>
    Path    *BasicLit     <span class="comment">// import path</span>
    Comment *CommentGroup <span class="comment">// line comments; or nil</span>
    EndPos  token.Pos     <span class="comment">// end of spec (overrides Path.Pos if nonzero)</span>
}</pre>
			<p>
An ImportSpec node represents a single package import.
</p>


			

			

			

			

			
				
				<h3 id="ImportSpec.End">func (*ImportSpec) <a href="src/pkg/go/ast/ast.htm#L848">End</a></h3>
				<pre>func (s *ImportSpec) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="ImportSpec.Pos">func (*ImportSpec) <a href="src/pkg/go/ast/ast.htm#L839">Pos</a></h3>
				<pre>func (s *ImportSpec) Pos() token.Pos</pre>
				<p>
Pos and End implementations for spec nodes.
</p>

				
				
			
		
			
			
			<h2 id="Importer">type <a href="src/pkg/go/ast/resolve.htm#L53">Importer</a></h2>
			<pre>type Importer func(imports map[string]*Object, path string) (pkg *Object, err error)</pre>
			<p>
An Importer resolves import paths to package Objects.
The imports map records the packages already imported,
indexed by package id (canonical import path).
An Importer must determine the canonical import path and
check the map to see if it is already present in the imports map.
If so, the Importer can return the map entry.  Otherwise, the
Importer should load the package data for the given path into
a new *Object (pkg), record pkg in the imports map, and then
return pkg.
</p>


			

			

			

			

			
		
			
			
			<h2 id="IncDecStmt">type <a href="src/pkg/go/ast/ast.htm#L578">IncDecStmt</a></h2>
			<pre>type IncDecStmt struct {
    X      Expr
    TokPos token.Pos   <span class="comment">// position of Tok</span>
    Tok    token.Token <span class="comment">// INC or DEC</span>
}</pre>
			<p>
An IncDecStmt node represents an increment or decrement statement.
</p>


			

			

			

			

			
				
				<h3 id="IncDecStmt.End">func (*IncDecStmt) <a href="src/pkg/go/ast/ast.htm#L727">End</a></h3>
				<pre>func (s *IncDecStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="IncDecStmt.Pos">func (*IncDecStmt) <a href="src/pkg/go/ast/ast.htm#L703">Pos</a></h3>
				<pre>func (s *IncDecStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="IndexExpr">type <a href="src/pkg/go/ast/ast.htm#L275">IndexExpr</a></h2>
			<pre>type IndexExpr struct {
    X      Expr      <span class="comment">// expression</span>
    Lbrack token.Pos <span class="comment">// position of &#34;[&#34;</span>
    Index  Expr      <span class="comment">// index expression</span>
    Rbrack token.Pos <span class="comment">// position of &#34;]&#34;</span>
}</pre>
			<p>
An IndexExpr node represents an expression followed by an index.
</p>


			

			

			

			

			
				
				<h3 id="IndexExpr.End">func (*IndexExpr) <a href="src/pkg/go/ast/ast.htm#L446">End</a></h3>
				<pre>func (x *IndexExpr) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="IndexExpr.Pos">func (*IndexExpr) <a href="src/pkg/go/ast/ast.htm#L418">Pos</a></h3>
				<pre>func (x *IndexExpr) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="InterfaceType">type <a href="src/pkg/go/ast/ast.htm#L382">InterfaceType</a></h2>
			<pre>type InterfaceType struct {
    Interface  token.Pos  <span class="comment">// position of &#34;interface&#34; keyword</span>
    Methods    *FieldList <span class="comment">// list of methods</span>
    Incomplete bool       <span class="comment">// true if (source) methods are missing in the Methods list</span>
}</pre>
			<p>
An InterfaceType node represents an interface type.
</p>


			

			

			

			

			
				
				<h3 id="InterfaceType.End">func (*InterfaceType) <a href="src/pkg/go/ast/ast.htm#L467">End</a></h3>
				<pre>func (x *InterfaceType) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="InterfaceType.Pos">func (*InterfaceType) <a href="src/pkg/go/ast/ast.htm#L429">Pos</a></h3>
				<pre>func (x *InterfaceType) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="KeyValueExpr">type <a href="src/pkg/go/ast/ast.htm#L336">KeyValueExpr</a></h2>
			<pre>type KeyValueExpr struct {
    Key   Expr
    Colon token.Pos <span class="comment">// position of &#34;:&#34;</span>
    Value Expr
}</pre>
			<p>
A KeyValueExpr node represents (key : value) pairs
in composite literals.
</p>


			

			

			

			

			
				
				<h3 id="KeyValueExpr.End">func (*KeyValueExpr) <a href="src/pkg/go/ast/ast.htm#L458">End</a></h3>
				<pre>func (x *KeyValueExpr) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="KeyValueExpr.Pos">func (*KeyValueExpr) <a href="src/pkg/go/ast/ast.htm#L425">Pos</a></h3>
				<pre>func (x *KeyValueExpr) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="LabeledStmt">type <a href="src/pkg/go/ast/ast.htm#L557">LabeledStmt</a></h2>
			<pre>type LabeledStmt struct {
    Label *Ident
    Colon token.Pos <span class="comment">// position of &#34;:&#34;</span>
    Stmt  Stmt
}</pre>
			<p>
A LabeledStmt node represents a labeled statement.
</p>


			

			

			

			

			
				
				<h3 id="LabeledStmt.End">func (*LabeledStmt) <a href="src/pkg/go/ast/ast.htm#L724">End</a></h3>
				<pre>func (s *LabeledStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="LabeledStmt.Pos">func (*LabeledStmt) <a href="src/pkg/go/ast/ast.htm#L700">Pos</a></h3>
				<pre>func (s *LabeledStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="MapType">type <a href="src/pkg/go/ast/ast.htm#L389">MapType</a></h2>
			<pre>type MapType struct {
    Map   token.Pos <span class="comment">// position of &#34;map&#34; keyword</span>
    Key   Expr
    Value Expr
}</pre>
			<p>
A MapType node represents a map type.
</p>


			

			

			

			

			
				
				<h3 id="MapType.End">func (*MapType) <a href="src/pkg/go/ast/ast.htm#L468">End</a></h3>
				<pre>func (x *MapType) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="MapType.Pos">func (*MapType) <a href="src/pkg/go/ast/ast.htm#L430">Pos</a></h3>
				<pre>func (x *MapType) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="MergeMode">type <a href="src/pkg/go/ast/filter.htm#L265">MergeMode</a></h2>
			<pre>type MergeMode uint</pre>
			<p>
The MergeMode flags control the behavior of MergePackageFiles.
</p>


			
				<pre>const (
    <span class="comment">// If set, duplicate function declarations are excluded.</span>
    FilterFuncDuplicates MergeMode = 1 &lt;&lt; iota
    <span class="comment">// If set, comments that are not associated with a specific</span>
    <span class="comment">// AST node (as Doc or Comment) are excluded.</span>
    FilterUnassociatedComments
    <span class="comment">// If set, duplicate import declarations are excluded.</span>
    FilterImportDuplicates
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="Node">type <a href="src/pkg/go/ast/ast.htm#L25">Node</a></h2>
			<pre>type Node interface {
    Pos() token.Pos <span class="comment">// position of first character belonging to the node</span>
    End() token.Pos <span class="comment">// position of first character immediately after the node</span>
}</pre>
			<p>
All node types implement the Node interface.
</p>


			

			

			

			

			
		
			
			
			<h2 id="ObjKind">type <a href="src/pkg/go/ast/scope.htm#L131">ObjKind</a></h2>
			<pre>type ObjKind int</pre>
			<p>
ObKind describes what an object represents.
</p>


			
				<pre>const (
    Bad ObjKind = iota <span class="comment">// for error handling</span>
    Pkg                <span class="comment">// package</span>
    Con                <span class="comment">// constant</span>
    Typ                <span class="comment">// type</span>
    Var                <span class="comment">// variable</span>
    Fun                <span class="comment">// function or method</span>
    Lbl                <span class="comment">// label</span>
)</pre>
				<p>
The list of possible Object kinds.
</p>

			

			

			

			

			
				
				<h3 id="ObjKind.String">func (ObjKind) <a href="src/pkg/go/ast/scope.htm#L154">String</a></h3>
				<pre>func (kind ObjKind) String() string</pre>
				
				
				
			
		
			
			
			<h2 id="Object">type <a href="src/pkg/go/ast/scope.htm#L70">Object</a></h2>
			<pre>type Object struct {
    Kind ObjKind
    Name string      <span class="comment">// declared name</span>
    Decl interface{} <span class="comment">// corresponding Field, XxxSpec, FuncDecl, LabeledStmt, AssignStmt, Scope; or nil</span>
    Data interface{} <span class="comment">// object-specific data; or nil</span>
    Type interface{} <span class="comment">// place holder for type information; may be nil</span>
}</pre>
			<p>
An Object describes a named language entity such as a package,
constant, type, variable, function (incl. methods), or label.
</p>
<p>
The Data fields contains object-specific data:
</p>
<pre>Kind    Data type    Data value
Pkg	*Scope       package scope
Con     int          iota for the respective declaration
Con     != nil       constant value
</pre>


			

			

			

			
				
				<h3 id="NewObj">func <a href="src/pkg/go/ast/scope.htm#L79">NewObj</a></h3>
				<pre>func NewObj(kind ObjKind, name string) *Object</pre>
				<p>
NewObj creates a new object of a given kind and name.
</p>

				
			

			
				
				<h3 id="Object.Pos">func (*Object) <a href="src/pkg/go/ast/scope.htm#L86">Pos</a></h3>
				<pre>func (obj *Object) Pos() token.Pos</pre>
				<p>
Pos computes the source position of the declaration of an object name.
The result may be an invalid position if it cannot be computed
(obj.Decl may be nil or not correct).
</p>

				
				
			
		
			
			
			<h2 id="Package">type <a href="src/pkg/go/ast/ast.htm#L972">Package</a></h2>
			<pre>type Package struct {
    Name    string             <span class="comment">// package name</span>
    Scope   *Scope             <span class="comment">// package scope across all files</span>
    Imports map[string]*Object <span class="comment">// map of package id -&gt; package object</span>
    Files   map[string]*File   <span class="comment">// Go source files by filename</span>
}</pre>
			<p>
A Package node represents a set of source files
collectively building a Go package.
</p>


			

			

			

			
				
				<h3 id="NewPackage">func <a href="src/pkg/go/ast/resolve.htm#L64">NewPackage</a></h3>
				<pre>func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, error)</pre>
				<p>
NewPackage creates a new Package node from a set of File nodes. It resolves
unresolved identifiers across files and updates each file&#39;s Unresolved list
accordingly. If a non-nil importer and universe scope are provided, they are
used to resolve identifiers not declared in any of the package files. Any
remaining unresolved identifiers are reported as undeclared. If the files
belong to different packages, one package name is selected and files with
different package names are reported and then ignored.
The result is a package node and a scanner.ErrorList if there were errors.
</p>

				
			

			
				
				<h3 id="Package.End">func (*Package) <a href="src/pkg/go/ast/ast.htm#L980">End</a></h3>
				<pre>func (p *Package) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="Package.Pos">func (*Package) <a href="src/pkg/go/ast/ast.htm#L979">Pos</a></h3>
				<pre>func (p *Package) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="ParenExpr">type <a href="src/pkg/go/ast/ast.htm#L262">ParenExpr</a></h2>
			<pre>type ParenExpr struct {
    Lparen token.Pos <span class="comment">// position of &#34;(&#34;</span>
    X      Expr      <span class="comment">// parenthesized expression</span>
    Rparen token.Pos <span class="comment">// position of &#34;)&#34;</span>
}</pre>
			<p>
A ParenExpr node represents a parenthesized expression.
</p>


			

			

			

			

			
				
				<h3 id="ParenExpr.End">func (*ParenExpr) <a href="src/pkg/go/ast/ast.htm#L444">End</a></h3>
				<pre>func (x *ParenExpr) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="ParenExpr.Pos">func (*ParenExpr) <a href="src/pkg/go/ast/ast.htm#L416">Pos</a></h3>
				<pre>func (x *ParenExpr) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="RangeStmt">type <a href="src/pkg/go/ast/ast.htm#L685">RangeStmt</a></h2>
			<pre>type RangeStmt struct {
    For        token.Pos   <span class="comment">// position of &#34;for&#34; keyword</span>
    Key, Value Expr        <span class="comment">// Value may be nil</span>
    TokPos     token.Pos   <span class="comment">// position of Tok</span>
    Tok        token.Token <span class="comment">// ASSIGN, DEFINE</span>
    X          Expr        <span class="comment">// value to range over</span>
    Body       *BlockStmt
}</pre>
			<p>
A RangeStmt represents a for statement with a range clause.
</p>


			

			

			

			

			
				
				<h3 id="RangeStmt.End">func (*RangeStmt) <a href="src/pkg/go/ast/ast.htm#L768">End</a></h3>
				<pre>func (s *RangeStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="RangeStmt.Pos">func (*RangeStmt) <a href="src/pkg/go/ast/ast.htm#L717">Pos</a></h3>
				<pre>func (s *RangeStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="ReturnStmt">type <a href="src/pkg/go/ast/ast.htm#L607">ReturnStmt</a></h2>
			<pre>type ReturnStmt struct {
    Return  token.Pos <span class="comment">// position of &#34;return&#34; keyword</span>
    Results []Expr    <span class="comment">// result expressions; or nil</span>
}</pre>
			<p>
A ReturnStmt node represents a return statement.
</p>


			

			

			

			

			
				
				<h3 id="ReturnStmt.End">func (*ReturnStmt) <a href="src/pkg/go/ast/ast.htm#L733">End</a></h3>
				<pre>func (s *ReturnStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="ReturnStmt.Pos">func (*ReturnStmt) <a href="src/pkg/go/ast/ast.htm#L707">Pos</a></h3>
				<pre>func (s *ReturnStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="Scope">type <a href="src/pkg/go/ast/scope.htm#L9">Scope</a></h2>
			<pre>type Scope struct {
    Outer   *Scope
    Objects map[string]*Object
}</pre>
			<p>
A Scope maintains the set of named language entities declared
in the scope and a link to the immediately surrounding (outer)
scope.
</p>


			

			

			

			
				
				<h3 id="NewScope">func <a href="src/pkg/go/ast/scope.htm#L15">NewScope</a></h3>
				<pre>func NewScope(outer *Scope) *Scope</pre>
				<p>
NewScope creates a new scope nested in the outer scope.
</p>

				
			

			
				
				<h3 id="Scope.Insert">func (*Scope) <a href="src/pkg/go/ast/scope.htm#L33">Insert</a></h3>
				<pre>func (s *Scope) Insert(obj *Object) (alt *Object)</pre>
				<p>
Insert attempts to insert a named object obj into the scope s.
If the scope already contains an object alt with the same name,
Insert leaves the scope unchanged and returns alt. Otherwise
it inserts obj and returns nil.&#34;
</p>

				
				
			
				
				<h3 id="Scope.Lookup">func (*Scope) <a href="src/pkg/go/ast/scope.htm#L24">Lookup</a></h3>
				<pre>func (s *Scope) Lookup(name string) *Object</pre>
				<p>
Lookup returns the object with the given name if it is
found in scope s, otherwise it returns nil. Outer scopes
are ignored.
</p>

				
				
			
				
				<h3 id="Scope.String">func (*Scope) <a href="src/pkg/go/ast/scope.htm#L41">String</a></h3>
				<pre>func (s *Scope) String() string</pre>
				<p>
Debugging support
</p>

				
				
			
		
			
			
			<h2 id="SelectStmt">type <a href="src/pkg/go/ast/ast.htm#L670">SelectStmt</a></h2>
			<pre>type SelectStmt struct {
    Select token.Pos  <span class="comment">// position of &#34;select&#34; keyword</span>
    Body   *BlockStmt <span class="comment">// CommClauses only</span>
}</pre>
			<p>
An SelectStmt node represents a select statement.
</p>


			

			

			

			

			
				
				<h3 id="SelectStmt.End">func (*SelectStmt) <a href="src/pkg/go/ast/ast.htm#L766">End</a></h3>
				<pre>func (s *SelectStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="SelectStmt.Pos">func (*SelectStmt) <a href="src/pkg/go/ast/ast.htm#L715">Pos</a></h3>
				<pre>func (s *SelectStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="SelectorExpr">type <a href="src/pkg/go/ast/ast.htm#L269">SelectorExpr</a></h2>
			<pre>type SelectorExpr struct {
    X   Expr   <span class="comment">// expression</span>
    Sel *Ident <span class="comment">// field selector</span>
}</pre>
			<p>
A SelectorExpr node represents an expression followed by a selector.
</p>


			

			

			

			

			
				
				<h3 id="SelectorExpr.End">func (*SelectorExpr) <a href="src/pkg/go/ast/ast.htm#L445">End</a></h3>
				<pre>func (x *SelectorExpr) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="SelectorExpr.Pos">func (*SelectorExpr) <a href="src/pkg/go/ast/ast.htm#L417">Pos</a></h3>
				<pre>func (x *SelectorExpr) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="SendStmt">type <a href="src/pkg/go/ast/ast.htm#L571">SendStmt</a></h2>
			<pre>type SendStmt struct {
    Chan  Expr
    Arrow token.Pos <span class="comment">// position of &#34;&lt;-&#34;</span>
    Value Expr
}</pre>
			<p>
A SendStmt node represents a send statement.
</p>


			

			

			

			

			
				
				<h3 id="SendStmt.End">func (*SendStmt) <a href="src/pkg/go/ast/ast.htm#L726">End</a></h3>
				<pre>func (s *SendStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="SendStmt.Pos">func (*SendStmt) <a href="src/pkg/go/ast/ast.htm#L702">Pos</a></h3>
				<pre>func (s *SendStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="SliceExpr">type <a href="src/pkg/go/ast/ast.htm#L283">SliceExpr</a></h2>
			<pre>type SliceExpr struct {
    X      Expr      <span class="comment">// expression</span>
    Lbrack token.Pos <span class="comment">// position of &#34;[&#34;</span>
    Low    Expr      <span class="comment">// begin of slice range; or nil</span>
    High   Expr      <span class="comment">// end of slice range; or nil</span>
    Rbrack token.Pos <span class="comment">// position of &#34;]&#34;</span>
}</pre>
			<p>
An SliceExpr node represents an expression followed by slice indices.
</p>


			

			

			

			

			
				
				<h3 id="SliceExpr.End">func (*SliceExpr) <a href="src/pkg/go/ast/ast.htm#L447">End</a></h3>
				<pre>func (x *SliceExpr) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="SliceExpr.Pos">func (*SliceExpr) <a href="src/pkg/go/ast/ast.htm#L419">Pos</a></h3>
				<pre>func (x *SliceExpr) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="Spec">type <a href="src/pkg/go/ast/ast.htm#L803">Spec</a></h2>
			<pre>type Spec interface {
    Node
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
			<p>
The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.
</p>


			

			

			

			

			
		
			
			
			<h2 id="StarExpr">type <a href="src/pkg/go/ast/ast.htm#L311">StarExpr</a></h2>
			<pre>type StarExpr struct {
    Star token.Pos <span class="comment">// position of &#34;*&#34;</span>
    X    Expr      <span class="comment">// operand</span>
}</pre>
			<p>
A StarExpr node represents an expression of the form &#34;*&#34; Expression.
Semantically it could be a unary &#34;*&#34; expression, or a pointer type.
</p>


			

			

			

			

			
				
				<h3 id="StarExpr.End">func (*StarExpr) <a href="src/pkg/go/ast/ast.htm#L455">End</a></h3>
				<pre>func (x *StarExpr) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="StarExpr.Pos">func (*StarExpr) <a href="src/pkg/go/ast/ast.htm#L422">Pos</a></h3>
				<pre>func (x *StarExpr) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="Stmt">type <a href="src/pkg/go/ast/ast.htm#L37">Stmt</a></h2>
			<pre>type Stmt interface {
    Node
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>
			<p>
All statement nodes implement the Stmt interface.
</p>


			

			

			

			

			
		
			
			
			<h2 id="StructType">type <a href="src/pkg/go/ast/ast.htm#L366">StructType</a></h2>
			<pre>type StructType struct {
    Struct     token.Pos  <span class="comment">// position of &#34;struct&#34; keyword</span>
    Fields     *FieldList <span class="comment">// list of field declarations</span>
    Incomplete bool       <span class="comment">// true if (source) fields are missing in the Fields list</span>
}</pre>
			<p>
A StructType node represents a struct type.
</p>


			

			

			

			

			
				
				<h3 id="StructType.End">func (*StructType) <a href="src/pkg/go/ast/ast.htm#L460">End</a></h3>
				<pre>func (x *StructType) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="StructType.Pos">func (*StructType) <a href="src/pkg/go/ast/ast.htm#L427">Pos</a></h3>
				<pre>func (x *StructType) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="SwitchStmt">type <a href="src/pkg/go/ast/ast.htm#L646">SwitchStmt</a></h2>
			<pre>type SwitchStmt struct {
    Switch token.Pos  <span class="comment">// position of &#34;switch&#34; keyword</span>
    Init   Stmt       <span class="comment">// initialization statement; or nil</span>
    Tag    Expr       <span class="comment">// tag expression; or nil</span>
    Body   *BlockStmt <span class="comment">// CaseClauses only</span>
}</pre>
			<p>
A SwitchStmt node represents an expression switch statement.
</p>


			

			

			

			

			
				
				<h3 id="SwitchStmt.End">func (*SwitchStmt) <a href="src/pkg/go/ast/ast.htm#L758">End</a></h3>
				<pre>func (s *SwitchStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="SwitchStmt.Pos">func (*SwitchStmt) <a href="src/pkg/go/ast/ast.htm#L712">Pos</a></h3>
				<pre>func (s *SwitchStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="TypeAssertExpr">type <a href="src/pkg/go/ast/ast.htm#L294">TypeAssertExpr</a></h2>
			<pre>type TypeAssertExpr struct {
    X    Expr <span class="comment">// expression</span>
    Type Expr <span class="comment">// asserted type; nil means type switch X.(type)</span>
}</pre>
			<p>
A TypeAssertExpr node represents an expression followed by a
type assertion.
</p>


			

			

			

			

			
				
				<h3 id="TypeAssertExpr.End">func (*TypeAssertExpr) <a href="src/pkg/go/ast/ast.htm#L448">End</a></h3>
				<pre>func (x *TypeAssertExpr) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="TypeAssertExpr.Pos">func (*TypeAssertExpr) <a href="src/pkg/go/ast/ast.htm#L420">Pos</a></h3>
				<pre>func (x *TypeAssertExpr) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="TypeSpec">type <a href="src/pkg/go/ast/ast.htm#L829">TypeSpec</a></h2>
			<pre>type TypeSpec struct {
    Doc     *CommentGroup <span class="comment">// associated documentation; or nil</span>
    Name    *Ident        <span class="comment">// type name</span>
    Type    Expr          <span class="comment">// *Ident, *ParenExpr, *SelectorExpr, *StarExpr, or any of the *XxxTypes</span>
    Comment *CommentGroup <span class="comment">// line comments; or nil</span>
}</pre>
			<p>
A TypeSpec node represents a type declaration (TypeSpec production).
</p>


			

			

			

			

			
				
				<h3 id="TypeSpec.End">func (*TypeSpec) <a href="src/pkg/go/ast/ast.htm#L864">End</a></h3>
				<pre>func (s *TypeSpec) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="TypeSpec.Pos">func (*TypeSpec) <a href="src/pkg/go/ast/ast.htm#L846">Pos</a></h3>
				<pre>func (s *TypeSpec) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="TypeSwitchStmt">type <a href="src/pkg/go/ast/ast.htm#L654">TypeSwitchStmt</a></h2>
			<pre>type TypeSwitchStmt struct {
    Switch token.Pos  <span class="comment">// position of &#34;switch&#34; keyword</span>
    Init   Stmt       <span class="comment">// initialization statement; or nil</span>
    Assign Stmt       <span class="comment">// x := y.(type) or y.(type)</span>
    Body   *BlockStmt <span class="comment">// CaseClauses only</span>
}</pre>
			<p>
An TypeSwitchStmt node represents a type switch statement.
</p>


			

			

			

			

			
				
				<h3 id="TypeSwitchStmt.End">func (*TypeSwitchStmt) <a href="src/pkg/go/ast/ast.htm#L759">End</a></h3>
				<pre>func (s *TypeSwitchStmt) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="TypeSwitchStmt.Pos">func (*TypeSwitchStmt) <a href="src/pkg/go/ast/ast.htm#L713">Pos</a></h3>
				<pre>func (s *TypeSwitchStmt) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="UnaryExpr">type <a href="src/pkg/go/ast/ast.htm#L319">UnaryExpr</a></h2>
			<pre>type UnaryExpr struct {
    OpPos token.Pos   <span class="comment">// position of Op</span>
    Op    token.Token <span class="comment">// operator</span>
    X     Expr        <span class="comment">// operand</span>
}</pre>
			<p>
A UnaryExpr node represents a unary expression.
Unary &#34;*&#34; expressions are represented via StarExpr nodes.
</p>


			

			

			

			

			
				
				<h3 id="UnaryExpr.End">func (*UnaryExpr) <a href="src/pkg/go/ast/ast.htm#L456">End</a></h3>
				<pre>func (x *UnaryExpr) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="UnaryExpr.Pos">func (*UnaryExpr) <a href="src/pkg/go/ast/ast.htm#L423">Pos</a></h3>
				<pre>func (x *UnaryExpr) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="ValueSpec">type <a href="src/pkg/go/ast/ast.htm#L820">ValueSpec</a></h2>
			<pre>type ValueSpec struct {
    Doc     *CommentGroup <span class="comment">// associated documentation; or nil</span>
    Names   []*Ident      <span class="comment">// value names (len(Names) &gt; 0)</span>
    Type    Expr          <span class="comment">// value type; or nil</span>
    Values  []Expr        <span class="comment">// initial values; or nil</span>
    Comment *CommentGroup <span class="comment">// line comments; or nil</span>
}</pre>
			<p>
A ValueSpec node represents a constant or variable declaration
(ConstSpec or VarSpec production).
</p>


			

			

			

			

			
				
				<h3 id="ValueSpec.End">func (*ValueSpec) <a href="src/pkg/go/ast/ast.htm#L855">End</a></h3>
				<pre>func (s *ValueSpec) End() token.Pos</pre>
				
				
				
			
				
				<h3 id="ValueSpec.Pos">func (*ValueSpec) <a href="src/pkg/go/ast/ast.htm#L845">Pos</a></h3>
				<pre>func (s *ValueSpec) Pos() token.Pos</pre>
				
				
				
			
		
			
			
			<h2 id="Visitor">type <a href="src/pkg/go/ast/walk.htm#L2">Visitor</a></h2>
			<pre>type Visitor interface {
    Visit(node Node) (w Visitor)
}</pre>
			<p>
A Visitor&#39;s Visit method is invoked for each node encountered by Walk.
If the result visitor w is not nil, Walk visits each of the children
of node with the visitor w, followed by a call of w.Visit(nil).
</p>


			

			

			

			

			
		
		</div>
	

	









</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
