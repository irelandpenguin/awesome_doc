
<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

  <title>x509 - The Go Programming Language</title>

<link type="text/css" rel="stylesheet" href="../../doc/style.css">
<script type="text/javascript" src="../../doc/godocs.js"></script>

<link rel="search" type="application/opensearchdescription+xml" title="godoc" href="/opensearch.xml" />

<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(["_setAccount", "UA-11222381-2"]);
_gaq.push(["_trackPageview"]);
</script>
</head>
<body>

<div id="page" class="wide">


  <div id="plusone"><g:plusone size="small" annotation="none"></g:plusone></div>
  <h1>Package x509</h1>




<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->

	
		<div id="short-nav">
			<dl>
			<dd><code>import "crypto/x509"</code></dd>
			</dl>
			<dl>
			<dd><a href="#overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#index">Index</a></dd>
			
			
				<dd><a href="#subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ?</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ?</h2>
				<p>
Package x509 parses X.509-encoded keys and certificates.
</p>

			</div>
		</div>
		
	
		<h2 id="index">Index</h2>
		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
		<div id="manual-nav">
			<dl>
			
			
				<dd><a href="#variables">Variables</a></dd>
			
			
				
				<dd><a href="#CreateCertificate">func CreateCertificate(rand io.Reader, template, parent *Certificate, pub interface{}, priv interface{}) (cert []byte, err error)</a></dd>
			
				
				<dd><a href="#MarshalPKCS1PrivateKey">func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte</a></dd>
			
				
				<dd><a href="#MarshalPKIXPublicKey">func MarshalPKIXPublicKey(pub interface{}) ([]byte, error)</a></dd>
			
				
				<dd><a href="#ParseCRL">func ParseCRL(crlBytes []byte) (certList *pkix.CertificateList, err error)</a></dd>
			
				
				<dd><a href="#ParseCertificates">func ParseCertificates(asn1Data []byte) ([]*Certificate, error)</a></dd>
			
				
				<dd><a href="#ParseDERCRL">func ParseDERCRL(derBytes []byte) (certList *pkix.CertificateList, err error)</a></dd>
			
				
				<dd><a href="#ParsePKCS1PrivateKey">func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err error)</a></dd>
			
				
				<dd><a href="#ParsePKCS8PrivateKey">func ParsePKCS8PrivateKey(der []byte) (key interface{}, err error)</a></dd>
			
				
				<dd><a href="#ParsePKIXPublicKey">func ParsePKIXPublicKey(derBytes []byte) (pub interface{}, err error)</a></dd>
			
			
				
				<dd><a href="#CertPool">type CertPool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCertPool">func NewCertPool() *CertPool</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CertPool.AddCert">func (s *CertPool) AddCert(cert *Certificate)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CertPool.AppendCertsFromPEM">func (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CertPool.Subjects">func (s *CertPool) Subjects() (res [][]byte)</a></dd>
				
			
				
				<dd><a href="#Certificate">type Certificate</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseCertificate">func ParseCertificate(asn1Data []byte) (*Certificate, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Certificate.CheckCRLSignature">func (c *Certificate) CheckCRLSignature(crl *pkix.CertificateList) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Certificate.CheckSignature">func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature []byte) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Certificate.CheckSignatureFrom">func (c *Certificate) CheckSignatureFrom(parent *Certificate) (err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Certificate.CreateCRL">func (c *Certificate) CreateCRL(rand io.Reader, priv interface{}, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Certificate.Equal">func (c *Certificate) Equal(other *Certificate) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Certificate.Verify">func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Certificate.VerifyHostname">func (c *Certificate) VerifyHostname(h string) error</a></dd>
				
			
				
				<dd><a href="#CertificateInvalidError">type CertificateInvalidError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CertificateInvalidError.Error">func (e CertificateInvalidError) Error() string</a></dd>
				
			
				
				<dd><a href="#ConstraintViolationError">type ConstraintViolationError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ConstraintViolationError.Error">func (ConstraintViolationError) Error() string</a></dd>
				
			
				
				<dd><a href="#ExtKeyUsage">type ExtKeyUsage</a></dd>
				
				
			
				
				<dd><a href="#HostnameError">type HostnameError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#HostnameError.Error">func (h HostnameError) Error() string</a></dd>
				
			
				
				<dd><a href="#InvalidReason">type InvalidReason</a></dd>
				
				
			
				
				<dd><a href="#KeyUsage">type KeyUsage</a></dd>
				
				
			
				
				<dd><a href="#PublicKeyAlgorithm">type PublicKeyAlgorithm</a></dd>
				
				
			
				
				<dd><a href="#SignatureAlgorithm">type SignatureAlgorithm</a></dd>
				
				
			
				
				<dd><a href="#UnhandledCriticalExtension">type UnhandledCriticalExtension</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnhandledCriticalExtension.Error">func (h UnhandledCriticalExtension) Error() string</a></dd>
				
			
				
				<dd><a href="#UnknownAuthorityError">type UnknownAuthorityError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnknownAuthorityError.Error">func (e UnknownAuthorityError) Error() string</a></dd>
				
			
				
				<dd><a href="#VerifyOptions">type VerifyOptions</a></dd>
				
				
			
			
		</dl>

		

		
			<h4>Package files</h4>
			<p>
			<span style="font-size:90%">
			
				<a href="src/pkg/crypto/x509/cert_pool.htm">cert_pool.go</a>
			
				<a href="src/pkg/crypto/x509/pkcs1.htm">pkcs1.go</a>
			
				<a href="src/pkg/crypto/x509/pkcs8.htm">pkcs8.go</a>
			
				<a href="src/pkg/crypto/x509/root.htm">root.go</a>
			
				<a href="src/pkg/crypto/x509/root_unix.htm">root_unix.go</a>
			
				<a href="src/pkg/crypto/x509/verify.htm">verify.go</a>
			
				<a href="src/pkg/crypto/x509/x509.htm">x509.go</a>
			
			</span>
			</p>
		
	
		
		
			<h2 id="variables">Variables</h2>
			
				<pre>var ErrUnsupportedAlgorithm = errors.New(&#34;crypto/x509: cannot verify signature: algorithm unimplemented&#34;)</pre>
				<p>
ErrUnsupportedAlgorithm results from attempting to perform an operation that
involves algorithms that are not currently implemented.
</p>

			
		
		
			
			
			<h2 id="CreateCertificate">func <a href="src/pkg/crypto/x509/x509.htm#L909">CreateCertificate</a></h2>
			<pre>func CreateCertificate(rand io.Reader, template, parent *Certificate, pub interface{}, priv interface{}) (cert []byte, err error)</pre>
			<p>
CreateCertificate creates a new certificate based on a template. The
following members of template are used: SerialNumber, Subject, NotBefore,
NotAfter, KeyUsage, BasicConstraintsValid, IsCA, MaxPathLen, SubjectKeyId,
DNSNames, PermittedDNSDomainsCritical, PermittedDNSDomains.
</p>
<p>
The certificate is signed by parent. If parent is equal to template then the
certificate is self-signed. The parameter pub is the public key of the
signee and priv is the private key of the signer.
</p>
<p>
The returned slice is the certificate in DER encoding.
</p>
<p>
The only supported key type is RSA (*rsa.PublicKey for pub, *rsa.PrivateKey
for priv).
</p>

			
		
			
			
			<h2 id="MarshalPKCS1PrivateKey">func <a href="src/pkg/crypto/x509/pkcs1.htm#L77">MarshalPKCS1PrivateKey</a></h2>
			<pre>func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte</pre>
			<p>
MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.
</p>

			
		
			
			
			<h2 id="MarshalPKIXPublicKey">func <a href="src/pkg/crypto/x509/x509.htm#L35">MarshalPKIXPublicKey</a></h2>
			<pre>func MarshalPKIXPublicKey(pub interface{}) ([]byte, error)</pre>
			<p>
MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.
</p>

			
		
			
			
			<h2 id="ParseCRL">func <a href="src/pkg/crypto/x509/x509.htm#L995">ParseCRL</a></h2>
			<pre>func ParseCRL(crlBytes []byte) (certList *pkix.CertificateList, err error)</pre>
			<p>
ParseCRL parses a CRL from the given bytes. It&#39;s often the case that PEM
encoded CRLs will appear where they should be DER encoded, so this function
will transparently handle PEM encoding as long as there isn&#39;t any leading
garbage.
</p>

			
		
			
			
			<h2 id="ParseCertificates">func <a href="src/pkg/crypto/x509/x509.htm#L741">ParseCertificates</a></h2>
			<pre>func ParseCertificates(asn1Data []byte) ([]*Certificate, error)</pre>
			<p>
ParseCertificates parses one or more certificates from the given ASN.1 DER
data. The certificates must be concatenated with no intermediate padding.
</p>

			
		
			
			
			<h2 id="ParseDERCRL">func <a href="src/pkg/crypto/x509/x509.htm#L1006">ParseDERCRL</a></h2>
			<pre>func ParseDERCRL(derBytes []byte) (certList *pkix.CertificateList, err error)</pre>
			<p>
ParseDERCRL parses a DER encoded CRL from the given bytes.
</p>

			
		
			
			
			<h2 id="ParsePKCS1PrivateKey">func <a href="src/pkg/crypto/x509/pkcs1.htm#L29">ParsePKCS1PrivateKey</a></h2>
			<pre>func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err error)</pre>
			<p>
ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.
</p>

			
		
			
			
			<h2 id="ParsePKCS8PrivateKey">func <a href="src/pkg/crypto/x509/pkcs8.htm#L15">ParsePKCS8PrivateKey</a></h2>
			<pre>func ParsePKCS8PrivateKey(der []byte) (key interface{}, err error)</pre>
			<p>
ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key. See
<a href="http://www.rsa.com/rsalabs/node.asp?id=2130">http://www.rsa.com/rsalabs/node.asp?id=2130</a>
</p>

			
		
			
			
			<h2 id="ParsePKIXPublicKey">func <a href="src/pkg/crypto/x509/x509.htm#L22">ParsePKIXPublicKey</a></h2>
			<pre>func ParsePKIXPublicKey(derBytes []byte) (pub interface{}, err error)</pre>
			<p>
ParsePKIXPublicKey parses a DER encoded public key. These values are
typically found in PEM blocks with &#34;BEGIN PUBLIC KEY&#34;.
</p>

			
		
		
			
			
			<h2 id="CertPool">type <a href="src/pkg/crypto/x509/cert_pool.htm#L2">CertPool</a></h2>
			<pre>type CertPool struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
CertPool is a set of certificates.
</p>


			

			

			

			
				
				<h3 id="NewCertPool">func <a href="src/pkg/crypto/x509/cert_pool.htm#L9">NewCertPool</a></h3>
				<pre>func NewCertPool() *CertPool</pre>
				<p>
NewCertPool returns a new, empty CertPool.
</p>

				
			

			
				
				<h3 id="CertPool.AddCert">func (*CertPool) <a href="src/pkg/crypto/x509/cert_pool.htm#L43">AddCert</a></h3>
				<pre>func (s *CertPool) AddCert(cert *Certificate)</pre>
				<p>
AddCert adds a certificate to a pool.
</p>

				
				
			
				
				<h3 id="CertPool.AppendCertsFromPEM">func (*CertPool) <a href="src/pkg/crypto/x509/cert_pool.htm#L72">AppendCertsFromPEM</a></h3>
				<pre>func (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool)</pre>
				<p>
AppendCertsFromPEM attempts to parse a series of PEM encoded certificates.
It appends any certificates found to s and returns true if any certificates
were successfully parsed.
</p>
<p>
On many Linux systems, /etc/ssl/cert.pem will contain the system wide set
of root CAs in a format suitable for this function.
</p>

				
				
			
				
				<h3 id="CertPool.Subjects">func (*CertPool) <a href="src/pkg/crypto/x509/cert_pool.htm#L97">Subjects</a></h3>
				<pre>func (s *CertPool) Subjects() (res [][]byte)</pre>
				<p>
Subjects returns a list of the DER-encoded subjects of
all of the certificates in the pool.
</p>

				
				
			
		
			
			
			<h2 id="Certificate">type <a href="src/pkg/crypto/x509/x509.htm#L279">Certificate</a></h2>
			<pre>type Certificate struct {
    Raw                     []byte <span class="comment">// Complete ASN.1 DER content (certificate, signature algorithm and signature).</span>
    RawTBSCertificate       []byte <span class="comment">// Certificate part of raw ASN.1 DER content.</span>
    RawSubjectPublicKeyInfo []byte <span class="comment">// DER encoded SubjectPublicKeyInfo.</span>
    RawSubject              []byte <span class="comment">// DER encoded Subject</span>
    RawIssuer               []byte <span class="comment">// DER encoded Issuer</span>

    Signature          []byte
    SignatureAlgorithm SignatureAlgorithm

    PublicKeyAlgorithm PublicKeyAlgorithm
    PublicKey          interface{}

    Version             int
    SerialNumber        *big.Int
    Issuer              pkix.Name
    Subject             pkix.Name
    NotBefore, NotAfter time.Time <span class="comment">// Validity bounds.</span>
    KeyUsage            KeyUsage

    ExtKeyUsage        []ExtKeyUsage           <span class="comment">// Sequence of extended key usages.</span>
    UnknownExtKeyUsage []asn1.ObjectIdentifier <span class="comment">// Encountered extended key usages unknown to this package.</span>

    BasicConstraintsValid bool <span class="comment">// if true then the next two fields are valid.</span>
    IsCA                  bool
    MaxPathLen            int

    SubjectKeyId   []byte
    AuthorityKeyId []byte

    <span class="comment">// Subject Alternate Name values</span>
    DNSNames       []string
    EmailAddresses []string

    <span class="comment">// Name constraints</span>
    PermittedDNSDomainsCritical bool <span class="comment">// if true then the name constraints are marked critical.</span>
    PermittedDNSDomains         []string

    PolicyIdentifiers []asn1.ObjectIdentifier
}</pre>
			<p>
A Certificate represents an X.509 certificate.
</p>


			

			

			

			
				
				<h3 id="ParseCertificate">func <a href="src/pkg/crypto/x509/x509.htm#L726">ParseCertificate</a></h3>
				<pre>func ParseCertificate(asn1Data []byte) (*Certificate, error)</pre>
				<p>
ParseCertificate parses a single certificate from the given ASN.1 DER data.
</p>

				
			

			
				
				<h3 id="Certificate.CheckCRLSignature">func (*Certificate) <a href="src/pkg/crypto/x509/x509.htm#L409">CheckCRLSignature</a></h3>
				<pre>func (c *Certificate) CheckCRLSignature(crl *pkix.CertificateList) (err error)</pre>
				<p>
CheckCRLSignature checks that the signature in crl is from c.
</p>

				
				
			
				
				<h3 id="Certificate.CheckSignature">func (*Certificate) <a href="src/pkg/crypto/x509/x509.htm#L365">CheckSignature</a></h3>
				<pre>func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature []byte) (err error)</pre>
				<p>
CheckSignature verifies that signature is a valid signature over signed from
c&#39;s public key.
</p>

				
				
			
				
				<h3 id="Certificate.CheckSignatureFrom">func (*Certificate) <a href="src/pkg/crypto/x509/x509.htm#L339">CheckSignatureFrom</a></h3>
				<pre>func (c *Certificate) CheckSignatureFrom(parent *Certificate) (err error)</pre>
				<p>
CheckSignatureFrom verifies that the signature on c is a valid signature
from parent.
</p>

				
				
			
				
				<h3 id="Certificate.CreateCRL">func (*Certificate) <a href="src/pkg/crypto/x509/x509.htm#L1019">CreateCRL</a></h3>
				<pre>func (c *Certificate) CreateCRL(rand io.Reader, priv interface{}, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error)</pre>
				<p>
CreateCRL returns a DER encoded CRL, signed by this Certificate, that
contains the given list of revoked certificates.
</p>
<p>
The only supported key type is RSA (*rsa.PrivateKey for priv).
</p>

				
				
			
				
				<h3 id="Certificate.Equal">func (*Certificate) <a href="src/pkg/crypto/x509/x509.htm#L333">Equal</a></h3>
				<pre>func (c *Certificate) Equal(other *Certificate) bool</pre>
				
				
				
			
				
				<h3 id="Certificate.Verify">func (*Certificate) <a href="src/pkg/crypto/x509/verify.htm#L145">Verify</a></h3>
				<pre>func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error)</pre>
				<p>
Verify attempts to verify c by building one or more chains from c to a
certificate in opts.Roots, using certificates in opts.Intermediates if
needed. If successful, it returns one or more chains where the first
element of the chain is c and the last element is from opts.Roots.
</p>
<p>
WARNING: this doesn&#39;t do any revocation checking.
</p>

				
				
			
				
				<h3 id="Certificate.VerifyHostname">func (*Certificate) <a href="src/pkg/crypto/x509/verify.htm#L277">VerifyHostname</a></h3>
				<pre>func (c *Certificate) VerifyHostname(h string) error</pre>
				<p>
VerifyHostname returns nil if c is a valid certificate for the named host.
Otherwise it returns an error describing the mismatch.
</p>

				
				
			
		
			
			
			<h2 id="CertificateInvalidError">type <a href="src/pkg/crypto/x509/verify.htm#L24">CertificateInvalidError</a></h2>
			<pre>type CertificateInvalidError struct {
    Cert   *Certificate
    Reason InvalidReason
}</pre>
			<p>
CertificateInvalidError results when an odd error occurs. Users of this
library probably want to handle all these errors uniformly.
</p>


			

			

			

			

			
				
				<h3 id="CertificateInvalidError.Error">func (CertificateInvalidError) <a href="src/pkg/crypto/x509/verify.htm#L29">Error</a></h3>
				<pre>func (e CertificateInvalidError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="ConstraintViolationError">type <a href="src/pkg/crypto/x509/x509.htm#L327">ConstraintViolationError</a></h2>
			<pre>type ConstraintViolationError struct{}</pre>
			<p>
ConstraintViolationError results when a requested usage is not permitted by
a certificate. For example: checking a signature when the public key isn&#39;t a
certificate signing key.
</p>


			

			

			

			

			
				
				<h3 id="ConstraintViolationError.Error">func (ConstraintViolationError) <a href="src/pkg/crypto/x509/x509.htm#L329">Error</a></h3>
				<pre>func (ConstraintViolationError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="ExtKeyUsage">type <a href="src/pkg/crypto/x509/x509.htm#L266">ExtKeyUsage</a></h2>
			<pre>type ExtKeyUsage int</pre>
			<p>
ExtKeyUsage represents an extended set of actions that are valid for a given key.
Each of the ExtKeyUsage* constants define a unique action.
</p>


			
				<pre>const (
    ExtKeyUsageAny ExtKeyUsage = iota
    ExtKeyUsageServerAuth
    ExtKeyUsageClientAuth
    ExtKeyUsageCodeSigning
    ExtKeyUsageEmailProtection
    ExtKeyUsageTimeStamping
    ExtKeyUsageOCSPSigning
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="HostnameError">type <a href="src/pkg/crypto/x509/verify.htm#L45">HostnameError</a></h2>
			<pre>type HostnameError struct {
    Certificate *Certificate
    Host        string
}</pre>
			<p>
HostnameError results when the set of authorized names doesn&#39;t match the
requested name.
</p>


			

			

			

			

			
				
				<h3 id="HostnameError.Error">func (HostnameError) <a href="src/pkg/crypto/x509/verify.htm#L50">Error</a></h3>
				<pre>func (h HostnameError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="InvalidReason">type <a href="src/pkg/crypto/x509/verify.htm#L4">InvalidReason</a></h2>
			<pre>type InvalidReason int</pre>
			

			
				<pre>const (
    <span class="comment">// NotAuthorizedToSign results when a certificate is signed by another</span>
    <span class="comment">// which isn&#39;t marked as a CA certificate.</span>
    NotAuthorizedToSign InvalidReason = iota
    <span class="comment">// Expired results when a certificate has expired, based on the time</span>
    <span class="comment">// given in the VerifyOptions.</span>
    Expired
    <span class="comment">// CANotAuthorizedForThisName results when an intermediate or root</span>
    <span class="comment">// certificate has a name constraint which doesn&#39;t include the name</span>
    <span class="comment">// being checked.</span>
    CANotAuthorizedForThisName
    <span class="comment">// TooManyIntermediates results when a path length constraint is</span>
    <span class="comment">// violated.</span>
    TooManyIntermediates
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="KeyUsage">type <a href="src/pkg/crypto/x509/x509.htm#L228">KeyUsage</a></h2>
			<pre>type KeyUsage int</pre>
			<p>
KeyUsage represents the set of actions that are valid for a given key. It&#39;s
a bitmap of the KeyUsage* constants.
</p>


			
				<pre>const (
    KeyUsageDigitalSignature KeyUsage = 1 &lt;&lt; iota
    KeyUsageContentCommitment
    KeyUsageKeyEncipherment
    KeyUsageDataEncipherment
    KeyUsageKeyAgreement
    KeyUsageCertSign
    KeyUsageCRLSign
    KeyUsageEncipherOnly
    KeyUsageDecipherOnly
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="PublicKeyAlgorithm">type <a href="src/pkg/crypto/x509/x509.htm#L128">PublicKeyAlgorithm</a></h2>
			<pre>type PublicKeyAlgorithm int</pre>
			

			
				<pre>const (
    UnknownPublicKeyAlgorithm PublicKeyAlgorithm = iota
    RSA
    DSA
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="SignatureAlgorithm">type <a href="src/pkg/crypto/x509/x509.htm#L114">SignatureAlgorithm</a></h2>
			<pre>type SignatureAlgorithm int</pre>
			

			
				<pre>const (
    UnknownSignatureAlgorithm SignatureAlgorithm = iota
    MD2WithRSA
    MD5WithRSA
    SHA1WithRSA
    SHA256WithRSA
    SHA384WithRSA
    SHA512WithRSA
    DSAWithSHA1
    DSAWithSHA256
)</pre>
				
			

			

			

			

			
		
			
			
			<h2 id="UnhandledCriticalExtension">type <a href="src/pkg/crypto/x509/x509.htm#L414">UnhandledCriticalExtension</a></h2>
			<pre>type UnhandledCriticalExtension struct{}</pre>
			

			

			

			

			

			
				
				<h3 id="UnhandledCriticalExtension.Error">func (UnhandledCriticalExtension) <a href="src/pkg/crypto/x509/x509.htm#L416">Error</a></h3>
				<pre>func (h UnhandledCriticalExtension) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="UnknownAuthorityError">type <a href="src/pkg/crypto/x509/verify.htm#L62">UnknownAuthorityError</a></h2>
			<pre>type UnknownAuthorityError struct {
    <span class="comment">// contains filtered or unexported fields</span>
}</pre>
			<p>
UnknownAuthorityError results when the certificate issuer is unknown
</p>


			

			

			

			

			
				
				<h3 id="UnknownAuthorityError.Error">func (UnknownAuthorityError) <a href="src/pkg/crypto/x509/verify.htm#L66">Error</a></h3>
				<pre>func (e UnknownAuthorityError) Error() string</pre>
				
				
				
			
		
			
			
			<h2 id="VerifyOptions">type <a href="src/pkg/crypto/x509/verify.htm#L72">VerifyOptions</a></h2>
			<pre>type VerifyOptions struct {
    DNSName       string
    Intermediates *CertPool
    Roots         *CertPool <span class="comment">// if nil, the system roots are used</span>
    CurrentTime   time.Time <span class="comment">// if zero, the current time is used</span>
}</pre>
			<p>
VerifyOptions contains parameters for Certificate.Verify. It&#39;s a structure
because other PKIX verification APIs have ended up needing many options.
</p>


			

			

			

			

			
		
		</div>
	

	







	
	
		<h2 id="subdirectories">Subdirectories</h2>
	
	<table class="dir">
	<tr>
	<th>Name</th>
	<th>&nbsp;&nbsp;&nbsp;&nbsp;</th>
	<th style="text-align: left; width: auto">Synopsis</th>
	</tr>

		
			<tr>
			<td class="name"><a href="crypto_x509_pkix.htm">pkix</a></td>
			<td>&nbsp;&nbsp;&nbsp;&nbsp;</td>
			<td style="width: auto">Package pkix contains shared, low level structures used for ASN.1 parsing and serialization of X.509 certificates, CRL and OCSP.</td>
			</tr>
		
	
	</table>
	



</div>

<div id="footer">
Build version go1.0.1.<br>
Except as <a href="http://code.google.com/policies.html#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="/doc/tos.html">Terms of Service</a> | 
<a href="http://www.google.com/intl/en/privacy/privacy-policy.html">Privacy Policy</a>
</div>

<script type="text/javascript">
(function() {
  var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
  ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
  var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
})();
</script>
</body>
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
</html>
